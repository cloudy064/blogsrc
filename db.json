{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.jpg","path":"favicon.jpg","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/favicon.jpg","hash":"70dd00d587646a479e35288a373ac532b588fb2a","modified":1529925065957},{"_id":"source/robots.txt","hash":"43b0aab7022cef694d3b47b9f8c494967e74ec36","modified":1529925065960},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1529925066055},{"_id":"themes/next/.gitignore","hash":"63d003fa46cf9665b4dab1786f9dc694812a5a79","modified":1529925066056},{"_id":"themes/next/.bowerrc","hash":"20038353db532b4c40625419d396da7359f89cbe","modified":1529925066054},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1529925066056},{"_id":"themes/next/.javascript_ignore","hash":"beb0b95736650284ceb712a162cc033847a83cd3","modified":1529925066057},{"_id":"themes/next/README.en.md","hash":"fa31bbc6dd8778b8dee469740c92b3b5b59702af","modified":1529925066059},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1529925066058},{"_id":"themes/next/_config.yml","hash":"3ff8d17f4013ca7b64d1e323f13b61ba9bf49bd5","modified":1530015080198},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1529925066060},{"_id":"themes/next/bower.json","hash":"da39b00fcdf2e7a42af412de0a4d3617cc6d7084","modified":1529925066061},{"_id":"themes/next/gulpfile.coffee","hash":"4e8c1082fa82e383494ff5b5963b7936d9c7bb2e","modified":1529925066062},{"_id":"themes/next/package.json","hash":"95eaba1607544965e432d56406bae391dd11bcbb","modified":1529925066114},{"_id":"source/categories/index.md","hash":"f2b6ff2c43fa7d697e64af4478e237cfb6ceeef1","modified":1529925065956},{"_id":"source/images/avatar.jpg","hash":"70dd00d587646a479e35288a373ac532b588fb2a","modified":1529925065959},{"_id":"source/tags/index.md","hash":"69f9ecb2237e74d41231ff8a140ec48d1189e7dc","modified":1529925065961},{"_id":"themes/next/languages/de.yml","hash":"4c3ffeb0d214c807a226dd98214958cb5483df1c","modified":1529925066063},{"_id":"themes/next/languages/default.yml","hash":"d2f6784b9c6567b64e58736e36025dbf96d863d4","modified":1529925066064},{"_id":"themes/next/languages/en.yml","hash":"df81ab6b1cf3c88ed053d3766381cd12eb659fe3","modified":1529925066064},{"_id":"themes/next/languages/fr-FR.yml","hash":"d8a40fe025fad6f42df0cf16d4be2d513769b062","modified":1529925066065},{"_id":"themes/next/languages/id.yml","hash":"19537c8bae42c4c2e7d06a64537e8dfd503b7e19","modified":1529925066066},{"_id":"themes/next/languages/ja.yml","hash":"e594aa42a33c489e4a65065659a01bb76c3c0cb5","modified":1529925066067},{"_id":"themes/next/languages/pt.yml","hash":"4c64594f477905d5d2d9ca2422f03175b7b0c617","modified":1529925066068},{"_id":"themes/next/languages/ru.yml","hash":"c3aedb94decf05a301662afc3398ab563dd9995a","modified":1529925066069},{"_id":"themes/next/languages/zh-Hans.yml","hash":"23b45e77c1846c9457b98c745a60a9461678c389","modified":1529925066070},{"_id":"themes/next/languages/zh-hk.yml","hash":"88e603eb0f3fd25c35bb37bd30372fd77bba7c46","modified":1529925066071},{"_id":"themes/next/languages/zh-tw.yml","hash":"04479b419c72b71fd34046f3fc33ebda4fe8de84","modified":1529925066072},{"_id":"themes/next/layout/_layout.swig","hash":"1138b849e1240249480849cc2b6c6d09b28207a5","modified":1529925066073},{"_id":"themes/next/layout/category.swig","hash":"58cf08388901f7549b1fca95548b2c79173aa840","modified":1529925066110},{"_id":"themes/next/layout/archive.swig","hash":"b867a08f6b43de8b5d700c84b943df55917407ae","modified":1529925066109},{"_id":"themes/next/layout/index.swig","hash":"fec0e6e8748b8d3381565dcfae5c4c8644a50247","modified":1529925066111},{"_id":"themes/next/layout/page.swig","hash":"a91e3fd7aef26e8a02e339e3372801c517f400cf","modified":1529925066112},{"_id":"themes/next/layout/tag.swig","hash":"6f764ea3ab11eeb7c530df45528d449b14f5dc62","modified":1529925066113},{"_id":"themes/next/layout/post.swig","hash":"b8334c479840b7724638eec71971cbd8512ae58d","modified":1529925066112},{"_id":"themes/next/scripts/merge-configs.js","hash":"f8cde6953939802f92da5b7a2458c6c539e9be69","modified":1529925066115},{"_id":"themes/next/test/.jshintrc","hash":"1dae9d1cf7df1ae6d5c5efd6cffb949e9b8dcebb","modified":1529925066294},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1529925066295},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1529925066296},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529925066221},{"_id":"source/_posts/inject/2016-07-14-remote-inject.md","hash":"3240bae50575185a26f3b095980c93275e465bd7","modified":1529925353213},{"_id":"source/_posts/hexo/2016-06-20-build-blog-with-hexo.md","hash":"074540b523797de7a18b53381a281d3b82112986","modified":1529925382613},{"_id":"source/_posts/leetcode/2016-10-18-leetcode-chapter1.md","hash":"6cf2ab0de105302d6291d5a9903fc7c1dc200c0c","modified":1530014827138},{"_id":"source/_posts/leetcode/2018-06-26-leetcode-chapter2.md","hash":"78f494354ad0c09fccc05f2eb92401e57097f2e4","modified":1530014703446},{"_id":"source/_posts/windbg/windbg-chapter1.md","hash":"2da1f21bf8b6635c99dba7f8d8e27fef131e1db5","modified":1529925289163},{"_id":"source/_posts/windbg/windbg-chapter2.md","hash":"a94cdba4b95da5bd112e0caa46031d8cfb611611","modified":1529925289163},{"_id":"source/_posts/windbg/windbg-chapter3.md","hash":"5743290c56617a5cd9ab29bb0d6e9f14c6ff3587","modified":1529925289163},{"_id":"source/_posts/windbg/windbg-chapter4.md","hash":"ce65bcb80b33bf740ef086289d4c7a6a11500f23","modified":1529925289164},{"_id":"source/_posts/windbg/windbg-chapter5.md","hash":"5e2012e136504be20ef8538f4bd61c627ee2d96f","modified":1529925289164},{"_id":"source/_posts/windbg/windbg-extra1.md","hash":"2d4ff8aa2ddf8fdc950c292ff46e0d528d201ad8","modified":1529925289164},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"b87a5122dbff1d5fccf8f3d09d1640bd4b01c4a0","modified":1529925066074},{"_id":"themes/next/layout/_macro/post.swig","hash":"843389ec3cb4c2baa6a6a2bb916f803c89ca723b","modified":1529925066075},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5d84f3938e99f1908a6a1d44dd530740625f0188","modified":1529925066078},{"_id":"themes/next/layout/_macro/reward.swig","hash":"b6cb171f0ed227b82b8f7601814af2df93f3a09a","modified":1529925066075},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"d569af20d20a960d534a5b60f90c20fef519d351","modified":1529925066077},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9fc9f89c169439d7584197930359b758eb198a1c","modified":1529925066076},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1529925066079},{"_id":"themes/next/layout/_partials/footer.swig","hash":"27669118b957e8a39d843b63dddf561c9d62b336","modified":1529925066079},{"_id":"themes/next/layout/_partials/head.swig","hash":"881abebed3a7fa71827365b0ba0e84ec525eeb7f","modified":1529925066080},{"_id":"themes/next/layout/_partials/header.swig","hash":"46f8bbe51c0334c64c3a237bc0fe8ef73c6e58e1","modified":1529925066082},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1529925066084},{"_id":"themes/next/layout/_partials/search.swig","hash":"95b55fe35f2d2c22f2cc055d4379b5435314c7ec","modified":1529925066085},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c5db707b46eac6a5df1d2a77f8556945a66fd181","modified":1529925066091},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1529925066092},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1529925066093},{"_id":"themes/next/layout/_scripts/lean-analytics.swig","hash":"19afa1a4a829d6b789d0b87ecb0f4dbd6dc7e5df","modified":1529925066094},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"c9d45628330ce8bf5fbe71c9f131c7d75334c1c4","modified":1529925066109},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1529925066116},{"_id":"themes/next/scripts/tags/full-image.js","hash":"86194a05a8c6499de0b2aaa525d6de135778c0ae","modified":1529925066117},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1529925066117},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1529925066223},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1529925066222},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1529925066224},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1529925066225},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1529925066226},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1529925066226},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1529925066227},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1529925066229},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1529925066230},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1529925066229},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1529925066232},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1529925066231},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1529925066233},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1529925066221},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529925066095},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529925066095},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529925066166},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529925066166},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529925066168},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529925066218},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1529925066220},{"_id":"source/_posts/windbg/windbg-chapter1/aftera10.png","hash":"1ada02ab73eac1f44ba0ec418a39df240c69e3ff","modified":1529925065813},{"_id":"source/_posts/windbg/windbg-chapter1/afterda30.png","hash":"3d0dedcc0ce36204f56f048eb5d3cb1d060fccbe","modified":1529925065814},{"_id":"source/_posts/windbg/windbg-chapter1/afterrepstos.png","hash":"05c3ef6236fd3df1709317b7ec45fe2765aab5d0","modified":1529925065815},{"_id":"source/_posts/windbg/windbg-chapter1/afterrepstosmem.png","hash":"03b611c399aa0557d095cc395c86ab6b35469825","modified":1529925065816},{"_id":"source/_posts/windbg/windbg-chapter1/callstack.png","hash":"50eefeb3146b85fd799a820a265be3a67c2d194b","modified":1529925065819},{"_id":"source/_posts/windbg/windbg-chapter1/callstackstatus.png","hash":"c3f84c96ec2df1ed2b3f479a73c08b99c71acb99","modified":1529925065820},{"_id":"source/_posts/windbg/windbg-chapter1/checkesp.png","hash":"49c0949b200e1481c5e6dd21e3a70c6feb8144aa","modified":1529925065821},{"_id":"source/_posts/windbg/windbg-chapter1/disassembly.png","hash":"c2da8b2c8d8e1d519785a73811bd9f562485dbe0","modified":1529925065822},{"_id":"source/_posts/windbg/windbg-chapter1/pushebp.png","hash":"36812c0d93ef229bcfe5d3c60fcb83b3b1f296fc","modified":1529925065823},{"_id":"source/_posts/windbg/windbg-chapter1/pushebxesiedi.png","hash":"52796c4629af4238f02e714650e58975119096bf","modified":1529925065824},{"_id":"source/_posts/windbg/windbg-chapter1/pushresult.png","hash":"a82ea8c03e3f7ddf3402c8f74bda27423232f32a","modified":1529925065825},{"_id":"source/_posts/windbg/windbg-chapter1/registers.png","hash":"d786dc63787a6625967d628e610021c82c0934a8","modified":1529925065826},{"_id":"source/_posts/windbg/windbg-chapter1/testfuncsource.png","hash":"2df3ac0f708a0066f13aa991cbf0ef925b462001","modified":1529925065831},{"_id":"source/_posts/windbg/windbg-chapter1/stackmemory.png","hash":"a227d19024656d326f0c002a0d6fe12698c840e3","modified":1529925065830},{"_id":"source/_posts/windbg/windbg-chapter2/AfterCallTestReturnStack.png","hash":"397f68e6b53401e366d2337b69970ac01a2fc7e3","modified":1529925065834},{"_id":"source/_posts/windbg/windbg-chapter2/AfterCallTestReturn.png","hash":"f0011e34f593f9339908578914650d991602b80f","modified":1529925065833},{"_id":"source/_posts/windbg/windbg-chapter2/BeforeCallTestReturn.png","hash":"126fafa08b6d53a99621fdc043d03816655dc215","modified":1529925065836},{"_id":"source/_posts/windbg/windbg-chapter2/BeforeCallTestReturnStack.png","hash":"43ae7abb7e283864b5ce7fd431456b6da59f57aa","modified":1529925065837},{"_id":"source/_posts/windbg/windbg-chapter2/CallTestConstReference.png","hash":"f563d14336e0c56b06ce97f0c48fac3931a342da","modified":1529925065838},{"_id":"source/_posts/windbg/windbg-chapter2/CallTestPointer.png","hash":"46aa9bb532b8feb9f172f4520078659dccdecbfa","modified":1529925065839},{"_id":"source/_posts/windbg/windbg-chapter2/CallTestReference.png","hash":"9bab798b147982a54777672ad4d0a3ddb274055b","modified":1529925065840},{"_id":"source/_posts/windbg/windbg-chapter2/CallTestValue.png","hash":"5e38e018521a531b1dbfd34f2704270e73ace120","modified":1529925065841},{"_id":"source/_posts/windbg/windbg-chapter2/InitSimple.png","hash":"d6089453e90542c78c043f2a84163efcb0a9d5ee","modified":1529925065842},{"_id":"source/_posts/windbg/windbg-chapter2/SimpleStructMemory.png","hash":"adc869feb4f393189e9135fcf54dc99f67fbff14","modified":1529925065843},{"_id":"source/_posts/windbg/windbg-chapter2/begin.png","hash":"7bad97faeb75cc867ac0d501202e80f8ae0c029c","modified":1529925065845},{"_id":"source/_posts/windbg/windbg-chapter2/ddebp-14hL4.png","hash":"54cd5c43213ea54811453eb2c4b78b2f9576c132","modified":1529925065846},{"_id":"source/_posts/windbg/windbg-chapter3/ActualValueForCmp.png","hash":"4910955731ecc64fac00ab4deefc3941bb261c6e","modified":1529925065850},{"_id":"source/_posts/windbg/windbg-chapter2/ddebp-2ChL4.png","hash":"a63864a38e85e8aaaca0b5d395ecb287eda6bf64","modified":1529925065847},{"_id":"source/_posts/windbg/windbg-chapter2/dtHelloWorld2005Simple.png","hash":"1d5625a78957940d0d90a82187724419ca0b7170","modified":1529925065848},{"_id":"source/_posts/windbg/windbg-chapter3/AfterCmpOperation.png","hash":"2f53fcbef85a3aca2a0683e7534f0e7f9a4109e8","modified":1529925065851},{"_id":"source/_posts/windbg/windbg-chapter3/AllRegisters.png","hash":"602632016d9ff05d074efa764402b5f50bea4e7b","modified":1529925065853},{"_id":"source/_posts/windbg/windbg-chapter3/CmpResult.png","hash":"5ea7066689dc6ab06820c3a5f7437935e024843c","modified":1529925065855},{"_id":"source/_posts/windbg/windbg-chapter3/DtSimpleClass.png","hash":"6862d82767f58227926a28b2f4172b25b81ec25a","modified":1529925065857},{"_id":"source/_posts/windbg/windbg-chapter3/DynamicInitializerForK.png","hash":"bd1353400721115792407f308e6b401efc542242","modified":1529925065863},{"_id":"source/_posts/windbg/windbg-chapter3/HelloWorld2005PreCppInit.png","hash":"4e176853c602fbacc1b1b58fb8e72d26010f61c5","modified":1529925065868},{"_id":"source/_posts/windbg/windbg-chapter3/HitConstructorBreakPoint.png","hash":"c9a562342cd9ee60f220f7eb7693f6f19f1f8a4c","modified":1529925065870},{"_id":"source/_posts/windbg/windbg-chapter3/GlobalVarCallStack.png","hash":"468eb54ded2f6404d9a54c353e41358f21f66811","modified":1529925065865},{"_id":"source/_posts/windbg/windbg-chapter3/InInitTermFunction.png","hash":"7d583d2ebe4e5f8bec81b77c9ea440f07f3eec0d","modified":1529925065872},{"_id":"source/_posts/windbg/windbg-chapter3/InitTermJmpBackToFuncHead.png","hash":"6a7abf39307f969220b3675ef2d6791e52a58fd7","modified":1529925065875},{"_id":"source/_posts/windbg/windbg-chapter3/MainCallTestStatic.png","hash":"f443376ff000970af6966921a4ee03dec501b5af","modified":1529925065877},{"_id":"source/_posts/windbg/windbg-chapter3/MainCallTestVirtual.png","hash":"d78c1971b86d75437b1c57197d26b94f572374fb","modified":1529925065879},{"_id":"source/_posts/windbg/windbg-chapter3/MainSimpleClassJ=233.png","hash":"d4777dc6043400caa3bfa01b735a3f1a2e15b148","modified":1529925065884},{"_id":"source/_posts/windbg/windbg-chapter3/MainCompareTestAndTestConst.png","hash":"658221b280f7a378b667e6d24a082e8fa9620045","modified":1529925065881},{"_id":"source/_posts/windbg/windbg-chapter3/MainSimpleClassJ=233Stack.png","hash":"81c41b88d74e283b9b07ab9f538e708116dfaaf2","modified":1529925065886},{"_id":"source/_posts/windbg/windbg-chapter3/PreCppInitDtValueResult.png","hash":"b977cd122e4027e099ad6c6c5865b836b006eac4","modified":1529925065888},{"_id":"source/_posts/windbg/windbg-chapter3/PreCppInitDvResult.png","hash":"95e74a3a8b7c088069b25bee86cd4d4accecc7e4","modified":1529925065890},{"_id":"source/_posts/windbg/windbg-chapter3/SetConstructorBreakPoint.png","hash":"5457da66f7afd00a6b9a36fd27597fa4e4a4c1f8","modified":1529925065892},{"_id":"source/_posts/windbg/windbg-chapter3/SimpleClassConstructorCode.png","hash":"0c342c022ec003065491cc0505ee8a719f4c23d7","modified":1529925065895},{"_id":"source/_posts/windbg/windbg-chapter3/SimpleClassCopyConstructorCode.png","hash":"7ded1f16b8b8c58b7a975184b128724bb9f90fb9","modified":1529925065898},{"_id":"source/_posts/windbg/windbg-chapter3/SimpleClassMemoryMap.png","hash":"b0440b7899f574132feb69d722971c50a8f8f2ef","modified":1529925065900},{"_id":"source/_posts/windbg/windbg-chapter3/SimpleClassThisPointToMemory.png","hash":"a14de9b822aeb39f5ec0621ecceb588857196e77","modified":1529925065902},{"_id":"source/_posts/windbg/windbg-chapter3/TestDeriveCtorBeforeBaseCtorStackMemory.png","hash":"a83251da4635416f097d7d6fc777d3c629b0871a","modified":1529925065904},{"_id":"source/_posts/windbg/windbg-chapter3/da0040412c.png","hash":"155effd833b3b696ab2bb851b4dff806feae2875","modified":1529925065910},{"_id":"source/_posts/windbg/windbg-chapter3/dd00406000.png","hash":"1b65a703f42c9e70db292089430b7d24c456e3ae","modified":1529925065912},{"_id":"source/_posts/windbg/windbg-chapter3/lmvmHelloWorld2005.png","hash":"0485fe54fdb275434e9cb2d358e1dc957094a5d6","modified":1529925065913},{"_id":"source/_posts/windbg/windbg-chapter4/NormalFunc1Addresses.png","hash":"cebd66abd8f33d57968c21f7a588c97c323203d9","modified":1529925065923},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseContentOfVirtualTable.png","hash":"159c6502f26b3e0026b42f13ecbd423778ccdfe4","modified":1529925065927},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseLookupThis.png","hash":"d75493372b791b685915ea4ad7a1affbcf002f12","modified":1529925065929},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseVcall0.png","hash":"a1491e3eca261af0dd2fa1f470ddd2379f83d186","modified":1529925065930},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseVirtualFunc2Function.png","hash":"3d14e54e113998f82082f2c9b154d13e76801970","modified":1529925065932},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseVirtualFunctionsAddress.png","hash":"5b3e5fe5cd20664663e0ef5c61ea3ae878802a3c","modified":1529925065933},{"_id":"source/_posts/windbg/windbg-chapter4/TestDeriveAfterAssignVftable.png","hash":"240acbeb29b0f87ba289df869aec20970fe8d179","modified":1529925065934},{"_id":"source/_posts/windbg/windbg-chapter4/TestDeriveVtableContent.png","hash":"03ba1be97351ee079c48796fa9799578ca2de773","modified":1529925065937},{"_id":"source/_posts/windbg/windbg-chapter4/TestDeriveVirtualFunctionAddress.png","hash":"c52bb4615ffa3be44ac31baac6da375489b8a7dd","modified":1529925065936},{"_id":"source/_posts/windbg/windbg-chapter4/dtTestBase.png","hash":"ed639b060397da206d947cf7b81f0d5dd685d499","modified":1529925065938},{"_id":"source/_posts/windbg/windbg-chapter4/dtTestDerive.png","hash":"2c8b6266d22ca5dfe72e3e89e03840bf753e1bd9","modified":1529925065939},{"_id":"source/_posts/windbg/windbg-chapter5/VirtualFunc1Code.png","hash":"7257a62c809060cb5dc11c42191a830b1143fe46","modified":1529925065941},{"_id":"source/_posts/windbg/windbg-chapter5/contentofecx.png","hash":"53a968bb7e9d4bb94383bb85d22c56437c8ae63b","modified":1529925065943},{"_id":"source/_posts/windbg/windbg-chapter5/beforedconstructorstack.png","hash":"70b88edb9024f0029845715d254fbe650623a17a","modified":1529925065942},{"_id":"source/_posts/windbg/windbg-chapter5/contentofobjectd.png","hash":"8f6ffe4301d10a351fee2c195d665825371a4371","modified":1529925065944},{"_id":"source/_posts/windbg/windbg-chapter5/inderiveconstructorstack.png","hash":"010275c524c8ed55b40094e22f624cfd5c7886ce","modified":1529925065947},{"_id":"source/_posts/windbg/windbg-chapter5/linkoptions.png","hash":"a562658a18adc4841b6b51b2a0f0e3583cc0c8ec","modified":1529925065950},{"_id":"source/_posts/windbg/windbg-chapter5/superconstructor.png","hash":"cada05ee42df2b8958cab6201a041293d43eb09f","modified":1529925065951},{"_id":"source/_posts/windbg/windbg-chapter5/vbtablecontent.png","hash":"7996554836706bc5e2c59cdc533af18cf9f3e4dd","modified":1529925065952},{"_id":"source/_posts/windbg/windbg-chapter5/vsoptions.png","hash":"7d6945ed3956daffbdfe7660374c1733adfaac30","modified":1529925065953},{"_id":"source/_posts/windbg/windbg-extra1/vftables.png","hash":"2ce02a29f1fe4ab0600eb0c462aab7a08bd3140d","modified":1529925065955},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1529925066081},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"efa7efcbb575381b508f9aa0e0c53140eef72a7b","modified":1529925066086},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1529925066086},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1529925066087},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"bf8e9223a40748b2e3ef77d753a8e1dbbce8095e","modified":1529925066088},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"3fdde03f45a80f7a85097a40b40358adde618fc7","modified":1529925066089},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1529925066090},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1529925066090},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1529925066095},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1529925066096},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"91c5353fcb94cc3b3f265b06ad2341734bc4c826","modified":1529925066097},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"8ba01f1ac07fbca62a4b00f5a0a3a506122c1530","modified":1529925066102},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"e495aed8fb36bf8015ddbd64366270a7debad2b0","modified":1529925066105},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"5bd98c26cc188a2a30504d1330a0eaae34034db0","modified":1529925066106},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1529925066108},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"4a5c6df1579a4ca72ed17f7dbd6d16a509aa7dc8","modified":1529925066107},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1529925066165},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1529925066167},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"531934ea21ef4dc9f0978512050f54834f0a6cff","modified":1529925066168},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1529925066218},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"b8e3663996b39590509d843f674360872b0242ac","modified":1529925066219},{"_id":"themes/next/source/css/_variables/base.styl","hash":"a7ae72e846393493385275d934eaa78534d9834c","modified":1529925066220},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1529925066234},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"4a0da1bed19e65bd7db42421b447061bc1618710","modified":1529925066235},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1529925066237},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1529925066236},{"_id":"themes/next/source/js/src/post-details.js","hash":"458af3b1bd7783c1950808e66cedfa9fb68bf21f","modified":1529925066237},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1529925066255},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1529925066239},{"_id":"themes/next/source/js/src/utils.js","hash":"418d09eb4df5dcc5e8d13d7f6245b1888200b51c","modified":1529925066240},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1529925066256},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1529925066257},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1529925066257},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1529925066277},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1529925066262},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"bb093f2ac1f1305069d873a7941324c8e0de3135","modified":1529925066260},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1529925066261},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1529925066263},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1529925066263},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1529925066279},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1529925066280},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1529925066281},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1529925066282},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1529925066282},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1529925066283},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1529925066287},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1529925066288},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1529925066292},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1529925066292},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1529925066293},{"_id":"source/_posts/hexo/2016-06-20-build-blog-with-hexo/generatesshkey.png","hash":"5dc494e498c08716c97a101f3d69d30efb56a024","modified":1529925065776},{"_id":"source/_posts/hexo/2016-06-20-build-blog-with-hexo/newrepository.png","hash":"9c8affff2b5c8774b0052efffe87bce2715082d1","modified":1529925065783},{"_id":"source/_posts/inject/2016-07-14-remote-inject/inject_result.jpg","hash":"4750899f4ad6b47b9dfde501b5f3df2c585292d1","modified":1529925065796},{"_id":"source/_posts/windbg/windbg-chapter1/runexe.png","hash":"e889da6a95c8a4f95190c9574b953d45f41a806b","modified":1529925065827},{"_id":"source/_posts/windbg/windbg-chapter2/AfterTestReturnReturn.png","hash":"c99adc229e00330c36a0fba76e062172deded407","modified":1529925065835},{"_id":"source/_posts/windbg/windbg-chapter2/TestReturnAssembly.png","hash":"b23d3a0c27c14e78cb18a79c76f5d3a2b0341459","modified":1529925065844},{"_id":"source/_posts/windbg/windbg-chapter3/DumpHelloWorldHeaders.png","hash":"ae1e86c495ac8123699131bc2d8e0325040f529a","modified":1529925065860},{"_id":"source/_posts/windbg/windbg-chapter3/s-saHelloWorld2005+4000L115C.png","hash":"623e912adaf9bfe50e062eea5d85b1ce890a93e2","modified":1529925065915},{"_id":"source/_posts/windbg/windbg-chapter4/FirstClassVariable.png","hash":"fc2e9b05cd0b4e323fa197cb80aefa37096a38ae","modified":1529925065922},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseConstructor.png","hash":"37dcc69daf58f92ef959cb6e37c922ab51561d17","modified":1529925065925},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseInitSequence.png","hash":"7e30f9c83fbf07a8095d326efe5e3caf94a7673d","modified":1529925065928},{"_id":"source/_posts/windbg/windbg-chapter4/TestDeriveConstructor.png","hash":"896876b7772b1ac7d422af6b5b381e1629a4191e","modified":1529925065935},{"_id":"source/_posts/windbg/windbg-chapter5/firststep.png","hash":"7d2580b88bea62394d61e62554d17ecf49ae06db","modified":1529925065945},{"_id":"source/_posts/windbg/windbg-chapter5/inderiveconstructor.png","hash":"fdc498333797c986f58ba39b8e20455557ba2311","modified":1529925065946},{"_id":"source/_posts/windbg/windbg-chapter5/jumpoversupercall.png","hash":"50d697d65b42a72cd7a75e8606dca0fc2af2b609","modified":1529925065949},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1529925066278},{"_id":"source/_posts/hexo/2016-06-20-build-blog-with-hexo/getrepositoryaddress.png","hash":"5b7b74324538a911ca23b5d188adc98fc0d1ffef","modified":1529925065779},{"_id":"source/_posts/inject/2016-07-14-remote-inject/explorer_kernel32_address.jpg","hash":"cb96086bc275354a80237ae8b48757d28525de31","modified":1529925065794},{"_id":"source/_posts/windbg/windbg-chapter1/breakpoint.png","hash":"95410b677e4bc49085e7d62fd73adcb16e1d852e","modified":1529925065818},{"_id":"source/_posts/windbg/windbg-chapter1/sourcemode.png","hash":"9ee0b512b2b187af4e3ed85be6d2082e8f16e773","modified":1529925065829},{"_id":"source/_posts/windbg/windbg-chapter3/ThePlaceWhereCallMain.png","hash":"8718f5e21771bf1e2cb7bc0e2e02513c9aa4d1fa","modified":1529925065908},{"_id":"source/_posts/windbg/windbg-chapter4/AssignMemberFuncPointer.png","hash":"489ce2eb63e21a9dc14a8b71f585538b030443fd","modified":1529925065920},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"24105e62d7f26946907fa14cd02589f899bf8122","modified":1529925066099},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"ae5b8597603d4e42ee66ed121544e7b1c644767e","modified":1529925066098},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"3931f9c3bac3970a3f54c9d0072ae4c950aa176c","modified":1529925066099},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"a79e7e0d809fcf407593dd7ed9e023db21c3cbd6","modified":1529925066100},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"1b6af02fd0ba3f729675cd95429a0cea4aebf358","modified":1529925066101},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1529925066102},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"f8b6a3017ab79057ce99f1ccb512193d67f4a35f","modified":1529925066103},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"2338be12ffee58bc08197cb9da8aaf31737aaf5c","modified":1529925066104},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ad69cbf94eedacc27e756cdb9c7073416db697d0","modified":1529925066119},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1529925066120},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1529925066121},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"b7d5cc29586ac796a50d90974ad99d24a5982137","modified":1529925066121},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1529925066132},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1529925066150},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1529925066159},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5a35aa0381b0e1d465b952a997194441020446ea","modified":1529925066160},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"b6ee5fefa6046086a76ddbcfafc82482816fa3e0","modified":1529925066161},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1529925066163},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1529925066162},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1529925066164},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1529925066170},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1529925066172},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"55b44e03054cd20ed8129bf986b15fba5fd85aad","modified":1529925066176},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1529925066171},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1529925066175},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1529925066177},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1529925066203},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1529925066208},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"124b540f059fd1ed13514362007cfc70355278c6","modified":1529925066207},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"13af2fb21fabfc4df4b577ce5363e13d03daff71","modified":1529925066208},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1529925066209},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c9875c010bebd77b4f59d459a10455fceb0a66a1","modified":1529925066212},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"de31e923bf5102498f06b1ae6bdf2ea22409f3e0","modified":1529925066213},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1529925066210},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"2182a6da3434a6fd4d03ab1592c645d3d3c88500","modified":1529925066213},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"9887bd3894db5394c1e64e800afaae55f47e8dd0","modified":1529925066215},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1529925066216},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"983c0723e8cfd84b67c2e66da0c26425a8db06e0","modified":1529925066216},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"88a5e0e95f93e4adb196bff1aac17d6cfb03768a","modified":1529925066217},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"a9d064d600ee35acd66508167e1ac8c6cfdbdcd8","modified":1529925066238},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1529925066242},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1529925066243},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1529925066243},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1529925066244},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1529925066245},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1529925066246},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1529925066252},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1529925066259},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1529925066253},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1529925066254},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1529925066259},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"811432ad1e2d6c1f6da9a63fd919bf2a02b71dd9","modified":1529925066265},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1529925066265},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"4c2c5f5f6cc86d775a44b944661e038b7be98149","modified":1529925066266},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1529925066276},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1529925066285},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1529925066285},{"_id":"source/_posts/inject/2016-07-14-remote-inject/devenv_kernel32_address.jpg","hash":"5c4f5bfd76a80109ca87306db24110756130d754","modified":1529925065790},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1529925066269},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1529925066270},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1529925066274},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1529925066291},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1529925066124},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1529925066123},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"852fd77500bda2c1a6651a14aa48d7d6222adc9d","modified":1529925066125},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1529925066126},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1529925066126},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"70ec8d38d2b3ee1906793d1dcb68032adfa65f03","modified":1529925066128},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1529925066122},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1529925066130},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"12e366f04497e3f44388fd40111a03e02f7c26af","modified":1529925066129},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a45f5fce643eec4e1b927165229d560364bcace1","modified":1529925066133},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1529925066130},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"b8f9c95702e87fd0b170ab586c82c9718a245f8a","modified":1529925066131},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1529925066132},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1529925066134},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"4866fb9453d7d4c83a1c4e55d74e4afed336eb8b","modified":1529925066135},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1529925066136},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"ca20affaeaf33c0904cb6356864fc6b78e95f447","modified":1529925066137},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"2bc3e33fdfbcf348c96ca60598f629dcd7ba3617","modified":1529925066138},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"8355b0e9375b3245508efda0e18acd069c2aa767","modified":1529925066139},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"929fac3a505bacbce6ba63009fd15851e2a8669d","modified":1529925066138},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1529925066140},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1529925066141},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1529925066142},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"681b7c8ce4dc47130a0ca67c1ec62be7c96e4c4f","modified":1529925066142},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1529925066143},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1529925066144},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"821991c0890966a512b43e8b1cf9537e738a09a0","modified":1529925066145},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1529925066146},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1529925066146},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"06b9a99d63b4d57fdbf70b88ab7036fbc47e3f52","modified":1529925066148},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"394888efec32749b353292a59ec7f1b609d6325e","modified":1529925066147},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"702be9e57dd6ff5fa99642a1f6e3df26215b8805","modified":1529925066149},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1529925066150},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1529925066155},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"7f7e9df15148608a9c29326dd880d8e8e8efc0ec","modified":1529925066155},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1529925066156},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1529925066157},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"7bd182d918f3117335a5ee87a1b544e6d2b54d7d","modified":1529925066158},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"dcb4548d07cbb38b645b1753cf3ee7157e16921a","modified":1529925066158},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1529925066151},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"dd941824210733588841897457e0cc9697ca5608","modified":1529925066152},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"a83f493e494f5c73fab8f6f5b686ef1670490095","modified":1529925066154},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1529925066153},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1529925066205},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"cf900c5026ab36f31118317d0ae32a213e3ec2a9","modified":1529925066206},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"cf900c5026ab36f31118317d0ae32a213e3ec2a9","modified":1529925066211},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1529925066247},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1529925066248},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1529925066249},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1529925066249},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1529925066250},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1529925066251},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1529925066273},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1529925066272}],"Category":[{"name":"Windows","_id":"cjivnhtn400042guswa4m4mh6"},{"name":"blog","_id":"cjivnhtnd00092gus234jbe21"},{"name":"leetcode","_id":"cjivnhtni000e2gusz775x9pl"},{"name":"windbg","_id":"cjivnhtnw000l2gusevcup6jm"}],"Data":[],"Page":[{"title":"categories","date":"2016-06-19T15:56:53.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-06-19 23:56:53\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-06-25T11:11:05.956Z","path":"categories/index.html","layout":"page","_id":"cjivnhtlx00002guskupfntbj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2016-06-19T15:55:45.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-06-19 23:55:45\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-06-25T11:11:05.961Z","path":"tags/index.html","layout":"page","_id":"cjivnhtm000012gusetjgeg82","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"云064与你一起玩注入（一）","date":"2016-07-13T16:58:16.000Z","_content":"\n## 导言\n写这个系列文章主要是为了学习下Windows中了解但是还不是很熟悉的知识及其原理，并且因为这两年的工作大部分都体现在注入上了。说起注入，这个真的是病毒、杀软、监控等不可或缺的一门技术。知道你的Windows为什么这么慢么？你以为加内存就可以了？你以为仅仅是Windows卡死了？呵呵。。。\n\n为了能让大家能有目的地去接触注入这门技术，这个系列我准备最终做一个监控其他模块注入的小工具吧。至于技术上能不能实现出来，那就是另外一回事了。另外，我提供的代码会用`Windows Native API`先实现一版；然后再对代码进行优化，但是过程中不会用第三方库，包括`STL`；最后提供利用第三方库实现的版本。所有代码都可以在我的[github](https://github.com/cloudy064/BlogCodes.git)上找到。好了，闲话不多说，开始今天的主题吧。\n<!-- more -->\n\n## 一些废话\n本着从简单到复杂的原则，我决定这一章只说明一部分原理。（你根本只是想偷懒啊喂！\n\n注入的方式有很多种，目前我知道的有如下几种方式：\n1. Windows提供的API:`SetWindowsHookEx`\n2. 远程线程注入\n3. 消息钩子\n\n而我这一章讲的是『远程线程注入』。因为我觉得这个是最简单的，也是最好理解的，它的原理我可以简单一句话描述：『在目标进程中创建一个线程，让它只做一件事：加载我们想要注入的dll』。\n\n那么这句话描述的功能中，我们需要推敲几个点：\n1. 我在其他进程中，怎么样才能让目标进程为我创建一个线程？\n2. 目标进程怎么知道我要注入的dll在哪里？\n3. 就算它知道我的dll路径，它怎么知道`LoadLibrary`的地址？\n\n我知道大家现在肯定很多疑问，比如『为什么注入的模块一定是dll』，这些以后解答吧，因为我也还存在一些疑问。所以这里你看到的只有代码，这里你只需要跟着我的代码一直敲下去看效果就行了。\n\n在做注入之前，我们首先需要一个被注入的进程，我们的老朋友`Hello World`登场，源码如下：\n```cpp\nint main()\n{\n    system(\"pause\"); //只是为了让进程不退出，能够让我们注入\n}\n```\n\n接着我们需要准备一个想要注入进去的dll（怎么创建工程自己百度去），代码也很简单：\n```cpp\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        printf(\"i am injected\");\n        break;\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n```\n\n它在注入到目标进程之后，会在控制台输出一句话。但是现在它和目标进程没有任何关系。\n\n## 基础准备\n所以，接下来就是今天需要重点说明的远程注入所需要用到的`API`:\n\n### 创建线程\n远程注入的基础是要能够在目标进程中运行代码，那么首当其中的就是创建注入线程的`API`:\n```cpp\nHANDLE\nWINAPI\nCreateRemoteThread(\n    _In_ HANDLE hProcess,\n    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,\n    _In_ SIZE_T dwStackSize,\n    _In_ LPTHREAD_START_ROUTINE lpStartAddress,\n    _In_opt_ LPVOID lpParameter,\n    _In_ DWORD dwCreationFlags,\n    _Out_opt_ LPDWORD lpThreadId\n    );\n```\n\n这个函数的具体描述可以参考`MSDN`，这里我只挑选重点关注的进行讲解：\n1. hProcess: 这个是你需要注入的进程的句柄，你可以通过`OpenProcess`来获得这个句柄。然后你在`MSDN`会看到这样一句话：\n> The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without these rights on certain platforms.\n   你需要在`OpenProcess`时指定上面提到的这些权限，否则`CreateRemoteThread`会失败\n2. lpStartAddress: 这个是你线程开始运行的地址。这里你需要注意，你并不能传当前进程的函数地址过去，因为每个进程都有自己的虚拟内存，且互相看不见对方有啥（就目前来说），就32位系统来说，虚拟内存的地址范围都是0~4G。也就是说你这边的`0x23333333`是函数`A`，而到了目标进程中`0x23333333`地址就可能是函数`B`了。所以你这里需要在目标进程中申请一块内存，并且向这块内存中写入线程的起始地址才行，而这就需要用到另外一个知名`API`了:`VirtualAllocEx`。\n3. lpParameter: 这个是线程运行时传递给`lpStartAddress`的一个参数，额，用过`CreateThread`的肯定还是知道的，就和那个一模一样。\n\n所以现在我们可以先写出一部分代码，如下：\n```cpp\nint main()\n{\n    HANDLE hProcess = ::OpenProcess(\n        PROCESS_CREATE_THREAD | PROCESS_OPERATION | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE,\n        FALSE,\n        6916/*进程ID，这里因人而异，可以打开任务管理器看*/\n    );\n\n    if (hProcess == NULL)\n    {\n        return -1;\n    }\n\n    HANDLE hThread = ::CreateRemoteThread(\n        hProcess,\n        NULL,\n        0,\n        /*这里是要执行的函数的起始地址*/,\n        /*传给执行函数的参数地址*/,\n        0,\n        NULL\n    );\n\n    if (hThread == NULL)\n    {\n        ::CloseHandle(hProcess);\n        return -1;\n    }\n\n    ::WaitForSingleObject(hThread, INFINITE); //这里是为了确保注入线程正常退出，然后做资源回收\n\n    ::CloseHandle(hThread);\n    ::CloseHandle(hProcess);\n\n    return 0;\n}\n```\n\n那所以说现在还差两个东西，就是函数的起始地址和传递给函数的参数。继续往下看，你会找到答案。\n\n### LoadLibrary\n我们先用[ProcExp](https://technet.microsoft.com/en-us/sysinternals/bb896653/)来看下各个进程中`kernel32.dll`的地址分布吧：\n{% asset_img explorer_kernel32_address.jpg Explorer.exe中kernel32的地址 %}\n{% asset_img devenv_kernel32_address.jpg VS中kernel32的地址 %}\n\n可以看出来，`kernel32.dll`在进程中的起始地址都是固定的，大家也可以自己验证下其他进程。而`LoadLibraryW`在`kernel32.dll`中的偏移地址也是一定的，所以如果我们想要知道目标进程中`LoadLibraryW`的地址，其实就可以获取当前进程中`LoadLibraryW`的地址。\n\n所以获取`LoadLibraryW`的地址的代码如下：\n```cpp\nHMODULE hKnl = ::LoadLibraryW(L\"kernel32.dll\");\nif (hKnl == NULL)\n{\n    return -1;\n}\n\nLPTHREAD_START_ROUTINE pLoadLibrary = (LPTHREAD_START_ROUTINE)::GetProcAddress(hKnl, \"LoadLibraryW\");\nif (pLoadLibrary == NULL)\n{\n    return -1;\n}\n```\n\n### 申请内存\n现在我们还缺一个传递给`LoadLibraryW`的参数，也就是我们需要注入的dll的地址。但是由于我们创建的线程是在目标进程中跑的，而目标进程无法读取到我们当前进程中的内存，我们需要创建一块目标进程中的内存才行。所以自然地就引出了下面这个`API`:\n```cpp\nLPVOID\nWINAPI\nVirtualAllocEx(\n    _In_ HANDLE hProcess,\n    _In_opt_ LPVOID lpAddress,\n    _In_ SIZE_T dwSize,\n    _In_ DWORD flAllocationType,\n    _In_ DWORD flProtect\n    );\n```\n\n这个函数可以向目标进程申请一块内存，并且这块内存会被初始化为0。函数的具体参数解释如下：\n1. hProcess: 目标进程的句柄，不做解释\n2. lpAddress: 内存的起始地址，这里传NULL就行了\n3. dwSize: 申请的内存的大熊啊\n4. flAllocationType: 这个是申请内存的类型，以后会细讲，这里传`MEM_COMMIT`就行了\n5. flProtect: 这个是你对这块内存索取的权限，以后细讲，这里传`PAGE_READWRITE`即可\n\n我们现在有了目标进程中的一块内存，但是我们还要借助另外一个`API`来实现向这块内存中写入数据:\n```cpp\nBOOL\nWINAPI\nWriteProcessMemory(\n    _In_ HANDLE hProcess,\n    _In_ LPVOID lpBaseAddress,\n    _In_reads_bytes_(nSize) LPCVOID lpBuffer,\n    _In_ SIZE_T nSize,\n    _Out_opt_ SIZE_T * lpNumberOfBytesWritten\n    );\n```\n\n比如我们需要注入的`dll`的路径是`D:\\RemoteInjectDll.dll`，那么代码如下:\n```cpp\nLPCWSTR lpszDllPath = LR\"(D:\\RemoteInjectDll.dll)\";\nSIZE_T dwMemSize = static_cast<SIZE_T>((wcslen(lpszDllPath) + 1) * sizeof(WCHAR));\nLPVOID lpRemoteMemory = ::VirtualAllocEx(hProcess, NULL, dwMemSize, MEM_COMMIT, PAGE_READWRITE);\nif (lpRemoteMemory == NULL)\n{\n    return -1;\n}\n\nSIZE_T sizeWritten = 0;\nif (!::WriteProcessMemory(hProcess, lpRemoteMemory, (LPCVOID)lpszDllPath, dwMemSize, &sizeWritten))\n{\n    ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n    return -1;\n}\n\n//...\n\n::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n```\n\n## 最后组装\n现在所有的条件都具备了，需要把这几块都组装一下，形成的最终代码如下：\n```cpp\n// RemoteInjectExe.cpp : Defines the entry point for the console application.\n//\n\nint main()\n{\n    HANDLE hProcess = ::OpenProcess(\n        PROCESS_CREATE_THREAD | PROCESS_OPERATION | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE,\n        FALSE,\n        6916\n    );\n\n    if (hProcess == NULL)\n    {\n        return -1;\n    }\n\n    LPCWSTR lpszDllPath = LR\"(D:\\workspaces\\c++\\RemoteInjectExe\\Debug\\RemoteInjectDll.dll)\"; //我改了下地址\n    SIZE_T dwMemSize = static_cast<SIZE_T>((wcslen(lpszDllPath) + 1) * sizeof(WCHAR));\n    LPVOID lpRemoteMemory = ::VirtualAllocEx(hProcess, NULL, dwMemSize, MEM_COMMIT, PAGE_READWRITE);\n\n    if (lpRemoteMemory == NULL)\n    {\n        return -1;\n    }\n\n    SIZE_T sizeWritten = 0;\n    if (!::WriteProcessMemory(hProcess, lpRemoteMemory, (LPCVOID)lpszDllPath, dwMemSize, &sizeWritten))\n    {\n        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n        ::CloseHandle(hProcess);\n        return -1;\n    }\n\n    HMODULE hKnl = ::LoadLibraryW(L\"kernel32.dll\");\n    if (hKnl == NULL)\n    {\n        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n        ::CloseHandle(hProcess);\n        return -1;\n    }\n\n    LPTHREAD_START_ROUTINE pLoadLibrary = (LPTHREAD_START_ROUTINE)::GetProcAddress(hKnl, \"LoadLibraryW\");\n    if (pLoadLibrary == NULL)\n    {\n        ::FreeLibrary(hKnl);\n        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n        ::CloseHandle(hProcess);\n        return -1;\n    }\n\n    DWORD dwThreadId;\n    HANDLE hThread = ::CreateRemoteThread(\n        hProcess,\n        NULL,\n        0,\n        pLoadLibrary,\n        lpRemoteMemory,\n        0,\n        &dwThreadId);\n\n    if (hThread == NULL)\n    {\n        ::FreeLibrary(hKnl);\n        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n        ::CloseHandle(hProcess);\n        return -1;\n    }\n\n    ::WaitForSingleObject(hThread, INFINITE);\n\n    ::FreeLibrary(hKnl);\n    ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n    ::CloseHandle(hProcess);\n    return 0;\n}\n```\n\n## 测试\n我们现在把`HelloWorld.exe`运行起来，然后把`OpenProcess`函数中的最后一个参数改为`HelloWorld.exe`的进程ID，编译运行即可。可以看到最终运行结果如下：\n{% asset_img inject_result.png 运行结果 %}\n\n到这里就完全讲完了，所以注入也不是一个神奇的事情，完全就是`API`的事情，知道了就行了。至于原理，做完了之后可以慢慢研究。\n\n## 代码优化\n1. 你看代码里面很多那种资源回收的代码，而且是完全相同的，是不是可以有一个统一回收的机制呢？比如说我们利用`C++`中析构函数会在对象生命周期结束时被调用，因为这里我们仅仅是需要在main函数结束的时候能够把句柄和内存释放掉。所以就有了下面两个类：\n```cpp\nclass ScopeHandle\n{\npublic:\n    ScopeHandle(HANDLE h)\n        : m_h(h)\n    {\n\n    }\n\n    ScopeHandle(const ScopeHandle&) = delete;\n    \n    ~ScopeHandle()\n    {\n        Close();\n    }\n\npublic:\n    void Attach(HANDLE h)\n    {\n        Close();\n        m_h = h;\n    }\n\n    HANDLE Detach()\n    {\n        HANDLE h = m_h;\n        m_h = NULL;\n        return h;\n    }\n\npublic:\n    operator HANDLE()\n    {\n        return m_h;\n    }\n\n    ScopeHandle& operator=(HANDLE h)\n    {\n        Close();\n        m_h = h;\n        return (*this);\n    }\n\n    ScopeHandle& operator=(const ScopeHandle&) = delete;\n\nprivate:\n    void Close()\n    {\n        if (m_h != NULL || m_h != INVALID_HANDLE_VALUE)\n        {\n            ::CloseHandle(m_h);\n            m_h = NULL;\n        }\n    }\n\nprivate:\n    HANDLE m_h;\n};\n\nclass ScopeVirtualMemoryEx\n{\npublic:\n    ScopeVirtualMemoryEx(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)\n        : m_lpMemory(lpMemory)\n        , m_hProcess(hProcess)\n        , m_memSize(memSize)\n    {\n\n    }\n\n    ScopeVirtualMemoryEx(const ScopeVirtualMemoryEx&) = delete;\n\n    ~ScopeVirtualMemoryEx()\n    {\n        Close();\n    }\n\npublic:\n    void Attach(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)\n    {\n        Close();\n        m_lpMemory = lpMemory;\n        m_hProcess = hProcess;\n        m_memSize = memSize;\n    }\n\n    LPVOID Detach()\n    {\n        LPVOID lpMemory = m_lpMemory;\n        Close();\n\n        return lpMemory;\n    }\n\npublic:\n    operator LPVOID()\n    {\n        return m_lpMemory;\n    }\n\n    ScopeVirtualMemoryEx& operator=(const ScopeVirtualMemoryEx&) = delete;\n\nprivate:\n    void Close()\n    {\n        if (m_lpMemory == NULL)\n        {\n            return;\n        }\n\n        if (m_hProcess == NULL)\n        {\n            return;\n        }\n\n        ::VirtualFreeEx(m_hProcess, m_lpMemory, m_memSize, MEM_RELEASE);\n\n        m_hProcess = NULL;\n        m_lpMemory = NULL;\n        m_memSize = 0;\n    }\n\nprivate:\n    LPVOID m_lpMemory;\n    HANDLE m_hProcess;\n    SIZE_T m_memSize;\n};\n```\n\n有的人是不是会觉得得不偿失啊？我为了优化不到20行代码，平白无故多出来100多行代码。这个的话，看个人喜好吧。\n\n那上面的是不是优化结束了呢？那万一我还有10个其他自定义的对象也需要这种自动释放的机制，那是不是还要在写100个类了？\n\n所以，我们继续观察，可以发现其实上面两个类有非常多的相似之处，如果排除掉成员变量的因素，那就一模一样了！那么还能怎么抽取呢？我们观察下上面两个类，可以发现无非就是需要做两件事情：\n1. 判断代理的目标对象是否有效\n2. 释放代理的目标对象\n\n也就是说我们其实可以再在这两个类上抽象一层，比如就叫`AutoReleaseObject`吧，然后传递一个判断是否有效以及释放的方法。恩，想法是很美好的，那么问题又来了，如果只有一个参数我们还能用一个模板来消除差异性，现在它们释放的函数签名完全不同，这你让我怎么玩？别急啊，办法总是有的。其中心思想就是把数据处理与流程分离（也可以理解为机制与策略分离，详见《unix编程思想》），那么我后来就写出了下面的代码（妈蛋，怎么越来越麻烦了！:\n```cpp\ntemplate <typename T>\nclass AutoReleaseDelegate\n{\npublic:\n    AutoReleaseDelegate(T obj)\n        : m_obj(obj)\n    {\n\n    }\n\n    virtual ~AutoReleaseDelegate()\n    {\n\n    }\n\npublic:\n    virtual bool Validate() const = 0;\n    virtual void Release() = 0;\n\npublic:\n    operator T()\n    {\n        return m_obj;\n    }\n\nprotected:\n    T m_obj;\n};\n\nclass HandleDelegate\n    : public AutoReleaseDelegate<HANDLE>\n{\n    using super = AutoReleaseDelegate<HANDLE>;\n\npublic:\n    HandleDelegate(HANDLE h)\n        : AutoReleaseDelegate(h)\n    {\n\n    }\n\n    ~HandleDelegate()\n    {\n\n    }\n\npublic:\n    virtual bool Validate() const override\n    {\n        return (super::m_obj != NULL);\n    }\n\n    virtual void Release() override\n    {\n        ::CloseHandle(super::m_obj);\n        super::m_obj = NULL;\n    }\n};\n\nclass VirtualMemoryExDelegate\n    : public AutoReleaseDelegate<LPVOID>\n{\n    using super = AutoReleaseDelegate<LPVOID>;\n\npublic:\n    VirtualMemoryExDelegate(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)\n        : AutoReleaseDelegate(lpMemory)\n        , m_hProcess(hProcess)\n        , m_memSize(memSize)\n    {\n\n    }\n\n    ~VirtualMemoryExDelegate()\n    {\n\n    }\n\npublic:\n    virtual bool Validate() const override\n    {\n        if (super::m_obj == NULL)\n            return false;\n\n        if (m_hProcess == NULL)\n            return false;\n\n        return true;\n    }\n\n    virtual void Release() override\n    {\n        ::VirtualFreeEx(m_hProcess, super::m_obj, m_memSize, MEM_RELEASE);\n        m_hProcess = NULL;\n        super::m_obj = NULL;\n        m_memSize = 0;\n    }\n\nprivate:\n    HANDLE m_hProcess;\n    SIZE_T m_memSize;\n};\n\ntemplate <typename T>\nclass AutoReleaseObj\n{\n    using DelegateType = AutoReleaseDelegate<T>;\n\npublic:\n    AutoReleaseObj(DelegateType* pDelegate)\n        : m_pDelegate(pDelegate)\n    {\n\n    }\n    \n    AutoReleaseObj(const AutoReleaseObj&) = delete;\n\n    ~AutoReleaseObj()\n    {\n        assert(m_pDelegate != nullptr);\n        if (m_pDelegate->Validate())\n        {\n            m_pDelegate->Release();\n        }\n    }\n\npublic:\n    operator T()\n    {\n        assert(m_pDelegate != nullptr);\n        return T(*m_pDelegate);\n    }\n\n    AutoReleaseObj<T>& operator=(AutoReleaseObj<T>& rhs) = delete;\n\nprivate:\n    DelegateType* m_pDelegate;\n};\n```\n\n这样一来我们要接入新的需要`AutoRelease`特性的对象时，只需要继承`AutoReleaseDelegate`即可，而整个流程不在需要你去关系，交给`AutoReleaseObj`就行了。当然上面的代码这样写不免有些过度设计之嫌，还是那句话，用你你喜欢或者你习惯的方式就好，不必追求什么设计。\n\n我自己的优化已经结束了，如果大家觉得还有哪里可以进行优化的话，欢迎提出来，我努力实现。还有这里肯定会有人问为什么指针不判空，我想说，请分清楚库代码和工作代码之间的区别。\n\n这次没有`ATL`优化版本，`ATL`中只提供了`CHandle`对`HANDLE`进行封装，其他并没有做任何封装（或者我没有找到），所以注入的第一篇就到这里结束啦，大家好好消化下吧。\n","source":"_posts/inject/2016-07-14-remote-inject.md","raw":"---\ntitle: 云064与你一起玩注入（一）\ndate: 2016-07-14 00:58:16\ncategories: Windows\ntags: [windows,c++,inject]\n---\n\n## 导言\n写这个系列文章主要是为了学习下Windows中了解但是还不是很熟悉的知识及其原理，并且因为这两年的工作大部分都体现在注入上了。说起注入，这个真的是病毒、杀软、监控等不可或缺的一门技术。知道你的Windows为什么这么慢么？你以为加内存就可以了？你以为仅仅是Windows卡死了？呵呵。。。\n\n为了能让大家能有目的地去接触注入这门技术，这个系列我准备最终做一个监控其他模块注入的小工具吧。至于技术上能不能实现出来，那就是另外一回事了。另外，我提供的代码会用`Windows Native API`先实现一版；然后再对代码进行优化，但是过程中不会用第三方库，包括`STL`；最后提供利用第三方库实现的版本。所有代码都可以在我的[github](https://github.com/cloudy064/BlogCodes.git)上找到。好了，闲话不多说，开始今天的主题吧。\n<!-- more -->\n\n## 一些废话\n本着从简单到复杂的原则，我决定这一章只说明一部分原理。（你根本只是想偷懒啊喂！\n\n注入的方式有很多种，目前我知道的有如下几种方式：\n1. Windows提供的API:`SetWindowsHookEx`\n2. 远程线程注入\n3. 消息钩子\n\n而我这一章讲的是『远程线程注入』。因为我觉得这个是最简单的，也是最好理解的，它的原理我可以简单一句话描述：『在目标进程中创建一个线程，让它只做一件事：加载我们想要注入的dll』。\n\n那么这句话描述的功能中，我们需要推敲几个点：\n1. 我在其他进程中，怎么样才能让目标进程为我创建一个线程？\n2. 目标进程怎么知道我要注入的dll在哪里？\n3. 就算它知道我的dll路径，它怎么知道`LoadLibrary`的地址？\n\n我知道大家现在肯定很多疑问，比如『为什么注入的模块一定是dll』，这些以后解答吧，因为我也还存在一些疑问。所以这里你看到的只有代码，这里你只需要跟着我的代码一直敲下去看效果就行了。\n\n在做注入之前，我们首先需要一个被注入的进程，我们的老朋友`Hello World`登场，源码如下：\n```cpp\nint main()\n{\n    system(\"pause\"); //只是为了让进程不退出，能够让我们注入\n}\n```\n\n接着我们需要准备一个想要注入进去的dll（怎么创建工程自己百度去），代码也很简单：\n```cpp\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        printf(\"i am injected\");\n        break;\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n```\n\n它在注入到目标进程之后，会在控制台输出一句话。但是现在它和目标进程没有任何关系。\n\n## 基础准备\n所以，接下来就是今天需要重点说明的远程注入所需要用到的`API`:\n\n### 创建线程\n远程注入的基础是要能够在目标进程中运行代码，那么首当其中的就是创建注入线程的`API`:\n```cpp\nHANDLE\nWINAPI\nCreateRemoteThread(\n    _In_ HANDLE hProcess,\n    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,\n    _In_ SIZE_T dwStackSize,\n    _In_ LPTHREAD_START_ROUTINE lpStartAddress,\n    _In_opt_ LPVOID lpParameter,\n    _In_ DWORD dwCreationFlags,\n    _Out_opt_ LPDWORD lpThreadId\n    );\n```\n\n这个函数的具体描述可以参考`MSDN`，这里我只挑选重点关注的进行讲解：\n1. hProcess: 这个是你需要注入的进程的句柄，你可以通过`OpenProcess`来获得这个句柄。然后你在`MSDN`会看到这样一句话：\n> The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without these rights on certain platforms.\n   你需要在`OpenProcess`时指定上面提到的这些权限，否则`CreateRemoteThread`会失败\n2. lpStartAddress: 这个是你线程开始运行的地址。这里你需要注意，你并不能传当前进程的函数地址过去，因为每个进程都有自己的虚拟内存，且互相看不见对方有啥（就目前来说），就32位系统来说，虚拟内存的地址范围都是0~4G。也就是说你这边的`0x23333333`是函数`A`，而到了目标进程中`0x23333333`地址就可能是函数`B`了。所以你这里需要在目标进程中申请一块内存，并且向这块内存中写入线程的起始地址才行，而这就需要用到另外一个知名`API`了:`VirtualAllocEx`。\n3. lpParameter: 这个是线程运行时传递给`lpStartAddress`的一个参数，额，用过`CreateThread`的肯定还是知道的，就和那个一模一样。\n\n所以现在我们可以先写出一部分代码，如下：\n```cpp\nint main()\n{\n    HANDLE hProcess = ::OpenProcess(\n        PROCESS_CREATE_THREAD | PROCESS_OPERATION | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE,\n        FALSE,\n        6916/*进程ID，这里因人而异，可以打开任务管理器看*/\n    );\n\n    if (hProcess == NULL)\n    {\n        return -1;\n    }\n\n    HANDLE hThread = ::CreateRemoteThread(\n        hProcess,\n        NULL,\n        0,\n        /*这里是要执行的函数的起始地址*/,\n        /*传给执行函数的参数地址*/,\n        0,\n        NULL\n    );\n\n    if (hThread == NULL)\n    {\n        ::CloseHandle(hProcess);\n        return -1;\n    }\n\n    ::WaitForSingleObject(hThread, INFINITE); //这里是为了确保注入线程正常退出，然后做资源回收\n\n    ::CloseHandle(hThread);\n    ::CloseHandle(hProcess);\n\n    return 0;\n}\n```\n\n那所以说现在还差两个东西，就是函数的起始地址和传递给函数的参数。继续往下看，你会找到答案。\n\n### LoadLibrary\n我们先用[ProcExp](https://technet.microsoft.com/en-us/sysinternals/bb896653/)来看下各个进程中`kernel32.dll`的地址分布吧：\n{% asset_img explorer_kernel32_address.jpg Explorer.exe中kernel32的地址 %}\n{% asset_img devenv_kernel32_address.jpg VS中kernel32的地址 %}\n\n可以看出来，`kernel32.dll`在进程中的起始地址都是固定的，大家也可以自己验证下其他进程。而`LoadLibraryW`在`kernel32.dll`中的偏移地址也是一定的，所以如果我们想要知道目标进程中`LoadLibraryW`的地址，其实就可以获取当前进程中`LoadLibraryW`的地址。\n\n所以获取`LoadLibraryW`的地址的代码如下：\n```cpp\nHMODULE hKnl = ::LoadLibraryW(L\"kernel32.dll\");\nif (hKnl == NULL)\n{\n    return -1;\n}\n\nLPTHREAD_START_ROUTINE pLoadLibrary = (LPTHREAD_START_ROUTINE)::GetProcAddress(hKnl, \"LoadLibraryW\");\nif (pLoadLibrary == NULL)\n{\n    return -1;\n}\n```\n\n### 申请内存\n现在我们还缺一个传递给`LoadLibraryW`的参数，也就是我们需要注入的dll的地址。但是由于我们创建的线程是在目标进程中跑的，而目标进程无法读取到我们当前进程中的内存，我们需要创建一块目标进程中的内存才行。所以自然地就引出了下面这个`API`:\n```cpp\nLPVOID\nWINAPI\nVirtualAllocEx(\n    _In_ HANDLE hProcess,\n    _In_opt_ LPVOID lpAddress,\n    _In_ SIZE_T dwSize,\n    _In_ DWORD flAllocationType,\n    _In_ DWORD flProtect\n    );\n```\n\n这个函数可以向目标进程申请一块内存，并且这块内存会被初始化为0。函数的具体参数解释如下：\n1. hProcess: 目标进程的句柄，不做解释\n2. lpAddress: 内存的起始地址，这里传NULL就行了\n3. dwSize: 申请的内存的大熊啊\n4. flAllocationType: 这个是申请内存的类型，以后会细讲，这里传`MEM_COMMIT`就行了\n5. flProtect: 这个是你对这块内存索取的权限，以后细讲，这里传`PAGE_READWRITE`即可\n\n我们现在有了目标进程中的一块内存，但是我们还要借助另外一个`API`来实现向这块内存中写入数据:\n```cpp\nBOOL\nWINAPI\nWriteProcessMemory(\n    _In_ HANDLE hProcess,\n    _In_ LPVOID lpBaseAddress,\n    _In_reads_bytes_(nSize) LPCVOID lpBuffer,\n    _In_ SIZE_T nSize,\n    _Out_opt_ SIZE_T * lpNumberOfBytesWritten\n    );\n```\n\n比如我们需要注入的`dll`的路径是`D:\\RemoteInjectDll.dll`，那么代码如下:\n```cpp\nLPCWSTR lpszDllPath = LR\"(D:\\RemoteInjectDll.dll)\";\nSIZE_T dwMemSize = static_cast<SIZE_T>((wcslen(lpszDllPath) + 1) * sizeof(WCHAR));\nLPVOID lpRemoteMemory = ::VirtualAllocEx(hProcess, NULL, dwMemSize, MEM_COMMIT, PAGE_READWRITE);\nif (lpRemoteMemory == NULL)\n{\n    return -1;\n}\n\nSIZE_T sizeWritten = 0;\nif (!::WriteProcessMemory(hProcess, lpRemoteMemory, (LPCVOID)lpszDllPath, dwMemSize, &sizeWritten))\n{\n    ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n    return -1;\n}\n\n//...\n\n::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n```\n\n## 最后组装\n现在所有的条件都具备了，需要把这几块都组装一下，形成的最终代码如下：\n```cpp\n// RemoteInjectExe.cpp : Defines the entry point for the console application.\n//\n\nint main()\n{\n    HANDLE hProcess = ::OpenProcess(\n        PROCESS_CREATE_THREAD | PROCESS_OPERATION | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE,\n        FALSE,\n        6916\n    );\n\n    if (hProcess == NULL)\n    {\n        return -1;\n    }\n\n    LPCWSTR lpszDllPath = LR\"(D:\\workspaces\\c++\\RemoteInjectExe\\Debug\\RemoteInjectDll.dll)\"; //我改了下地址\n    SIZE_T dwMemSize = static_cast<SIZE_T>((wcslen(lpszDllPath) + 1) * sizeof(WCHAR));\n    LPVOID lpRemoteMemory = ::VirtualAllocEx(hProcess, NULL, dwMemSize, MEM_COMMIT, PAGE_READWRITE);\n\n    if (lpRemoteMemory == NULL)\n    {\n        return -1;\n    }\n\n    SIZE_T sizeWritten = 0;\n    if (!::WriteProcessMemory(hProcess, lpRemoteMemory, (LPCVOID)lpszDllPath, dwMemSize, &sizeWritten))\n    {\n        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n        ::CloseHandle(hProcess);\n        return -1;\n    }\n\n    HMODULE hKnl = ::LoadLibraryW(L\"kernel32.dll\");\n    if (hKnl == NULL)\n    {\n        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n        ::CloseHandle(hProcess);\n        return -1;\n    }\n\n    LPTHREAD_START_ROUTINE pLoadLibrary = (LPTHREAD_START_ROUTINE)::GetProcAddress(hKnl, \"LoadLibraryW\");\n    if (pLoadLibrary == NULL)\n    {\n        ::FreeLibrary(hKnl);\n        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n        ::CloseHandle(hProcess);\n        return -1;\n    }\n\n    DWORD dwThreadId;\n    HANDLE hThread = ::CreateRemoteThread(\n        hProcess,\n        NULL,\n        0,\n        pLoadLibrary,\n        lpRemoteMemory,\n        0,\n        &dwThreadId);\n\n    if (hThread == NULL)\n    {\n        ::FreeLibrary(hKnl);\n        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n        ::CloseHandle(hProcess);\n        return -1;\n    }\n\n    ::WaitForSingleObject(hThread, INFINITE);\n\n    ::FreeLibrary(hKnl);\n    ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);\n    ::CloseHandle(hProcess);\n    return 0;\n}\n```\n\n## 测试\n我们现在把`HelloWorld.exe`运行起来，然后把`OpenProcess`函数中的最后一个参数改为`HelloWorld.exe`的进程ID，编译运行即可。可以看到最终运行结果如下：\n{% asset_img inject_result.png 运行结果 %}\n\n到这里就完全讲完了，所以注入也不是一个神奇的事情，完全就是`API`的事情，知道了就行了。至于原理，做完了之后可以慢慢研究。\n\n## 代码优化\n1. 你看代码里面很多那种资源回收的代码，而且是完全相同的，是不是可以有一个统一回收的机制呢？比如说我们利用`C++`中析构函数会在对象生命周期结束时被调用，因为这里我们仅仅是需要在main函数结束的时候能够把句柄和内存释放掉。所以就有了下面两个类：\n```cpp\nclass ScopeHandle\n{\npublic:\n    ScopeHandle(HANDLE h)\n        : m_h(h)\n    {\n\n    }\n\n    ScopeHandle(const ScopeHandle&) = delete;\n    \n    ~ScopeHandle()\n    {\n        Close();\n    }\n\npublic:\n    void Attach(HANDLE h)\n    {\n        Close();\n        m_h = h;\n    }\n\n    HANDLE Detach()\n    {\n        HANDLE h = m_h;\n        m_h = NULL;\n        return h;\n    }\n\npublic:\n    operator HANDLE()\n    {\n        return m_h;\n    }\n\n    ScopeHandle& operator=(HANDLE h)\n    {\n        Close();\n        m_h = h;\n        return (*this);\n    }\n\n    ScopeHandle& operator=(const ScopeHandle&) = delete;\n\nprivate:\n    void Close()\n    {\n        if (m_h != NULL || m_h != INVALID_HANDLE_VALUE)\n        {\n            ::CloseHandle(m_h);\n            m_h = NULL;\n        }\n    }\n\nprivate:\n    HANDLE m_h;\n};\n\nclass ScopeVirtualMemoryEx\n{\npublic:\n    ScopeVirtualMemoryEx(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)\n        : m_lpMemory(lpMemory)\n        , m_hProcess(hProcess)\n        , m_memSize(memSize)\n    {\n\n    }\n\n    ScopeVirtualMemoryEx(const ScopeVirtualMemoryEx&) = delete;\n\n    ~ScopeVirtualMemoryEx()\n    {\n        Close();\n    }\n\npublic:\n    void Attach(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)\n    {\n        Close();\n        m_lpMemory = lpMemory;\n        m_hProcess = hProcess;\n        m_memSize = memSize;\n    }\n\n    LPVOID Detach()\n    {\n        LPVOID lpMemory = m_lpMemory;\n        Close();\n\n        return lpMemory;\n    }\n\npublic:\n    operator LPVOID()\n    {\n        return m_lpMemory;\n    }\n\n    ScopeVirtualMemoryEx& operator=(const ScopeVirtualMemoryEx&) = delete;\n\nprivate:\n    void Close()\n    {\n        if (m_lpMemory == NULL)\n        {\n            return;\n        }\n\n        if (m_hProcess == NULL)\n        {\n            return;\n        }\n\n        ::VirtualFreeEx(m_hProcess, m_lpMemory, m_memSize, MEM_RELEASE);\n\n        m_hProcess = NULL;\n        m_lpMemory = NULL;\n        m_memSize = 0;\n    }\n\nprivate:\n    LPVOID m_lpMemory;\n    HANDLE m_hProcess;\n    SIZE_T m_memSize;\n};\n```\n\n有的人是不是会觉得得不偿失啊？我为了优化不到20行代码，平白无故多出来100多行代码。这个的话，看个人喜好吧。\n\n那上面的是不是优化结束了呢？那万一我还有10个其他自定义的对象也需要这种自动释放的机制，那是不是还要在写100个类了？\n\n所以，我们继续观察，可以发现其实上面两个类有非常多的相似之处，如果排除掉成员变量的因素，那就一模一样了！那么还能怎么抽取呢？我们观察下上面两个类，可以发现无非就是需要做两件事情：\n1. 判断代理的目标对象是否有效\n2. 释放代理的目标对象\n\n也就是说我们其实可以再在这两个类上抽象一层，比如就叫`AutoReleaseObject`吧，然后传递一个判断是否有效以及释放的方法。恩，想法是很美好的，那么问题又来了，如果只有一个参数我们还能用一个模板来消除差异性，现在它们释放的函数签名完全不同，这你让我怎么玩？别急啊，办法总是有的。其中心思想就是把数据处理与流程分离（也可以理解为机制与策略分离，详见《unix编程思想》），那么我后来就写出了下面的代码（妈蛋，怎么越来越麻烦了！:\n```cpp\ntemplate <typename T>\nclass AutoReleaseDelegate\n{\npublic:\n    AutoReleaseDelegate(T obj)\n        : m_obj(obj)\n    {\n\n    }\n\n    virtual ~AutoReleaseDelegate()\n    {\n\n    }\n\npublic:\n    virtual bool Validate() const = 0;\n    virtual void Release() = 0;\n\npublic:\n    operator T()\n    {\n        return m_obj;\n    }\n\nprotected:\n    T m_obj;\n};\n\nclass HandleDelegate\n    : public AutoReleaseDelegate<HANDLE>\n{\n    using super = AutoReleaseDelegate<HANDLE>;\n\npublic:\n    HandleDelegate(HANDLE h)\n        : AutoReleaseDelegate(h)\n    {\n\n    }\n\n    ~HandleDelegate()\n    {\n\n    }\n\npublic:\n    virtual bool Validate() const override\n    {\n        return (super::m_obj != NULL);\n    }\n\n    virtual void Release() override\n    {\n        ::CloseHandle(super::m_obj);\n        super::m_obj = NULL;\n    }\n};\n\nclass VirtualMemoryExDelegate\n    : public AutoReleaseDelegate<LPVOID>\n{\n    using super = AutoReleaseDelegate<LPVOID>;\n\npublic:\n    VirtualMemoryExDelegate(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)\n        : AutoReleaseDelegate(lpMemory)\n        , m_hProcess(hProcess)\n        , m_memSize(memSize)\n    {\n\n    }\n\n    ~VirtualMemoryExDelegate()\n    {\n\n    }\n\npublic:\n    virtual bool Validate() const override\n    {\n        if (super::m_obj == NULL)\n            return false;\n\n        if (m_hProcess == NULL)\n            return false;\n\n        return true;\n    }\n\n    virtual void Release() override\n    {\n        ::VirtualFreeEx(m_hProcess, super::m_obj, m_memSize, MEM_RELEASE);\n        m_hProcess = NULL;\n        super::m_obj = NULL;\n        m_memSize = 0;\n    }\n\nprivate:\n    HANDLE m_hProcess;\n    SIZE_T m_memSize;\n};\n\ntemplate <typename T>\nclass AutoReleaseObj\n{\n    using DelegateType = AutoReleaseDelegate<T>;\n\npublic:\n    AutoReleaseObj(DelegateType* pDelegate)\n        : m_pDelegate(pDelegate)\n    {\n\n    }\n    \n    AutoReleaseObj(const AutoReleaseObj&) = delete;\n\n    ~AutoReleaseObj()\n    {\n        assert(m_pDelegate != nullptr);\n        if (m_pDelegate->Validate())\n        {\n            m_pDelegate->Release();\n        }\n    }\n\npublic:\n    operator T()\n    {\n        assert(m_pDelegate != nullptr);\n        return T(*m_pDelegate);\n    }\n\n    AutoReleaseObj<T>& operator=(AutoReleaseObj<T>& rhs) = delete;\n\nprivate:\n    DelegateType* m_pDelegate;\n};\n```\n\n这样一来我们要接入新的需要`AutoRelease`特性的对象时，只需要继承`AutoReleaseDelegate`即可，而整个流程不在需要你去关系，交给`AutoReleaseObj`就行了。当然上面的代码这样写不免有些过度设计之嫌，还是那句话，用你你喜欢或者你习惯的方式就好，不必追求什么设计。\n\n我自己的优化已经结束了，如果大家觉得还有哪里可以进行优化的话，欢迎提出来，我努力实现。还有这里肯定会有人问为什么指针不判空，我想说，请分清楚库代码和工作代码之间的区别。\n\n这次没有`ATL`优化版本，`ATL`中只提供了`CHandle`对`HANDLE`进行封装，其他并没有做任何封装（或者我没有找到），所以注入的第一篇就到这里结束啦，大家好好消化下吧。\n","slug":"inject-2016-07-14-remote-inject","published":1,"updated":"2018-06-25T11:15:53.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjivnhtmy00022gus2eqqovmz","content":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>写这个系列文章主要是为了学习下Windows中了解但是还不是很熟悉的知识及其原理，并且因为这两年的工作大部分都体现在注入上了。说起注入，这个真的是病毒、杀软、监控等不可或缺的一门技术。知道你的Windows为什么这么慢么？你以为加内存就可以了？你以为仅仅是Windows卡死了？呵呵。。。</p>\n<p>为了能让大家能有目的地去接触注入这门技术，这个系列我准备最终做一个监控其他模块注入的小工具吧。至于技术上能不能实现出来，那就是另外一回事了。另外，我提供的代码会用<code>Windows Native API</code>先实现一版；然后再对代码进行优化，但是过程中不会用第三方库，包括<code>STL</code>；最后提供利用第三方库实现的版本。所有代码都可以在我的<a href=\"https://github.com/cloudy064/BlogCodes.git\" target=\"_blank\" rel=\"noopener\">github</a>上找到。好了，闲话不多说，开始今天的主题吧。<br><a id=\"more\"></a></p>\n<h2 id=\"一些废话\"><a href=\"#一些废话\" class=\"headerlink\" title=\"一些废话\"></a>一些废话</h2><p>本着从简单到复杂的原则，我决定这一章只说明一部分原理。（你根本只是想偷懒啊喂！</p>\n<p>注入的方式有很多种，目前我知道的有如下几种方式：</p>\n<ol>\n<li>Windows提供的API:<code>SetWindowsHookEx</code></li>\n<li>远程线程注入</li>\n<li>消息钩子</li>\n</ol>\n<p>而我这一章讲的是『远程线程注入』。因为我觉得这个是最简单的，也是最好理解的，它的原理我可以简单一句话描述：『在目标进程中创建一个线程，让它只做一件事：加载我们想要注入的dll』。</p>\n<p>那么这句话描述的功能中，我们需要推敲几个点：</p>\n<ol>\n<li>我在其他进程中，怎么样才能让目标进程为我创建一个线程？</li>\n<li>目标进程怎么知道我要注入的dll在哪里？</li>\n<li>就算它知道我的dll路径，它怎么知道<code>LoadLibrary</code>的地址？</li>\n</ol>\n<p>我知道大家现在肯定很多疑问，比如『为什么注入的模块一定是dll』，这些以后解答吧，因为我也还存在一些疑问。所以这里你看到的只有代码，这里你只需要跟着我的代码一直敲下去看效果就行了。</p>\n<p>在做注入之前，我们首先需要一个被注入的进程，我们的老朋友<code>Hello World</code>登场，源码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>); <span class=\"comment\">//只是为了让进程不退出，能够让我们注入</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着我们需要准备一个想要注入进去的dll（怎么创建工程自己百度去），代码也很简单：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL APIENTRY <span class=\"title\">DllMain</span><span class=\"params\">( HMODULE hModule,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       DWORD  ul_reason_for_call,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       LPVOID lpReserved</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (ul_reason_for_call)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_PROCESS_ATTACH:</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"i am injected\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_THREAD_ATTACH:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_THREAD_DETACH:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_PROCESS_DETACH:</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它在注入到目标进程之后，会在控制台输出一句话。但是现在它和目标进程没有任何关系。</p>\n<h2 id=\"基础准备\"><a href=\"#基础准备\" class=\"headerlink\" title=\"基础准备\"></a>基础准备</h2><p>所以，接下来就是今天需要重点说明的远程注入所需要用到的<code>API</code>:</p>\n<h3 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h3><p>远程注入的基础是要能够在目标进程中运行代码，那么首当其中的就是创建注入线程的<code>API</code>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HANDLE</span><br><span class=\"line\">WINAPI</span><br><span class=\"line\">CreateRemoteThread(</span><br><span class=\"line\">    _In_ HANDLE hProcess,</span><br><span class=\"line\">    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class=\"line\">    _In_ SIZE_T dwStackSize,</span><br><span class=\"line\">    _In_ LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class=\"line\">    _In_opt_ LPVOID lpParameter,</span><br><span class=\"line\">    _In_ DWORD dwCreationFlags,</span><br><span class=\"line\">    _Out_opt_ LPDWORD lpThreadId</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure></p>\n<p>这个函数的具体描述可以参考<code>MSDN</code>，这里我只挑选重点关注的进行讲解：</p>\n<ol>\n<li>hProcess: 这个是你需要注入的进程的句柄，你可以通过<code>OpenProcess</code>来获得这个句柄。然后你在<code>MSDN</code>会看到这样一句话：<blockquote>\n<p>The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without these rights on certain platforms.<br>你需要在<code>OpenProcess</code>时指定上面提到的这些权限，否则<code>CreateRemoteThread</code>会失败</p>\n</blockquote>\n</li>\n<li>lpStartAddress: 这个是你线程开始运行的地址。这里你需要注意，你并不能传当前进程的函数地址过去，因为每个进程都有自己的虚拟内存，且互相看不见对方有啥（就目前来说），就32位系统来说，虚拟内存的地址范围都是0~4G。也就是说你这边的<code>0x23333333</code>是函数<code>A</code>，而到了目标进程中<code>0x23333333</code>地址就可能是函数<code>B</code>了。所以你这里需要在目标进程中申请一块内存，并且向这块内存中写入线程的起始地址才行，而这就需要用到另外一个知名<code>API</code>了:<code>VirtualAllocEx</code>。</li>\n<li>lpParameter: 这个是线程运行时传递给<code>lpStartAddress</code>的一个参数，额，用过<code>CreateThread</code>的肯定还是知道的，就和那个一模一样。</li>\n</ol>\n<p>所以现在我们可以先写出一部分代码，如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HANDLE hProcess = ::OpenProcess(</span><br><span class=\"line\">        PROCESS_CREATE_THREAD | PROCESS_OPERATION | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE,</span><br><span class=\"line\">        FALSE,</span><br><span class=\"line\">        <span class=\"number\">6916</span><span class=\"comment\">/*进程ID，这里因人而异，可以打开任务管理器看*/</span></span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hProcess == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    HANDLE hThread = ::CreateRemoteThread(</span><br><span class=\"line\">        hProcess,</span><br><span class=\"line\">        <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">/*这里是要执行的函数的起始地址*/</span>,</span><br><span class=\"line\">        <span class=\"comment\">/*传给执行函数的参数地址*/</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"literal\">NULL</span></span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hThread == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ::CloseHandle(hProcess);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ::WaitForSingleObject(hThread, INFINITE); <span class=\"comment\">//这里是为了确保注入线程正常退出，然后做资源回收</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ::CloseHandle(hThread);</span><br><span class=\"line\">    ::CloseHandle(hProcess);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那所以说现在还差两个东西，就是函数的起始地址和传递给函数的参数。继续往下看，你会找到答案。</p>\n<h3 id=\"LoadLibrary\"><a href=\"#LoadLibrary\" class=\"headerlink\" title=\"LoadLibrary\"></a>LoadLibrary</h3><p>我们先用<a href=\"https://technet.microsoft.com/en-us/sysinternals/bb896653/\" target=\"_blank\" rel=\"noopener\">ProcExp</a>来看下各个进程中<code>kernel32.dll</code>的地址分布吧：<br><img src=\"/2016/07/14/inject-2016-07-14-remote-inject/explorer_kernel32_address.jpg\" title=\"Explorer.exe中kernel32的地址\"><br><img src=\"/2016/07/14/inject-2016-07-14-remote-inject/devenv_kernel32_address.jpg\" title=\"VS中kernel32的地址\"></p>\n<p>可以看出来，<code>kernel32.dll</code>在进程中的起始地址都是固定的，大家也可以自己验证下其他进程。而<code>LoadLibraryW</code>在<code>kernel32.dll</code>中的偏移地址也是一定的，所以如果我们想要知道目标进程中<code>LoadLibraryW</code>的地址，其实就可以获取当前进程中<code>LoadLibraryW</code>的地址。</p>\n<p>所以获取<code>LoadLibraryW</code>的地址的代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HMODULE hKnl = ::LoadLibraryW(<span class=\"string\">L\"kernel32.dll\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (hKnl == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">LPTHREAD_START_ROUTINE pLoadLibrary = (LPTHREAD_START_ROUTINE)::GetProcAddress(hKnl, <span class=\"string\">\"LoadLibraryW\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pLoadLibrary == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"申请内存\"><a href=\"#申请内存\" class=\"headerlink\" title=\"申请内存\"></a>申请内存</h3><p>现在我们还缺一个传递给<code>LoadLibraryW</code>的参数，也就是我们需要注入的dll的地址。但是由于我们创建的线程是在目标进程中跑的，而目标进程无法读取到我们当前进程中的内存，我们需要创建一块目标进程中的内存才行。所以自然地就引出了下面这个<code>API</code>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPVOID</span><br><span class=\"line\">WINAPI</span><br><span class=\"line\">VirtualAllocEx(</span><br><span class=\"line\">    _In_ HANDLE hProcess,</span><br><span class=\"line\">    _In_opt_ LPVOID lpAddress,</span><br><span class=\"line\">    _In_ SIZE_T dwSize,</span><br><span class=\"line\">    _In_ DWORD flAllocationType,</span><br><span class=\"line\">    _In_ DWORD flProtect</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure></p>\n<p>这个函数可以向目标进程申请一块内存，并且这块内存会被初始化为0。函数的具体参数解释如下：</p>\n<ol>\n<li>hProcess: 目标进程的句柄，不做解释</li>\n<li>lpAddress: 内存的起始地址，这里传NULL就行了</li>\n<li>dwSize: 申请的内存的大熊啊</li>\n<li>flAllocationType: 这个是申请内存的类型，以后会细讲，这里传<code>MEM_COMMIT</code>就行了</li>\n<li>flProtect: 这个是你对这块内存索取的权限，以后细讲，这里传<code>PAGE_READWRITE</code>即可</li>\n</ol>\n<p>我们现在有了目标进程中的一块内存，但是我们还要借助另外一个<code>API</code>来实现向这块内存中写入数据:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL</span><br><span class=\"line\">WINAPI</span><br><span class=\"line\">WriteProcessMemory(</span><br><span class=\"line\">    _In_ HANDLE hProcess,</span><br><span class=\"line\">    _In_ LPVOID lpBaseAddress,</span><br><span class=\"line\">    _In_reads_bytes_(nSize) LPCVOID lpBuffer,</span><br><span class=\"line\">    _In_ SIZE_T nSize,</span><br><span class=\"line\">    _Out_opt_ SIZE_T * lpNumberOfBytesWritten</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure></p>\n<p>比如我们需要注入的<code>dll</code>的路径是<code>D:\\RemoteInjectDll.dll</code>，那么代码如下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPCWSTR lpszDllPath = L<span class=\"string\">R\"(D:\\RemoteInjectDll.dll)\"</span>;</span><br><span class=\"line\">SIZE_T dwMemSize = <span class=\"keyword\">static_cast</span>&lt;SIZE_T&gt;((wcslen(lpszDllPath) + <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(WCHAR));</span><br><span class=\"line\">LPVOID lpRemoteMemory = ::VirtualAllocEx(hProcess, <span class=\"literal\">NULL</span>, dwMemSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (lpRemoteMemory == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SIZE_T sizeWritten = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!::WriteProcessMemory(hProcess, lpRemoteMemory, (LPCVOID)lpszDllPath, dwMemSize, &amp;sizeWritten))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"最后组装\"><a href=\"#最后组装\" class=\"headerlink\" title=\"最后组装\"></a>最后组装</h2><p>现在所有的条件都具备了，需要把这几块都组装一下，形成的最终代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// RemoteInjectExe.cpp : Defines the entry point for the console application.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HANDLE hProcess = ::OpenProcess(</span><br><span class=\"line\">        PROCESS_CREATE_THREAD | PROCESS_OPERATION | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE,</span><br><span class=\"line\">        FALSE,</span><br><span class=\"line\">        <span class=\"number\">6916</span></span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hProcess == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LPCWSTR lpszDllPath = L<span class=\"string\">R\"(D:\\workspaces\\c++\\RemoteInjectExe\\Debug\\RemoteInjectDll.dll)\"</span>; <span class=\"comment\">//我改了下地址</span></span><br><span class=\"line\">    SIZE_T dwMemSize = <span class=\"keyword\">static_cast</span>&lt;SIZE_T&gt;((wcslen(lpszDllPath) + <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(WCHAR));</span><br><span class=\"line\">    LPVOID lpRemoteMemory = ::VirtualAllocEx(hProcess, <span class=\"literal\">NULL</span>, dwMemSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lpRemoteMemory == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SIZE_T sizeWritten = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::WriteProcessMemory(hProcess, lpRemoteMemory, (LPCVOID)lpszDllPath, dwMemSize, &amp;sizeWritten))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">        ::CloseHandle(hProcess);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    HMODULE hKnl = ::LoadLibraryW(<span class=\"string\">L\"kernel32.dll\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hKnl == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">        ::CloseHandle(hProcess);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LPTHREAD_START_ROUTINE pLoadLibrary = (LPTHREAD_START_ROUTINE)::GetProcAddress(hKnl, <span class=\"string\">\"LoadLibraryW\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pLoadLibrary == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ::FreeLibrary(hKnl);</span><br><span class=\"line\">        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">        ::CloseHandle(hProcess);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DWORD dwThreadId;</span><br><span class=\"line\">    HANDLE hThread = ::CreateRemoteThread(</span><br><span class=\"line\">        hProcess,</span><br><span class=\"line\">        <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        pLoadLibrary,</span><br><span class=\"line\">        lpRemoteMemory,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        &amp;dwThreadId);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hThread == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ::FreeLibrary(hKnl);</span><br><span class=\"line\">        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">        ::CloseHandle(hProcess);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ::WaitForSingleObject(hThread, INFINITE);</span><br><span class=\"line\"></span><br><span class=\"line\">    ::FreeLibrary(hKnl);</span><br><span class=\"line\">    ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">    ::CloseHandle(hProcess);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>我们现在把<code>HelloWorld.exe</code>运行起来，然后把<code>OpenProcess</code>函数中的最后一个参数改为<code>HelloWorld.exe</code>的进程ID，编译运行即可。可以看到最终运行结果如下：<br></p>\n<p>到这里就完全讲完了，所以注入也不是一个神奇的事情，完全就是<code>API</code>的事情，知道了就行了。至于原理，做完了之后可以慢慢研究。</p>\n<h2 id=\"代码优化\"><a href=\"#代码优化\" class=\"headerlink\" title=\"代码优化\"></a>代码优化</h2><ol>\n<li>你看代码里面很多那种资源回收的代码，而且是完全相同的，是不是可以有一个统一回收的机制呢？比如说我们利用<code>C++</code>中析构函数会在对象生命周期结束时被调用，因为这里我们仅仅是需要在main函数结束的时候能够把句柄和内存释放掉。所以就有了下面两个类：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeHandle</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ScopeHandle(HANDLE h)</span><br><span class=\"line\">        : m_h(h)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScopeHandle(<span class=\"keyword\">const</span> ScopeHandle&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ~ScopeHandle()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Attach</span><span class=\"params\">(HANDLE h)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\">        m_h = h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">HANDLE <span class=\"title\">Detach</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        HANDLE h = m_h;</span><br><span class=\"line\">        m_h = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">HANDLE</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScopeHandle&amp; <span class=\"keyword\">operator</span>=(HANDLE h)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\">        m_h = h;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScopeHandle&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> ScopeHandle&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Close</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_h != <span class=\"literal\">NULL</span> || m_h != INVALID_HANDLE_VALUE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ::CloseHandle(m_h);</span><br><span class=\"line\">            m_h = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    HANDLE m_h;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeVirtualMemoryEx</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ScopeVirtualMemoryEx(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)</span><br><span class=\"line\">        : m_lpMemory(lpMemory)</span><br><span class=\"line\">        , m_hProcess(hProcess)</span><br><span class=\"line\">        , m_memSize(memSize)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScopeVirtualMemoryEx(<span class=\"keyword\">const</span> ScopeVirtualMemoryEx&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~ScopeVirtualMemoryEx()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Attach</span><span class=\"params\">(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\">        m_lpMemory = lpMemory;</span><br><span class=\"line\">        m_hProcess = hProcess;</span><br><span class=\"line\">        m_memSize = memSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">LPVOID <span class=\"title\">Detach</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        LPVOID lpMemory = m_lpMemory;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> lpMemory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">LPVOID</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_lpMemory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScopeVirtualMemoryEx&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> ScopeVirtualMemoryEx&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Close</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_lpMemory == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_hProcess == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ::VirtualFreeEx(m_hProcess, m_lpMemory, m_memSize, MEM_RELEASE);</span><br><span class=\"line\"></span><br><span class=\"line\">        m_hProcess = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        m_lpMemory = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        m_memSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    LPVOID m_lpMemory;</span><br><span class=\"line\">    HANDLE m_hProcess;</span><br><span class=\"line\">    SIZE_T m_memSize;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>有的人是不是会觉得得不偿失啊？我为了优化不到20行代码，平白无故多出来100多行代码。这个的话，看个人喜好吧。</p>\n<p>那上面的是不是优化结束了呢？那万一我还有10个其他自定义的对象也需要这种自动释放的机制，那是不是还要在写100个类了？</p>\n<p>所以，我们继续观察，可以发现其实上面两个类有非常多的相似之处，如果排除掉成员变量的因素，那就一模一样了！那么还能怎么抽取呢？我们观察下上面两个类，可以发现无非就是需要做两件事情：</p>\n<ol>\n<li>判断代理的目标对象是否有效</li>\n<li>释放代理的目标对象</li>\n</ol>\n<p>也就是说我们其实可以再在这两个类上抽象一层，比如就叫<code>AutoReleaseObject</code>吧，然后传递一个判断是否有效以及释放的方法。恩，想法是很美好的，那么问题又来了，如果只有一个参数我们还能用一个模板来消除差异性，现在它们释放的函数签名完全不同，这你让我怎么玩？别急啊，办法总是有的。其中心思想就是把数据处理与流程分离（也可以理解为机制与策略分离，详见《unix编程思想》），那么我后来就写出了下面的代码（妈蛋，怎么越来越麻烦了！:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoReleaseDelegate</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    AutoReleaseDelegate(T obj)</span><br><span class=\"line\">        : m_obj(obj)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~AutoReleaseDelegate()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">Validate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Release</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">T</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    T m_obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandleDelegate</span></span></span><br><span class=\"line\"><span class=\"class\">    :</span> <span class=\"keyword\">public</span> AutoReleaseDelegate&lt;HANDLE&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> super = AutoReleaseDelegate&lt;HANDLE&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    HandleDelegate(HANDLE h)</span><br><span class=\"line\">        : AutoReleaseDelegate(h)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~HandleDelegate()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">Validate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (super::m_obj != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Release</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ::CloseHandle(super::m_obj);</span><br><span class=\"line\">        super::m_obj = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VirtualMemoryExDelegate</span></span></span><br><span class=\"line\"><span class=\"class\">    :</span> <span class=\"keyword\">public</span> AutoReleaseDelegate&lt;LPVOID&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> super = AutoReleaseDelegate&lt;LPVOID&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    VirtualMemoryExDelegate(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)</span><br><span class=\"line\">        : AutoReleaseDelegate(lpMemory)</span><br><span class=\"line\">        , m_hProcess(hProcess)</span><br><span class=\"line\">        , m_memSize(memSize)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~VirtualMemoryExDelegate()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">Validate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (super::m_obj == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_hProcess == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Release</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ::VirtualFreeEx(m_hProcess, super::m_obj, m_memSize, MEM_RELEASE);</span><br><span class=\"line\">        m_hProcess = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        super::m_obj = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        m_memSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    HANDLE m_hProcess;</span><br><span class=\"line\">    SIZE_T m_memSize;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoReleaseObj</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> DelegateType = AutoReleaseDelegate&lt;T&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    AutoReleaseObj(DelegateType* pDelegate)</span><br><span class=\"line\">        : m_pDelegate(pDelegate)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    AutoReleaseObj(<span class=\"keyword\">const</span> AutoReleaseObj&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~AutoReleaseObj()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        assert(m_pDelegate != <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pDelegate-&gt;Validate())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            m_pDelegate-&gt;Release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">T</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        assert(m_pDelegate != <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> T(*m_pDelegate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AutoReleaseObj&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(AutoReleaseObj&lt;T&gt;&amp; rhs) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    DelegateType* m_pDelegate;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样一来我们要接入新的需要<code>AutoRelease</code>特性的对象时，只需要继承<code>AutoReleaseDelegate</code>即可，而整个流程不在需要你去关系，交给<code>AutoReleaseObj</code>就行了。当然上面的代码这样写不免有些过度设计之嫌，还是那句话，用你你喜欢或者你习惯的方式就好，不必追求什么设计。</p>\n<p>我自己的优化已经结束了，如果大家觉得还有哪里可以进行优化的话，欢迎提出来，我努力实现。还有这里肯定会有人问为什么指针不判空，我想说，请分清楚库代码和工作代码之间的区别。</p>\n<p>这次没有<code>ATL</code>优化版本，<code>ATL</code>中只提供了<code>CHandle</code>对<code>HANDLE</code>进行封装，其他并没有做任何封装（或者我没有找到），所以注入的第一篇就到这里结束啦，大家好好消化下吧。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>写这个系列文章主要是为了学习下Windows中了解但是还不是很熟悉的知识及其原理，并且因为这两年的工作大部分都体现在注入上了。说起注入，这个真的是病毒、杀软、监控等不可或缺的一门技术。知道你的Windows为什么这么慢么？你以为加内存就可以了？你以为仅仅是Windows卡死了？呵呵。。。</p>\n<p>为了能让大家能有目的地去接触注入这门技术，这个系列我准备最终做一个监控其他模块注入的小工具吧。至于技术上能不能实现出来，那就是另外一回事了。另外，我提供的代码会用<code>Windows Native API</code>先实现一版；然后再对代码进行优化，但是过程中不会用第三方库，包括<code>STL</code>；最后提供利用第三方库实现的版本。所有代码都可以在我的<a href=\"https://github.com/cloudy064/BlogCodes.git\" target=\"_blank\" rel=\"noopener\">github</a>上找到。好了，闲话不多说，开始今天的主题吧。<br>","more":"</p>\n<h2 id=\"一些废话\"><a href=\"#一些废话\" class=\"headerlink\" title=\"一些废话\"></a>一些废话</h2><p>本着从简单到复杂的原则，我决定这一章只说明一部分原理。（你根本只是想偷懒啊喂！</p>\n<p>注入的方式有很多种，目前我知道的有如下几种方式：</p>\n<ol>\n<li>Windows提供的API:<code>SetWindowsHookEx</code></li>\n<li>远程线程注入</li>\n<li>消息钩子</li>\n</ol>\n<p>而我这一章讲的是『远程线程注入』。因为我觉得这个是最简单的，也是最好理解的，它的原理我可以简单一句话描述：『在目标进程中创建一个线程，让它只做一件事：加载我们想要注入的dll』。</p>\n<p>那么这句话描述的功能中，我们需要推敲几个点：</p>\n<ol>\n<li>我在其他进程中，怎么样才能让目标进程为我创建一个线程？</li>\n<li>目标进程怎么知道我要注入的dll在哪里？</li>\n<li>就算它知道我的dll路径，它怎么知道<code>LoadLibrary</code>的地址？</li>\n</ol>\n<p>我知道大家现在肯定很多疑问，比如『为什么注入的模块一定是dll』，这些以后解答吧，因为我也还存在一些疑问。所以这里你看到的只有代码，这里你只需要跟着我的代码一直敲下去看效果就行了。</p>\n<p>在做注入之前，我们首先需要一个被注入的进程，我们的老朋友<code>Hello World</code>登场，源码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    system(<span class=\"string\">\"pause\"</span>); <span class=\"comment\">//只是为了让进程不退出，能够让我们注入</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着我们需要准备一个想要注入进去的dll（怎么创建工程自己百度去），代码也很简单：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL APIENTRY <span class=\"title\">DllMain</span><span class=\"params\">( HMODULE hModule,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       DWORD  ul_reason_for_call,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                       LPVOID lpReserved</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (ul_reason_for_call)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_PROCESS_ATTACH:</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"i am injected\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_THREAD_ATTACH:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_THREAD_DETACH:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> DLL_PROCESS_DETACH:</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它在注入到目标进程之后，会在控制台输出一句话。但是现在它和目标进程没有任何关系。</p>\n<h2 id=\"基础准备\"><a href=\"#基础准备\" class=\"headerlink\" title=\"基础准备\"></a>基础准备</h2><p>所以，接下来就是今天需要重点说明的远程注入所需要用到的<code>API</code>:</p>\n<h3 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h3><p>远程注入的基础是要能够在目标进程中运行代码，那么首当其中的就是创建注入线程的<code>API</code>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HANDLE</span><br><span class=\"line\">WINAPI</span><br><span class=\"line\">CreateRemoteThread(</span><br><span class=\"line\">    _In_ HANDLE hProcess,</span><br><span class=\"line\">    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class=\"line\">    _In_ SIZE_T dwStackSize,</span><br><span class=\"line\">    _In_ LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class=\"line\">    _In_opt_ LPVOID lpParameter,</span><br><span class=\"line\">    _In_ DWORD dwCreationFlags,</span><br><span class=\"line\">    _Out_opt_ LPDWORD lpThreadId</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure></p>\n<p>这个函数的具体描述可以参考<code>MSDN</code>，这里我只挑选重点关注的进行讲解：</p>\n<ol>\n<li>hProcess: 这个是你需要注入的进程的句柄，你可以通过<code>OpenProcess</code>来获得这个句柄。然后你在<code>MSDN</code>会看到这样一句话：<blockquote>\n<p>The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without these rights on certain platforms.<br>你需要在<code>OpenProcess</code>时指定上面提到的这些权限，否则<code>CreateRemoteThread</code>会失败</p>\n</blockquote>\n</li>\n<li>lpStartAddress: 这个是你线程开始运行的地址。这里你需要注意，你并不能传当前进程的函数地址过去，因为每个进程都有自己的虚拟内存，且互相看不见对方有啥（就目前来说），就32位系统来说，虚拟内存的地址范围都是0~4G。也就是说你这边的<code>0x23333333</code>是函数<code>A</code>，而到了目标进程中<code>0x23333333</code>地址就可能是函数<code>B</code>了。所以你这里需要在目标进程中申请一块内存，并且向这块内存中写入线程的起始地址才行，而这就需要用到另外一个知名<code>API</code>了:<code>VirtualAllocEx</code>。</li>\n<li>lpParameter: 这个是线程运行时传递给<code>lpStartAddress</code>的一个参数，额，用过<code>CreateThread</code>的肯定还是知道的，就和那个一模一样。</li>\n</ol>\n<p>所以现在我们可以先写出一部分代码，如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HANDLE hProcess = ::OpenProcess(</span><br><span class=\"line\">        PROCESS_CREATE_THREAD | PROCESS_OPERATION | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE,</span><br><span class=\"line\">        FALSE,</span><br><span class=\"line\">        <span class=\"number\">6916</span><span class=\"comment\">/*进程ID，这里因人而异，可以打开任务管理器看*/</span></span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hProcess == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    HANDLE hThread = ::CreateRemoteThread(</span><br><span class=\"line\">        hProcess,</span><br><span class=\"line\">        <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"comment\">/*这里是要执行的函数的起始地址*/</span>,</span><br><span class=\"line\">        <span class=\"comment\">/*传给执行函数的参数地址*/</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"literal\">NULL</span></span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hThread == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ::CloseHandle(hProcess);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ::WaitForSingleObject(hThread, INFINITE); <span class=\"comment\">//这里是为了确保注入线程正常退出，然后做资源回收</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ::CloseHandle(hThread);</span><br><span class=\"line\">    ::CloseHandle(hProcess);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那所以说现在还差两个东西，就是函数的起始地址和传递给函数的参数。继续往下看，你会找到答案。</p>\n<h3 id=\"LoadLibrary\"><a href=\"#LoadLibrary\" class=\"headerlink\" title=\"LoadLibrary\"></a>LoadLibrary</h3><p>我们先用<a href=\"https://technet.microsoft.com/en-us/sysinternals/bb896653/\" target=\"_blank\" rel=\"noopener\">ProcExp</a>来看下各个进程中<code>kernel32.dll</code>的地址分布吧：<br><img src=\"/2016/07/14/inject-2016-07-14-remote-inject/explorer_kernel32_address.jpg\" title=\"Explorer.exe中kernel32的地址\"><br><img src=\"/2016/07/14/inject-2016-07-14-remote-inject/devenv_kernel32_address.jpg\" title=\"VS中kernel32的地址\"></p>\n<p>可以看出来，<code>kernel32.dll</code>在进程中的起始地址都是固定的，大家也可以自己验证下其他进程。而<code>LoadLibraryW</code>在<code>kernel32.dll</code>中的偏移地址也是一定的，所以如果我们想要知道目标进程中<code>LoadLibraryW</code>的地址，其实就可以获取当前进程中<code>LoadLibraryW</code>的地址。</p>\n<p>所以获取<code>LoadLibraryW</code>的地址的代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HMODULE hKnl = ::LoadLibraryW(<span class=\"string\">L\"kernel32.dll\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (hKnl == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">LPTHREAD_START_ROUTINE pLoadLibrary = (LPTHREAD_START_ROUTINE)::GetProcAddress(hKnl, <span class=\"string\">\"LoadLibraryW\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pLoadLibrary == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"申请内存\"><a href=\"#申请内存\" class=\"headerlink\" title=\"申请内存\"></a>申请内存</h3><p>现在我们还缺一个传递给<code>LoadLibraryW</code>的参数，也就是我们需要注入的dll的地址。但是由于我们创建的线程是在目标进程中跑的，而目标进程无法读取到我们当前进程中的内存，我们需要创建一块目标进程中的内存才行。所以自然地就引出了下面这个<code>API</code>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPVOID</span><br><span class=\"line\">WINAPI</span><br><span class=\"line\">VirtualAllocEx(</span><br><span class=\"line\">    _In_ HANDLE hProcess,</span><br><span class=\"line\">    _In_opt_ LPVOID lpAddress,</span><br><span class=\"line\">    _In_ SIZE_T dwSize,</span><br><span class=\"line\">    _In_ DWORD flAllocationType,</span><br><span class=\"line\">    _In_ DWORD flProtect</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure></p>\n<p>这个函数可以向目标进程申请一块内存，并且这块内存会被初始化为0。函数的具体参数解释如下：</p>\n<ol>\n<li>hProcess: 目标进程的句柄，不做解释</li>\n<li>lpAddress: 内存的起始地址，这里传NULL就行了</li>\n<li>dwSize: 申请的内存的大熊啊</li>\n<li>flAllocationType: 这个是申请内存的类型，以后会细讲，这里传<code>MEM_COMMIT</code>就行了</li>\n<li>flProtect: 这个是你对这块内存索取的权限，以后细讲，这里传<code>PAGE_READWRITE</code>即可</li>\n</ol>\n<p>我们现在有了目标进程中的一块内存，但是我们还要借助另外一个<code>API</code>来实现向这块内存中写入数据:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL</span><br><span class=\"line\">WINAPI</span><br><span class=\"line\">WriteProcessMemory(</span><br><span class=\"line\">    _In_ HANDLE hProcess,</span><br><span class=\"line\">    _In_ LPVOID lpBaseAddress,</span><br><span class=\"line\">    _In_reads_bytes_(nSize) LPCVOID lpBuffer,</span><br><span class=\"line\">    _In_ SIZE_T nSize,</span><br><span class=\"line\">    _Out_opt_ SIZE_T * lpNumberOfBytesWritten</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></figure></p>\n<p>比如我们需要注入的<code>dll</code>的路径是<code>D:\\RemoteInjectDll.dll</code>，那么代码如下:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPCWSTR lpszDllPath = L<span class=\"string\">R\"(D:\\RemoteInjectDll.dll)\"</span>;</span><br><span class=\"line\">SIZE_T dwMemSize = <span class=\"keyword\">static_cast</span>&lt;SIZE_T&gt;((wcslen(lpszDllPath) + <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(WCHAR));</span><br><span class=\"line\">LPVOID lpRemoteMemory = ::VirtualAllocEx(hProcess, <span class=\"literal\">NULL</span>, dwMemSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (lpRemoteMemory == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SIZE_T sizeWritten = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!::WriteProcessMemory(hProcess, lpRemoteMemory, (LPCVOID)lpszDllPath, dwMemSize, &amp;sizeWritten))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"最后组装\"><a href=\"#最后组装\" class=\"headerlink\" title=\"最后组装\"></a>最后组装</h2><p>现在所有的条件都具备了，需要把这几块都组装一下，形成的最终代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// RemoteInjectExe.cpp : Defines the entry point for the console application.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HANDLE hProcess = ::OpenProcess(</span><br><span class=\"line\">        PROCESS_CREATE_THREAD | PROCESS_OPERATION | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_VM_WRITE,</span><br><span class=\"line\">        FALSE,</span><br><span class=\"line\">        <span class=\"number\">6916</span></span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hProcess == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LPCWSTR lpszDllPath = L<span class=\"string\">R\"(D:\\workspaces\\c++\\RemoteInjectExe\\Debug\\RemoteInjectDll.dll)\"</span>; <span class=\"comment\">//我改了下地址</span></span><br><span class=\"line\">    SIZE_T dwMemSize = <span class=\"keyword\">static_cast</span>&lt;SIZE_T&gt;((wcslen(lpszDllPath) + <span class=\"number\">1</span>) * <span class=\"keyword\">sizeof</span>(WCHAR));</span><br><span class=\"line\">    LPVOID lpRemoteMemory = ::VirtualAllocEx(hProcess, <span class=\"literal\">NULL</span>, dwMemSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lpRemoteMemory == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SIZE_T sizeWritten = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::WriteProcessMemory(hProcess, lpRemoteMemory, (LPCVOID)lpszDllPath, dwMemSize, &amp;sizeWritten))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">        ::CloseHandle(hProcess);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    HMODULE hKnl = ::LoadLibraryW(<span class=\"string\">L\"kernel32.dll\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hKnl == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">        ::CloseHandle(hProcess);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LPTHREAD_START_ROUTINE pLoadLibrary = (LPTHREAD_START_ROUTINE)::GetProcAddress(hKnl, <span class=\"string\">\"LoadLibraryW\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pLoadLibrary == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ::FreeLibrary(hKnl);</span><br><span class=\"line\">        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">        ::CloseHandle(hProcess);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DWORD dwThreadId;</span><br><span class=\"line\">    HANDLE hThread = ::CreateRemoteThread(</span><br><span class=\"line\">        hProcess,</span><br><span class=\"line\">        <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        pLoadLibrary,</span><br><span class=\"line\">        lpRemoteMemory,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        &amp;dwThreadId);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hThread == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ::FreeLibrary(hKnl);</span><br><span class=\"line\">        ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">        ::CloseHandle(hProcess);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ::WaitForSingleObject(hThread, INFINITE);</span><br><span class=\"line\"></span><br><span class=\"line\">    ::FreeLibrary(hKnl);</span><br><span class=\"line\">    ::VirtualFreeEx(hProcess, lpRemoteMemory, dwMemSize, MEM_RELEASE);</span><br><span class=\"line\">    ::CloseHandle(hProcess);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>我们现在把<code>HelloWorld.exe</code>运行起来，然后把<code>OpenProcess</code>函数中的最后一个参数改为<code>HelloWorld.exe</code>的进程ID，编译运行即可。可以看到最终运行结果如下：<br></p>\n<p>到这里就完全讲完了，所以注入也不是一个神奇的事情，完全就是<code>API</code>的事情，知道了就行了。至于原理，做完了之后可以慢慢研究。</p>\n<h2 id=\"代码优化\"><a href=\"#代码优化\" class=\"headerlink\" title=\"代码优化\"></a>代码优化</h2><ol>\n<li>你看代码里面很多那种资源回收的代码，而且是完全相同的，是不是可以有一个统一回收的机制呢？比如说我们利用<code>C++</code>中析构函数会在对象生命周期结束时被调用，因为这里我们仅仅是需要在main函数结束的时候能够把句柄和内存释放掉。所以就有了下面两个类：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeHandle</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ScopeHandle(HANDLE h)</span><br><span class=\"line\">        : m_h(h)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScopeHandle(<span class=\"keyword\">const</span> ScopeHandle&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ~ScopeHandle()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Attach</span><span class=\"params\">(HANDLE h)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\">        m_h = h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">HANDLE <span class=\"title\">Detach</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        HANDLE h = m_h;</span><br><span class=\"line\">        m_h = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">HANDLE</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScopeHandle&amp; <span class=\"keyword\">operator</span>=(HANDLE h)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\">        m_h = h;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (*<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScopeHandle&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> ScopeHandle&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Close</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_h != <span class=\"literal\">NULL</span> || m_h != INVALID_HANDLE_VALUE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ::CloseHandle(m_h);</span><br><span class=\"line\">            m_h = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    HANDLE m_h;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScopeVirtualMemoryEx</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ScopeVirtualMemoryEx(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)</span><br><span class=\"line\">        : m_lpMemory(lpMemory)</span><br><span class=\"line\">        , m_hProcess(hProcess)</span><br><span class=\"line\">        , m_memSize(memSize)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScopeVirtualMemoryEx(<span class=\"keyword\">const</span> ScopeVirtualMemoryEx&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~ScopeVirtualMemoryEx()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Attach</span><span class=\"params\">(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\">        m_lpMemory = lpMemory;</span><br><span class=\"line\">        m_hProcess = hProcess;</span><br><span class=\"line\">        m_memSize = memSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">LPVOID <span class=\"title\">Detach</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        LPVOID lpMemory = m_lpMemory;</span><br><span class=\"line\">        Close();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> lpMemory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">LPVOID</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_lpMemory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ScopeVirtualMemoryEx&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> ScopeVirtualMemoryEx&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Close</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_lpMemory == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_hProcess == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ::VirtualFreeEx(m_hProcess, m_lpMemory, m_memSize, MEM_RELEASE);</span><br><span class=\"line\"></span><br><span class=\"line\">        m_hProcess = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        m_lpMemory = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        m_memSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    LPVOID m_lpMemory;</span><br><span class=\"line\">    HANDLE m_hProcess;</span><br><span class=\"line\">    SIZE_T m_memSize;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>有的人是不是会觉得得不偿失啊？我为了优化不到20行代码，平白无故多出来100多行代码。这个的话，看个人喜好吧。</p>\n<p>那上面的是不是优化结束了呢？那万一我还有10个其他自定义的对象也需要这种自动释放的机制，那是不是还要在写100个类了？</p>\n<p>所以，我们继续观察，可以发现其实上面两个类有非常多的相似之处，如果排除掉成员变量的因素，那就一模一样了！那么还能怎么抽取呢？我们观察下上面两个类，可以发现无非就是需要做两件事情：</p>\n<ol>\n<li>判断代理的目标对象是否有效</li>\n<li>释放代理的目标对象</li>\n</ol>\n<p>也就是说我们其实可以再在这两个类上抽象一层，比如就叫<code>AutoReleaseObject</code>吧，然后传递一个判断是否有效以及释放的方法。恩，想法是很美好的，那么问题又来了，如果只有一个参数我们还能用一个模板来消除差异性，现在它们释放的函数签名完全不同，这你让我怎么玩？别急啊，办法总是有的。其中心思想就是把数据处理与流程分离（也可以理解为机制与策略分离，详见《unix编程思想》），那么我后来就写出了下面的代码（妈蛋，怎么越来越麻烦了！:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoReleaseDelegate</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    AutoReleaseDelegate(T obj)</span><br><span class=\"line\">        : m_obj(obj)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~AutoReleaseDelegate()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">Validate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Release</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">T</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    T m_obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandleDelegate</span></span></span><br><span class=\"line\"><span class=\"class\">    :</span> <span class=\"keyword\">public</span> AutoReleaseDelegate&lt;HANDLE&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> super = AutoReleaseDelegate&lt;HANDLE&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    HandleDelegate(HANDLE h)</span><br><span class=\"line\">        : AutoReleaseDelegate(h)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~HandleDelegate()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">Validate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (super::m_obj != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Release</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ::CloseHandle(super::m_obj);</span><br><span class=\"line\">        super::m_obj = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VirtualMemoryExDelegate</span></span></span><br><span class=\"line\"><span class=\"class\">    :</span> <span class=\"keyword\">public</span> AutoReleaseDelegate&lt;LPVOID&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> super = AutoReleaseDelegate&lt;LPVOID&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    VirtualMemoryExDelegate(LPVOID lpMemory, HANDLE hProcess, SIZE_T memSize)</span><br><span class=\"line\">        : AutoReleaseDelegate(lpMemory)</span><br><span class=\"line\">        , m_hProcess(hProcess)</span><br><span class=\"line\">        , m_memSize(memSize)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~VirtualMemoryExDelegate()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">Validate</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (super::m_obj == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_hProcess == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Release</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ::VirtualFreeEx(m_hProcess, super::m_obj, m_memSize, MEM_RELEASE);</span><br><span class=\"line\">        m_hProcess = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        super::m_obj = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        m_memSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    HANDLE m_hProcess;</span><br><span class=\"line\">    SIZE_T m_memSize;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoReleaseObj</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> DelegateType = AutoReleaseDelegate&lt;T&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    AutoReleaseObj(DelegateType* pDelegate)</span><br><span class=\"line\">        : m_pDelegate(pDelegate)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    AutoReleaseObj(<span class=\"keyword\">const</span> AutoReleaseObj&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~AutoReleaseObj()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        assert(m_pDelegate != <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_pDelegate-&gt;Validate())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            m_pDelegate-&gt;Release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">T</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        assert(m_pDelegate != <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> T(*m_pDelegate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    AutoReleaseObj&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(AutoReleaseObj&lt;T&gt;&amp; rhs) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    DelegateType* m_pDelegate;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样一来我们要接入新的需要<code>AutoRelease</code>特性的对象时，只需要继承<code>AutoReleaseDelegate</code>即可，而整个流程不在需要你去关系，交给<code>AutoReleaseObj</code>就行了。当然上面的代码这样写不免有些过度设计之嫌，还是那句话，用你你喜欢或者你习惯的方式就好，不必追求什么设计。</p>\n<p>我自己的优化已经结束了，如果大家觉得还有哪里可以进行优化的话，欢迎提出来，我努力实现。还有这里肯定会有人问为什么指针不判空，我想说，请分清楚库代码和工作代码之间的区别。</p>\n<p>这次没有<code>ATL</code>优化版本，<code>ATL</code>中只提供了<code>CHandle</code>对<code>HANDLE</code>进行封装，其他并没有做任何封装（或者我没有找到），所以注入的第一篇就到这里结束啦，大家好好消化下吧。</p>"},{"title":"云064教你用hexo搭建博客","date":"2016-06-20T04:16:20.000Z","_content":"\n## 前言\n现在搭建一个博客所需要的成本越来越低了，相比起利用`WordPress`,甚至是自己开发博客框架，利用`hexo`+`github`的方式来进行搭建博客省时省力，并且以`Markdown`的方式进行书写，简化了书写时本就不需要费脑考虑的排版之类的问题，完全将博客内容从界面排版中剥离出来。当然这种方式也有不能够随心所欲控制界面的每个元素的限制，不过对于像我这种低端用户来说已经绰绰有余了。之前的`wordpress`搭建的博客，由于不满于它的写作方式，所以整整一年都没有动笔更新过。所以今天就教大家如何利用`hexo`和`github`搭建一个完全免费的博客。这里只介绍`windows`，至于`linux`和`macos`简单很多，这里我就忽略了。\n<!--more-->\n\n## 安装node.js\n因为`hexo`是跑在`node.js`上的，所以说第一步要做的就是去[node.js官网](https://nodejs.org/en/)下载安装程序。安装完成后，在命令行输入`npm`，如果有输出的话就表示不需要配置了；如果提示找不到这个命令，就需要手动把`nodejs`的安装目录加入到环境变量`PATH`中。\n\n## 安装hexo\n在命令行输入`npm install -g hexo-cli`，将`hexo`安装到全局目录中，完成。\n\n## 创建github仓库\n如果没有`github`账户先去注册一个，如果你被`Greate Fucking Wall`墙了，那我也没办法了。然后在主页点击`new repository`，然后将名字填写成你的`github名字.github.io`（一定是这个名字），然后点击`Create repository`就行了。如下图所示：\n{% asset_img newrepository.png 创建仓库 %}\n\n## 安装并配置git\n去[git官网](https://git-scm.com/download)下载`git`工具，所有安装选项都默认就行了。安装完成后，我们需要配置我们的`github`的用户名和密码：\n```cmd\ngit config --global user.name cloudy064\ngit config --global user.email cloudy@gmail.com\ngit config --global user.password **********\n```\n\n做好了这些之后我们还需要一个`SSH key`，不明白的人自己去百度是干嘛的吧，这里不解释。在命令行继续输入：\n```cmd\nssh-keygen -t rsa -C\"cloudy064@gmail.com\"\n```\n\n然后一路回车，之后就可以在用户目录下（我这边是`C:\\Users\\cloudy`目录）找到`.ssh`文件夹，该文件夹下主要看一个文件`id_rsa.pub`，待会儿会用到。\n\n打开`github`页面，在右上角下拉菜单中点击`Setting`，进入到设置页面，然后点击`SSH and GPG keys`，看到下面这个界面：\n{% asset_img generatesshkey.png 生成SSH key %}\n\n你需要点击右上角的`New SSH key`，然后在下面的输入框填写相关信息，`Title`随便填，只是一个标题而已，而`key`则需要把刚刚`id_rsa.pub`中的内容拷贝过来，然后点击`Add SSH key`即可。\n\n到目前为止`git`就配置完成了。\n\n## 准备博客目录\n打开你的命令行工具，跳转到你想要存放博客文件的目录下，然后一次输入下面几个命令行：\n```cmd\nnpm install hexo --save\nhexo init\n```\n\n然后还需要安装`Hexo`插件，让他变得更完善，再依次输入下面的命令行：\n```cmd\nnpm install hexo-generator-index --save\nnpm install hexo-generator-archive --save\nnpm install hexo-generator-category --save\nnpm install hexo-generator-tag --save\nnpm install hexo-generator-feed@1 --save\nnpm install hexo-generator-sitemap@1 --save\n\nnpm install hexo-server --save\n\nnpm install hexo-deployer-git --save\nnpm install hexo-deployer-heroku --save\nnpm install hexo-deployer-rsync --save\nnpm install hexo-deployer-openshift --save\n\nnpm install hexo-renderer-marked@0.2 --save\nnpm install hexo-renderer-stylus@0.2 --save\n```\n\n这样一个初步的`hexo`博客就搭建完成了。\n\n## 配置hexo\n但是我们的博客发布到哪里呢？打开你的`github`页面，进入到你刚刚创建的仓库中，点击右边的`Clone or download`，然后在下面弹出的对话框中，将输入框中的内容复制下来，等下有用。我这里的内容是`git@github.com:cloudy064/cloudy064.github.io.git`：\n{% asset_img getrepositoryaddress.png 找到发布地址 %}\n\n打开博客根目录下的`_config.yml`配置文件，这里面也很多比如标题、作者之类的信息需要你自己去填写。我主要说下发布这里，在最后找到`deploy:`，然后回车，空两个，输入下面的内容：\n```\n  repository: git@github.com:cloudy064/cloudy064.github.io.git\n  type: git\n  branch: master\n```\n\n这里就是告诉`hexo`，我写完了之后发布到哪个网址。\n\n这样`hexo`也配置完成了。\n\n## 发布博客\n打开你的命令行工具，然后跳转到博客的目录下去，依次输入下面的命令行:\n```cmd\nhexo g\nhexo d\n```\n\n然后再打开你的浏览器，输入你的博客地址，也就是仓库名称，我的是`cloudy064.github.io`，然后就可以看到`HelloWorld`这个熟悉的文章了。\n\n## 创建博文\n打开命令行工具，输入:\n```\nhexo n \"first blog\"\n```\n\n然后你就可以在`source\\_post\\`目录下找到`first blog.md`，你所要做的就是用`Markdown`语法创作你的博客，完成之后，按照上面发布博客的流程进行发布就可以了。\n\n## 其他问题\n\n### 添加图片\n这里我用的是`hexo`自定义的标签添加图片的。打开`_config.yml`文件，找到`post_asset_folder`选项，把后面的`false`改成`true`。然后以后你用`hexo n`创建博文的时候，在同级目录下会创建一个同名的目录，这个目录里面就是存放图片的，你在博文里面要做的就是利用下面的语句来插入图片：\n```\n{% asset_img 图片名字 图片描述 %}\n```\n\n当然这种方式插入图片有一个弊端就是不好移植，因为是`hexo`专有语法。我用这种方法纯属是因为方便管理，不需要人工去维护图片的存放位置。\n\n### 替换主题\n比如我这里用的就是`Next`主题，你需要做的就是用下面的命令把这个主题`clone`到本地：\n```cmd\ngit clone https://github.com/iissnan/hexo-theme-next\n```\n\n然后在博客目录下的`themes`文件夹中创建一个新的文件夹，我命名为`Next`，把刚刚`clone`下来的文件中的，除了`.git`和`.github`的文件拷贝到`Next`文件夹中。\n\n然后修改博客根目录下的`_config.yml`，找到`theme`一行，把后面的名字修改为`Next`即可。\n\n然后利用`hexo g`重新生成博客，再用`hexo d`发布上线，就可以看到实际效果了\n\n### 测试博客效果\n`hexo`提供了本地服务器的功能，你可以在用`hexo g`生成博客之后，通过输入`hexo s`，然后在浏览器输入`localhost:4000`来访问上线之后的效果。比如像上面替换主题这种大修改，这种本地测试的方式会很有用。","source":"_posts/hexo/2016-06-20-build-blog-with-hexo.md","raw":"---\ntitle: 云064教你用hexo搭建博客\ndate: 2016-06-20 12:16:20\ncategories: blog\ntags: [blog, hexo]\n---\n\n## 前言\n现在搭建一个博客所需要的成本越来越低了，相比起利用`WordPress`,甚至是自己开发博客框架，利用`hexo`+`github`的方式来进行搭建博客省时省力，并且以`Markdown`的方式进行书写，简化了书写时本就不需要费脑考虑的排版之类的问题，完全将博客内容从界面排版中剥离出来。当然这种方式也有不能够随心所欲控制界面的每个元素的限制，不过对于像我这种低端用户来说已经绰绰有余了。之前的`wordpress`搭建的博客，由于不满于它的写作方式，所以整整一年都没有动笔更新过。所以今天就教大家如何利用`hexo`和`github`搭建一个完全免费的博客。这里只介绍`windows`，至于`linux`和`macos`简单很多，这里我就忽略了。\n<!--more-->\n\n## 安装node.js\n因为`hexo`是跑在`node.js`上的，所以说第一步要做的就是去[node.js官网](https://nodejs.org/en/)下载安装程序。安装完成后，在命令行输入`npm`，如果有输出的话就表示不需要配置了；如果提示找不到这个命令，就需要手动把`nodejs`的安装目录加入到环境变量`PATH`中。\n\n## 安装hexo\n在命令行输入`npm install -g hexo-cli`，将`hexo`安装到全局目录中，完成。\n\n## 创建github仓库\n如果没有`github`账户先去注册一个，如果你被`Greate Fucking Wall`墙了，那我也没办法了。然后在主页点击`new repository`，然后将名字填写成你的`github名字.github.io`（一定是这个名字），然后点击`Create repository`就行了。如下图所示：\n{% asset_img newrepository.png 创建仓库 %}\n\n## 安装并配置git\n去[git官网](https://git-scm.com/download)下载`git`工具，所有安装选项都默认就行了。安装完成后，我们需要配置我们的`github`的用户名和密码：\n```cmd\ngit config --global user.name cloudy064\ngit config --global user.email cloudy@gmail.com\ngit config --global user.password **********\n```\n\n做好了这些之后我们还需要一个`SSH key`，不明白的人自己去百度是干嘛的吧，这里不解释。在命令行继续输入：\n```cmd\nssh-keygen -t rsa -C\"cloudy064@gmail.com\"\n```\n\n然后一路回车，之后就可以在用户目录下（我这边是`C:\\Users\\cloudy`目录）找到`.ssh`文件夹，该文件夹下主要看一个文件`id_rsa.pub`，待会儿会用到。\n\n打开`github`页面，在右上角下拉菜单中点击`Setting`，进入到设置页面，然后点击`SSH and GPG keys`，看到下面这个界面：\n{% asset_img generatesshkey.png 生成SSH key %}\n\n你需要点击右上角的`New SSH key`，然后在下面的输入框填写相关信息，`Title`随便填，只是一个标题而已，而`key`则需要把刚刚`id_rsa.pub`中的内容拷贝过来，然后点击`Add SSH key`即可。\n\n到目前为止`git`就配置完成了。\n\n## 准备博客目录\n打开你的命令行工具，跳转到你想要存放博客文件的目录下，然后一次输入下面几个命令行：\n```cmd\nnpm install hexo --save\nhexo init\n```\n\n然后还需要安装`Hexo`插件，让他变得更完善，再依次输入下面的命令行：\n```cmd\nnpm install hexo-generator-index --save\nnpm install hexo-generator-archive --save\nnpm install hexo-generator-category --save\nnpm install hexo-generator-tag --save\nnpm install hexo-generator-feed@1 --save\nnpm install hexo-generator-sitemap@1 --save\n\nnpm install hexo-server --save\n\nnpm install hexo-deployer-git --save\nnpm install hexo-deployer-heroku --save\nnpm install hexo-deployer-rsync --save\nnpm install hexo-deployer-openshift --save\n\nnpm install hexo-renderer-marked@0.2 --save\nnpm install hexo-renderer-stylus@0.2 --save\n```\n\n这样一个初步的`hexo`博客就搭建完成了。\n\n## 配置hexo\n但是我们的博客发布到哪里呢？打开你的`github`页面，进入到你刚刚创建的仓库中，点击右边的`Clone or download`，然后在下面弹出的对话框中，将输入框中的内容复制下来，等下有用。我这里的内容是`git@github.com:cloudy064/cloudy064.github.io.git`：\n{% asset_img getrepositoryaddress.png 找到发布地址 %}\n\n打开博客根目录下的`_config.yml`配置文件，这里面也很多比如标题、作者之类的信息需要你自己去填写。我主要说下发布这里，在最后找到`deploy:`，然后回车，空两个，输入下面的内容：\n```\n  repository: git@github.com:cloudy064/cloudy064.github.io.git\n  type: git\n  branch: master\n```\n\n这里就是告诉`hexo`，我写完了之后发布到哪个网址。\n\n这样`hexo`也配置完成了。\n\n## 发布博客\n打开你的命令行工具，然后跳转到博客的目录下去，依次输入下面的命令行:\n```cmd\nhexo g\nhexo d\n```\n\n然后再打开你的浏览器，输入你的博客地址，也就是仓库名称，我的是`cloudy064.github.io`，然后就可以看到`HelloWorld`这个熟悉的文章了。\n\n## 创建博文\n打开命令行工具，输入:\n```\nhexo n \"first blog\"\n```\n\n然后你就可以在`source\\_post\\`目录下找到`first blog.md`，你所要做的就是用`Markdown`语法创作你的博客，完成之后，按照上面发布博客的流程进行发布就可以了。\n\n## 其他问题\n\n### 添加图片\n这里我用的是`hexo`自定义的标签添加图片的。打开`_config.yml`文件，找到`post_asset_folder`选项，把后面的`false`改成`true`。然后以后你用`hexo n`创建博文的时候，在同级目录下会创建一个同名的目录，这个目录里面就是存放图片的，你在博文里面要做的就是利用下面的语句来插入图片：\n```\n{% asset_img 图片名字 图片描述 %}\n```\n\n当然这种方式插入图片有一个弊端就是不好移植，因为是`hexo`专有语法。我用这种方法纯属是因为方便管理，不需要人工去维护图片的存放位置。\n\n### 替换主题\n比如我这里用的就是`Next`主题，你需要做的就是用下面的命令把这个主题`clone`到本地：\n```cmd\ngit clone https://github.com/iissnan/hexo-theme-next\n```\n\n然后在博客目录下的`themes`文件夹中创建一个新的文件夹，我命名为`Next`，把刚刚`clone`下来的文件中的，除了`.git`和`.github`的文件拷贝到`Next`文件夹中。\n\n然后修改博客根目录下的`_config.yml`，找到`theme`一行，把后面的名字修改为`Next`即可。\n\n然后利用`hexo g`重新生成博客，再用`hexo d`发布上线，就可以看到实际效果了\n\n### 测试博客效果\n`hexo`提供了本地服务器的功能，你可以在用`hexo g`生成博客之后，通过输入`hexo s`，然后在浏览器输入`localhost:4000`来访问上线之后的效果。比如像上面替换主题这种大修改，这种本地测试的方式会很有用。","slug":"hexo-2016-06-20-build-blog-with-hexo","published":1,"updated":"2018-06-25T11:16:22.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjivnhtn200032gusk1yg1mmp","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>现在搭建一个博客所需要的成本越来越低了，相比起利用<code>WordPress</code>,甚至是自己开发博客框架，利用<code>hexo</code>+<code>github</code>的方式来进行搭建博客省时省力，并且以<code>Markdown</code>的方式进行书写，简化了书写时本就不需要费脑考虑的排版之类的问题，完全将博客内容从界面排版中剥离出来。当然这种方式也有不能够随心所欲控制界面的每个元素的限制，不过对于像我这种低端用户来说已经绰绰有余了。之前的<code>wordpress</code>搭建的博客，由于不满于它的写作方式，所以整整一年都没有动笔更新过。所以今天就教大家如何利用<code>hexo</code>和<code>github</code>搭建一个完全免费的博客。这里只介绍<code>windows</code>，至于<code>linux</code>和<code>macos</code>简单很多，这里我就忽略了。<br><a id=\"more\"></a></p>\n<h2 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><p>因为<code>hexo</code>是跑在<code>node.js</code>上的，所以说第一步要做的就是去<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">node.js官网</a>下载安装程序。安装完成后，在命令行输入<code>npm</code>，如果有输出的话就表示不需要配置了；如果提示找不到这个命令，就需要手动把<code>nodejs</code>的安装目录加入到环境变量<code>PATH</code>中。</p>\n<h2 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><p>在命令行输入<code>npm install -g hexo-cli</code>，将<code>hexo</code>安装到全局目录中，完成。</p>\n<h2 id=\"创建github仓库\"><a href=\"#创建github仓库\" class=\"headerlink\" title=\"创建github仓库\"></a>创建github仓库</h2><p>如果没有<code>github</code>账户先去注册一个，如果你被<code>Greate Fucking Wall</code>墙了，那我也没办法了。然后在主页点击<code>new repository</code>，然后将名字填写成你的<code>github名字.github.io</code>（一定是这个名字），然后点击<code>Create repository</code>就行了。如下图所示：<br><img src=\"/2016/06/20/hexo-2016-06-20-build-blog-with-hexo/newrepository.png\" title=\"创建仓库\"></p>\n<h2 id=\"安装并配置git\"><a href=\"#安装并配置git\" class=\"headerlink\" title=\"安装并配置git\"></a>安装并配置git</h2><p>去<a href=\"https://git-scm.com/download\" target=\"_blank\" rel=\"noopener\">git官网</a>下载<code>git</code>工具，所有安装选项都默认就行了。安装完成后，我们需要配置我们的<code>github</code>的用户名和密码：<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name cloudy064</span><br><span class=\"line\">git config --global user.email cloudy@gmail.com</span><br><span class=\"line\">git config --global user.password **********</span><br></pre></td></tr></table></figure></p>\n<p>做好了这些之后我们还需要一个<code>SSH key</code>，不明白的人自己去百度是干嘛的吧，这里不解释。在命令行继续输入：<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C\"cloudy064@gmail.com\"</span><br></pre></td></tr></table></figure></p>\n<p>然后一路回车，之后就可以在用户目录下（我这边是<code>C:\\Users\\cloudy</code>目录）找到<code>.ssh</code>文件夹，该文件夹下主要看一个文件<code>id_rsa.pub</code>，待会儿会用到。</p>\n<p>打开<code>github</code>页面，在右上角下拉菜单中点击<code>Setting</code>，进入到设置页面，然后点击<code>SSH and GPG keys</code>，看到下面这个界面：<br><img src=\"/2016/06/20/hexo-2016-06-20-build-blog-with-hexo/generatesshkey.png\" title=\"生成SSH key\"></p>\n<p>你需要点击右上角的<code>New SSH key</code>，然后在下面的输入框填写相关信息，<code>Title</code>随便填，只是一个标题而已，而<code>key</code>则需要把刚刚<code>id_rsa.pub</code>中的内容拷贝过来，然后点击<code>Add SSH key</code>即可。</p>\n<p>到目前为止<code>git</code>就配置完成了。</p>\n<h2 id=\"准备博客目录\"><a href=\"#准备博客目录\" class=\"headerlink\" title=\"准备博客目录\"></a>准备博客目录</h2><p>打开你的命令行工具，跳转到你想要存放博客文件的目录下，然后一次输入下面几个命令行：<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo --save</span><br><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure></p>\n<p>然后还需要安装<code>Hexo</code>插件，让他变得更完善，再依次输入下面的命令行：<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-index --save</span><br><span class=\"line\">npm install hexo-generator-archive --save</span><br><span class=\"line\">npm install hexo-generator-category --save</span><br><span class=\"line\">npm install hexo-generator-tag --save</span><br><span class=\"line\">npm install hexo-generator-feed@<span class=\"number\">1</span> --save</span><br><span class=\"line\">npm install hexo-generator-sitemap@<span class=\"number\">1</span> --save</span><br><span class=\"line\"></span><br><span class=\"line\">npm install hexo-server --save</span><br><span class=\"line\"></span><br><span class=\"line\">npm install hexo-deployer-git --save</span><br><span class=\"line\">npm install hexo-deployer-heroku --save</span><br><span class=\"line\">npm install hexo-deployer-rsync --save</span><br><span class=\"line\">npm install hexo-deployer-openshift --save</span><br><span class=\"line\"></span><br><span class=\"line\">npm install hexo-renderer-marked@<span class=\"number\">0</span>.<span class=\"number\">2</span> --save</span><br><span class=\"line\">npm install hexo-renderer-stylus@<span class=\"number\">0</span>.<span class=\"number\">2</span> --save</span><br></pre></td></tr></table></figure></p>\n<p>这样一个初步的<code>hexo</code>博客就搭建完成了。</p>\n<h2 id=\"配置hexo\"><a href=\"#配置hexo\" class=\"headerlink\" title=\"配置hexo\"></a>配置hexo</h2><p>但是我们的博客发布到哪里呢？打开你的<code>github</code>页面，进入到你刚刚创建的仓库中，点击右边的<code>Clone or download</code>，然后在下面弹出的对话框中，将输入框中的内容复制下来，等下有用。我这里的内容是<a href=\"mailto:`git@github.com\" target=\"_blank\" rel=\"noopener\">`git@github.com</a>:cloudy064/cloudy064.github.io.git`：<br><img src=\"/2016/06/20/hexo-2016-06-20-build-blog-with-hexo/getrepositoryaddress.png\" title=\"找到发布地址\"></p>\n<p>打开博客根目录下的<code>_config.yml</code>配置文件，这里面也很多比如标题、作者之类的信息需要你自己去填写。我主要说下发布这里，在最后找到<code>deploy:</code>，然后回车，空两个，输入下面的内容：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">repository</span>: git<span class=\"variable\">@github</span>.<span class=\"attribute\">com</span>:cloudy064/cloudy064.github.io.git</span><br><span class=\"line\"><span class=\"attribute\">type</span>: git</span><br><span class=\"line\"><span class=\"attribute\">branch</span>: master</span><br></pre></td></tr></table></figure></p>\n<p>这里就是告诉<code>hexo</code>，我写完了之后发布到哪个网址。</p>\n<p>这样<code>hexo</code>也配置完成了。</p>\n<h2 id=\"发布博客\"><a href=\"#发布博客\" class=\"headerlink\" title=\"发布博客\"></a>发布博客</h2><p>打开你的命令行工具，然后跳转到博客的目录下去，依次输入下面的命令行:<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure></p>\n<p>然后再打开你的浏览器，输入你的博客地址，也就是仓库名称，我的是<code>cloudy064.github.io</code>，然后就可以看到<code>HelloWorld</code>这个熟悉的文章了。</p>\n<h2 id=\"创建博文\"><a href=\"#创建博文\" class=\"headerlink\" title=\"创建博文\"></a>创建博文</h2><p>打开命令行工具，输入:<br><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"built_in\">n</span> <span class=\"string\">\"first blog\"</span></span><br></pre></td></tr></table></figure></p>\n<p>然后你就可以在<code>source\\_post\\</code>目录下找到<code>first blog.md</code>，你所要做的就是用<code>Markdown</code>语法创作你的博客，完成之后，按照上面发布博客的流程进行发布就可以了。</p>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><h3 id=\"添加图片\"><a href=\"#添加图片\" class=\"headerlink\" title=\"添加图片\"></a>添加图片</h3><p>这里我用的是<code>hexo</code>自定义的标签添加图片的。打开<code>_config.yml</code>文件，找到<code>post_asset_folder</code>选项，把后面的<code>false</code>改成<code>true</code>。然后以后你用<code>hexo n</code>创建博文的时候，在同级目录下会创建一个同名的目录，这个目录里面就是存放图片的，你在博文里面要做的就是利用下面的语句来插入图片：<br><figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\">asset_img</span> 图片名字 图片描述 %&#125;</span><span class=\"xml\"></span></span><br></pre></td></tr></table></figure></p>\n<p>当然这种方式插入图片有一个弊端就是不好移植，因为是<code>hexo</code>专有语法。我用这种方法纯属是因为方便管理，不需要人工去维护图片的存放位置。</p>\n<h3 id=\"替换主题\"><a href=\"#替换主题\" class=\"headerlink\" title=\"替换主题\"></a>替换主题</h3><p>比如我这里用的就是<code>Next</code>主题，你需要做的就是用下面的命令把这个主题<code>clone</code>到本地：<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/iissnan/hexo-theme-next</span><br></pre></td></tr></table></figure></p>\n<p>然后在博客目录下的<code>themes</code>文件夹中创建一个新的文件夹，我命名为<code>Next</code>，把刚刚<code>clone</code>下来的文件中的，除了<code>.git</code>和<code>.github</code>的文件拷贝到<code>Next</code>文件夹中。</p>\n<p>然后修改博客根目录下的<code>_config.yml</code>，找到<code>theme</code>一行，把后面的名字修改为<code>Next</code>即可。</p>\n<p>然后利用<code>hexo g</code>重新生成博客，再用<code>hexo d</code>发布上线，就可以看到实际效果了</p>\n<h3 id=\"测试博客效果\"><a href=\"#测试博客效果\" class=\"headerlink\" title=\"测试博客效果\"></a>测试博客效果</h3><p><code>hexo</code>提供了本地服务器的功能，你可以在用<code>hexo g</code>生成博客之后，通过输入<code>hexo s</code>，然后在浏览器输入<code>localhost:4000</code>来访问上线之后的效果。比如像上面替换主题这种大修改，这种本地测试的方式会很有用。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>现在搭建一个博客所需要的成本越来越低了，相比起利用<code>WordPress</code>,甚至是自己开发博客框架，利用<code>hexo</code>+<code>github</code>的方式来进行搭建博客省时省力，并且以<code>Markdown</code>的方式进行书写，简化了书写时本就不需要费脑考虑的排版之类的问题，完全将博客内容从界面排版中剥离出来。当然这种方式也有不能够随心所欲控制界面的每个元素的限制，不过对于像我这种低端用户来说已经绰绰有余了。之前的<code>wordpress</code>搭建的博客，由于不满于它的写作方式，所以整整一年都没有动笔更新过。所以今天就教大家如何利用<code>hexo</code>和<code>github</code>搭建一个完全免费的博客。这里只介绍<code>windows</code>，至于<code>linux</code>和<code>macos</code>简单很多，这里我就忽略了。<br>","more":"</p>\n<h2 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><p>因为<code>hexo</code>是跑在<code>node.js</code>上的，所以说第一步要做的就是去<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">node.js官网</a>下载安装程序。安装完成后，在命令行输入<code>npm</code>，如果有输出的话就表示不需要配置了；如果提示找不到这个命令，就需要手动把<code>nodejs</code>的安装目录加入到环境变量<code>PATH</code>中。</p>\n<h2 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><p>在命令行输入<code>npm install -g hexo-cli</code>，将<code>hexo</code>安装到全局目录中，完成。</p>\n<h2 id=\"创建github仓库\"><a href=\"#创建github仓库\" class=\"headerlink\" title=\"创建github仓库\"></a>创建github仓库</h2><p>如果没有<code>github</code>账户先去注册一个，如果你被<code>Greate Fucking Wall</code>墙了，那我也没办法了。然后在主页点击<code>new repository</code>，然后将名字填写成你的<code>github名字.github.io</code>（一定是这个名字），然后点击<code>Create repository</code>就行了。如下图所示：<br><img src=\"/2016/06/20/hexo-2016-06-20-build-blog-with-hexo/newrepository.png\" title=\"创建仓库\"></p>\n<h2 id=\"安装并配置git\"><a href=\"#安装并配置git\" class=\"headerlink\" title=\"安装并配置git\"></a>安装并配置git</h2><p>去<a href=\"https://git-scm.com/download\" target=\"_blank\" rel=\"noopener\">git官网</a>下载<code>git</code>工具，所有安装选项都默认就行了。安装完成后，我们需要配置我们的<code>github</code>的用户名和密码：<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name cloudy064</span><br><span class=\"line\">git config --global user.email cloudy@gmail.com</span><br><span class=\"line\">git config --global user.password **********</span><br></pre></td></tr></table></figure></p>\n<p>做好了这些之后我们还需要一个<code>SSH key</code>，不明白的人自己去百度是干嘛的吧，这里不解释。在命令行继续输入：<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C\"cloudy064@gmail.com\"</span><br></pre></td></tr></table></figure></p>\n<p>然后一路回车，之后就可以在用户目录下（我这边是<code>C:\\Users\\cloudy</code>目录）找到<code>.ssh</code>文件夹，该文件夹下主要看一个文件<code>id_rsa.pub</code>，待会儿会用到。</p>\n<p>打开<code>github</code>页面，在右上角下拉菜单中点击<code>Setting</code>，进入到设置页面，然后点击<code>SSH and GPG keys</code>，看到下面这个界面：<br><img src=\"/2016/06/20/hexo-2016-06-20-build-blog-with-hexo/generatesshkey.png\" title=\"生成SSH key\"></p>\n<p>你需要点击右上角的<code>New SSH key</code>，然后在下面的输入框填写相关信息，<code>Title</code>随便填，只是一个标题而已，而<code>key</code>则需要把刚刚<code>id_rsa.pub</code>中的内容拷贝过来，然后点击<code>Add SSH key</code>即可。</p>\n<p>到目前为止<code>git</code>就配置完成了。</p>\n<h2 id=\"准备博客目录\"><a href=\"#准备博客目录\" class=\"headerlink\" title=\"准备博客目录\"></a>准备博客目录</h2><p>打开你的命令行工具，跳转到你想要存放博客文件的目录下，然后一次输入下面几个命令行：<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo --save</span><br><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure></p>\n<p>然后还需要安装<code>Hexo</code>插件，让他变得更完善，再依次输入下面的命令行：<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-index --save</span><br><span class=\"line\">npm install hexo-generator-archive --save</span><br><span class=\"line\">npm install hexo-generator-category --save</span><br><span class=\"line\">npm install hexo-generator-tag --save</span><br><span class=\"line\">npm install hexo-generator-feed@<span class=\"number\">1</span> --save</span><br><span class=\"line\">npm install hexo-generator-sitemap@<span class=\"number\">1</span> --save</span><br><span class=\"line\"></span><br><span class=\"line\">npm install hexo-server --save</span><br><span class=\"line\"></span><br><span class=\"line\">npm install hexo-deployer-git --save</span><br><span class=\"line\">npm install hexo-deployer-heroku --save</span><br><span class=\"line\">npm install hexo-deployer-rsync --save</span><br><span class=\"line\">npm install hexo-deployer-openshift --save</span><br><span class=\"line\"></span><br><span class=\"line\">npm install hexo-renderer-marked@<span class=\"number\">0</span>.<span class=\"number\">2</span> --save</span><br><span class=\"line\">npm install hexo-renderer-stylus@<span class=\"number\">0</span>.<span class=\"number\">2</span> --save</span><br></pre></td></tr></table></figure></p>\n<p>这样一个初步的<code>hexo</code>博客就搭建完成了。</p>\n<h2 id=\"配置hexo\"><a href=\"#配置hexo\" class=\"headerlink\" title=\"配置hexo\"></a>配置hexo</h2><p>但是我们的博客发布到哪里呢？打开你的<code>github</code>页面，进入到你刚刚创建的仓库中，点击右边的<code>Clone or download</code>，然后在下面弹出的对话框中，将输入框中的内容复制下来，等下有用。我这里的内容是<a href=\"mailto:`git@github.com\" target=\"_blank\" rel=\"noopener\">`git@github.com</a>:cloudy064/cloudy064.github.io.git`：<br><img src=\"/2016/06/20/hexo-2016-06-20-build-blog-with-hexo/getrepositoryaddress.png\" title=\"找到发布地址\"></p>\n<p>打开博客根目录下的<code>_config.yml</code>配置文件，这里面也很多比如标题、作者之类的信息需要你自己去填写。我主要说下发布这里，在最后找到<code>deploy:</code>，然后回车，空两个，输入下面的内容：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">repository</span>: git<span class=\"variable\">@github</span>.<span class=\"attribute\">com</span>:cloudy064/cloudy064.github.io.git</span><br><span class=\"line\"><span class=\"attribute\">type</span>: git</span><br><span class=\"line\"><span class=\"attribute\">branch</span>: master</span><br></pre></td></tr></table></figure></p>\n<p>这里就是告诉<code>hexo</code>，我写完了之后发布到哪个网址。</p>\n<p>这样<code>hexo</code>也配置完成了。</p>\n<h2 id=\"发布博客\"><a href=\"#发布博客\" class=\"headerlink\" title=\"发布博客\"></a>发布博客</h2><p>打开你的命令行工具，然后跳转到博客的目录下去，依次输入下面的命令行:<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure></p>\n<p>然后再打开你的浏览器，输入你的博客地址，也就是仓库名称，我的是<code>cloudy064.github.io</code>，然后就可以看到<code>HelloWorld</code>这个熟悉的文章了。</p>\n<h2 id=\"创建博文\"><a href=\"#创建博文\" class=\"headerlink\" title=\"创建博文\"></a>创建博文</h2><p>打开命令行工具，输入:<br><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"built_in\">n</span> <span class=\"string\">\"first blog\"</span></span><br></pre></td></tr></table></figure></p>\n<p>然后你就可以在<code>source\\_post\\</code>目录下找到<code>first blog.md</code>，你所要做的就是用<code>Markdown</code>语法创作你的博客，完成之后，按照上面发布博客的流程进行发布就可以了。</p>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><h3 id=\"添加图片\"><a href=\"#添加图片\" class=\"headerlink\" title=\"添加图片\"></a>添加图片</h3><p>这里我用的是<code>hexo</code>自定义的标签添加图片的。打开<code>_config.yml</code>文件，找到<code>post_asset_folder</code>选项，把后面的<code>false</code>改成<code>true</code>。然后以后你用<code>hexo n</code>创建博文的时候，在同级目录下会创建一个同名的目录，这个目录里面就是存放图片的，你在博文里面要做的就是利用下面的语句来插入图片：<br><figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\">asset_img</span> 图片名字 图片描述 %&#125;</span><span class=\"xml\"></span></span><br></pre></td></tr></table></figure></p>\n<p>当然这种方式插入图片有一个弊端就是不好移植，因为是<code>hexo</code>专有语法。我用这种方法纯属是因为方便管理，不需要人工去维护图片的存放位置。</p>\n<h3 id=\"替换主题\"><a href=\"#替换主题\" class=\"headerlink\" title=\"替换主题\"></a>替换主题</h3><p>比如我这里用的就是<code>Next</code>主题，你需要做的就是用下面的命令把这个主题<code>clone</code>到本地：<br><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/iissnan/hexo-theme-next</span><br></pre></td></tr></table></figure></p>\n<p>然后在博客目录下的<code>themes</code>文件夹中创建一个新的文件夹，我命名为<code>Next</code>，把刚刚<code>clone</code>下来的文件中的，除了<code>.git</code>和<code>.github</code>的文件拷贝到<code>Next</code>文件夹中。</p>\n<p>然后修改博客根目录下的<code>_config.yml</code>，找到<code>theme</code>一行，把后面的名字修改为<code>Next</code>即可。</p>\n<p>然后利用<code>hexo g</code>重新生成博客，再用<code>hexo d</code>发布上线，就可以看到实际效果了</p>\n<h3 id=\"测试博客效果\"><a href=\"#测试博客效果\" class=\"headerlink\" title=\"测试博客效果\"></a>测试博客效果</h3><p><code>hexo</code>提供了本地服务器的功能，你可以在用<code>hexo g</code>生成博客之后，通过输入<code>hexo s</code>，然后在浏览器输入<code>localhost:4000</code>来访问上线之后的效果。比如像上面替换主题这种大修改，这种本地测试的方式会很有用。</p>"},{"title":"云064带你刷leetcode(1)","date":"2016-10-18T10:21:29.000Z","_content":"\n## 1. 题目描述\n[Two Sum](https://leetcode.com/problems/two-sum/)\n输入：数组nums，数字target\n输出：两个下标x和y，使得数组a中这两个下标的数的和为t (a[x]+a[y]==t)\n注意：题目中说明了，假设数组中只有一组下标符合条件\n\n## 2. 示例\n> 输入 nums=[2,7,11,15], target=9\n> 因为 nums[0] + nums[1] = 2 + 7 = 9\n> 所以 输出 [0,1]\n\n<!--more-->\n\n---\n\n## 3. 题目解答\n### 3.1 排序\n#### 3.1.1 思路\n算法思路描述如下：\n1. 对数组有大到下进行排序（题目并未指出输入的数组是否为已排序）\n2. 将头部(`a[i]`)与尾部(`a[j]`)的和`sum`作为初始值\n3. 如果`sum`大于`target`，说明值取大了，则将尾部指针向前移动一位(`j -= 1`)，继续执行第2步，否则执行第4步\n4. 如果`sum`小于`target`，说明值取小了，则将头部指针向后移动一位(`i += 1`)，继续执行第2步，否则执行第5步\n5. 找到了`i`和`j`，直接返回\n\n但是这里有一个问题，题目要求返回的是原数组中的下标，如果我们直接给他排序了，下标就丢失了，所以我们需要另外创建一个结构体保存对应数字的下标，或者也可以用一个`map`来存储数字对应的下表\n\n#### 3.1.2 算法复杂度\n时间复杂度： `O(nlogn)`\n空间复杂度： `O(n)`\n\n#### 3.1.3 代码实现\n```cpp\nstruct Num {\n    int num;    //原来的数\n    int index;  //原来的下标\n\n    bool operator<(const Num& rhs) {\n        return num < rhs.num;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<Num> numsWithIndex(nums.size());\n\n        // 初始化，保存原来的数和下标\n        for (int i = 0; i < nums.size(); ++i) {\n            numsWithIndex[i].num = nums[i];\n            numsWithIndex[i].index = i;\n        }\n\n        sort(numsWithIndex.begin(), numsWithIndex.end());\n\n        int smaller = 0;\n        int larger = numsWithIndex.size() - 1;\n        while (true) {\n            int sum = numsWithIndex[smaller].num + numsWithIndex[larger].num;\n            if (sum == target) {\n                break;\n            }\n\n            if (sum > target) {\n                --larger;\n            }\n            else {\n                ++smaller;\n            }\n        }\n\n        int indexa = numsWithIndex[smaller].index;\n        int indexb = numsWithIndex[larger].index;\n\n        // 这里还需要注意的就是返回要求从小到达的顺序\n        vector<int> result;\n        if (indexa > indexb) {\n            result.push_back(indexb);\n            result.push_back(indexa);\n        }\n        else {\n            result.push_back(indexa);\n            result.push_back(indexb);\n        }\n        return result;\n    }\n};\n```\n\n---\n\n### 3.2 哈希表\n#### 3.2.1 思路\n算法思路描述如下：\n1. 遍历一次数组，以具体的数字作为`key`，以下表作为`value`，记录到`map`中\n2. 在遍历一次数组，针对每一个数字`a`，计算出`target-a`，在`map`中查找`target-a`是否存在，如果存在则直接返回`a`的下标和`map[target-a]`，否则重复执行2\n\n#### 3.2.2 算法复杂度\n时间复杂度： `O(n)`\n空间复杂度： `O(n)`\n\n#### 3.2.3 代码实现\n```cpp\nclass Solution\n{\npublic:\n\tvector<int> twoSum(vector<int>& nums, int target) {\n\t\tvector<int> result;\n\t\tunordered_map<int, int> record;\n\t\tfor (int i = 0; i < nums.size(); ++i)\n\t\t{\n\t\t\tint to_find = target - nums[i];\n\t\t\tunordered_map<int, int>::iterator it = record.find(to_find);\n\t\t\tif (it != record.end())\n\t\t\t{\n\t\t\t\tresult.push_back(it->second);\n\t\t\t\tresult.push_back(i);\n\t\t\t\tbreak;\n\t\t\t} \n\t\t\telse\n\t\t\t{\n\t\t\t\trecord.insert(make_pair(nums[i], i));\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n```\n","source":"_posts/leetcode/2016-10-18-leetcode-chapter1.md","raw":"---\ntitle: 云064带你刷leetcode(1)\ndate: 2016-10-18 18:21:29\ncategories: leetcode\ntags: [algorithm,c++,leetcode]\n---\n\n## 1. 题目描述\n[Two Sum](https://leetcode.com/problems/two-sum/)\n输入：数组nums，数字target\n输出：两个下标x和y，使得数组a中这两个下标的数的和为t (a[x]+a[y]==t)\n注意：题目中说明了，假设数组中只有一组下标符合条件\n\n## 2. 示例\n> 输入 nums=[2,7,11,15], target=9\n> 因为 nums[0] + nums[1] = 2 + 7 = 9\n> 所以 输出 [0,1]\n\n<!--more-->\n\n---\n\n## 3. 题目解答\n### 3.1 排序\n#### 3.1.1 思路\n算法思路描述如下：\n1. 对数组有大到下进行排序（题目并未指出输入的数组是否为已排序）\n2. 将头部(`a[i]`)与尾部(`a[j]`)的和`sum`作为初始值\n3. 如果`sum`大于`target`，说明值取大了，则将尾部指针向前移动一位(`j -= 1`)，继续执行第2步，否则执行第4步\n4. 如果`sum`小于`target`，说明值取小了，则将头部指针向后移动一位(`i += 1`)，继续执行第2步，否则执行第5步\n5. 找到了`i`和`j`，直接返回\n\n但是这里有一个问题，题目要求返回的是原数组中的下标，如果我们直接给他排序了，下标就丢失了，所以我们需要另外创建一个结构体保存对应数字的下标，或者也可以用一个`map`来存储数字对应的下表\n\n#### 3.1.2 算法复杂度\n时间复杂度： `O(nlogn)`\n空间复杂度： `O(n)`\n\n#### 3.1.3 代码实现\n```cpp\nstruct Num {\n    int num;    //原来的数\n    int index;  //原来的下标\n\n    bool operator<(const Num& rhs) {\n        return num < rhs.num;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<Num> numsWithIndex(nums.size());\n\n        // 初始化，保存原来的数和下标\n        for (int i = 0; i < nums.size(); ++i) {\n            numsWithIndex[i].num = nums[i];\n            numsWithIndex[i].index = i;\n        }\n\n        sort(numsWithIndex.begin(), numsWithIndex.end());\n\n        int smaller = 0;\n        int larger = numsWithIndex.size() - 1;\n        while (true) {\n            int sum = numsWithIndex[smaller].num + numsWithIndex[larger].num;\n            if (sum == target) {\n                break;\n            }\n\n            if (sum > target) {\n                --larger;\n            }\n            else {\n                ++smaller;\n            }\n        }\n\n        int indexa = numsWithIndex[smaller].index;\n        int indexb = numsWithIndex[larger].index;\n\n        // 这里还需要注意的就是返回要求从小到达的顺序\n        vector<int> result;\n        if (indexa > indexb) {\n            result.push_back(indexb);\n            result.push_back(indexa);\n        }\n        else {\n            result.push_back(indexa);\n            result.push_back(indexb);\n        }\n        return result;\n    }\n};\n```\n\n---\n\n### 3.2 哈希表\n#### 3.2.1 思路\n算法思路描述如下：\n1. 遍历一次数组，以具体的数字作为`key`，以下表作为`value`，记录到`map`中\n2. 在遍历一次数组，针对每一个数字`a`，计算出`target-a`，在`map`中查找`target-a`是否存在，如果存在则直接返回`a`的下标和`map[target-a]`，否则重复执行2\n\n#### 3.2.2 算法复杂度\n时间复杂度： `O(n)`\n空间复杂度： `O(n)`\n\n#### 3.2.3 代码实现\n```cpp\nclass Solution\n{\npublic:\n\tvector<int> twoSum(vector<int>& nums, int target) {\n\t\tvector<int> result;\n\t\tunordered_map<int, int> record;\n\t\tfor (int i = 0; i < nums.size(); ++i)\n\t\t{\n\t\t\tint to_find = target - nums[i];\n\t\t\tunordered_map<int, int>::iterator it = record.find(to_find);\n\t\t\tif (it != record.end())\n\t\t\t{\n\t\t\t\tresult.push_back(it->second);\n\t\t\t\tresult.push_back(i);\n\t\t\t\tbreak;\n\t\t\t} \n\t\t\telse\n\t\t\t{\n\t\t\t\trecord.insert(make_pair(nums[i], i));\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n```\n","slug":"leetcode-2016-10-18-leetcode-chapter1","published":1,"updated":"2018-06-26T12:07:07.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjivnhtn600062gusm3dao6ax","content":"<h2 id=\"1-题目描述\"><a href=\"#1-题目描述\" class=\"headerlink\" title=\"1. 题目描述\"></a>1. 题目描述</h2><p><a href=\"https://leetcode.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">Two Sum</a><br>输入：数组nums，数字target<br>输出：两个下标x和y，使得数组a中这两个下标的数的和为t (a[x]+a[y]==t)<br>注意：题目中说明了，假设数组中只有一组下标符合条件</p>\n<h2 id=\"2-示例\"><a href=\"#2-示例\" class=\"headerlink\" title=\"2. 示例\"></a>2. 示例</h2><blockquote>\n<p>输入 nums=[2,7,11,15], target=9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以 输出 [0,1]</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"3-题目解答\"><a href=\"#3-题目解答\" class=\"headerlink\" title=\"3. 题目解答\"></a>3. 题目解答</h2><h3 id=\"3-1-排序\"><a href=\"#3-1-排序\" class=\"headerlink\" title=\"3.1 排序\"></a>3.1 排序</h3><h4 id=\"3-1-1-思路\"><a href=\"#3-1-1-思路\" class=\"headerlink\" title=\"3.1.1 思路\"></a>3.1.1 思路</h4><p>算法思路描述如下：</p>\n<ol>\n<li>对数组有大到下进行排序（题目并未指出输入的数组是否为已排序）</li>\n<li>将头部(<code>a[i]</code>)与尾部(<code>a[j]</code>)的和<code>sum</code>作为初始值</li>\n<li>如果<code>sum</code>大于<code>target</code>，说明值取大了，则将尾部指针向前移动一位(<code>j -= 1</code>)，继续执行第2步，否则执行第4步</li>\n<li>如果<code>sum</code>小于<code>target</code>，说明值取小了，则将头部指针向后移动一位(<code>i += 1</code>)，继续执行第2步，否则执行第5步</li>\n<li>找到了<code>i</code>和<code>j</code>，直接返回</li>\n</ol>\n<p>但是这里有一个问题，题目要求返回的是原数组中的下标，如果我们直接给他排序了，下标就丢失了，所以我们需要另外创建一个结构体保存对应数字的下标，或者也可以用一个<code>map</code>来存储数字对应的下表</p>\n<h4 id=\"3-1-2-算法复杂度\"><a href=\"#3-1-2-算法复杂度\" class=\"headerlink\" title=\"3.1.2 算法复杂度\"></a>3.1.2 算法复杂度</h4><p>时间复杂度： <code>O(nlogn)</code><br>空间复杂度： <code>O(n)</code></p>\n<h4 id=\"3-1-3-代码实现\"><a href=\"#3-1-3-代码实现\" class=\"headerlink\" title=\"3.1.3 代码实现\"></a>3.1.3 代码实现</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Num</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;    <span class=\"comment\">//原来的数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;  <span class=\"comment\">//原来的下标</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Num&amp; rhs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num &lt; rhs.num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;Num&gt; numsWithIndex(nums.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化，保存原来的数和下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            numsWithIndex[i].num = nums[i];</span><br><span class=\"line\">            numsWithIndex[i].index = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sort(numsWithIndex.begin(), numsWithIndex.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> smaller = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> larger = numsWithIndex.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = numsWithIndex[smaller].num + numsWithIndex[larger].num;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt; target) &#123;</span><br><span class=\"line\">                --larger;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ++smaller;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> indexa = numsWithIndex[smaller].index;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> indexb = numsWithIndex[larger].index;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这里还需要注意的就是返回要求从小到达的顺序</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (indexa &gt; indexb) &#123;</span><br><span class=\"line\">            result.push_back(indexb);</span><br><span class=\"line\">            result.push_back(indexa);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result.push_back(indexa);</span><br><span class=\"line\">            result.push_back(indexb);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3-2-哈希表\"><a href=\"#3-2-哈希表\" class=\"headerlink\" title=\"3.2 哈希表\"></a>3.2 哈希表</h3><h4 id=\"3-2-1-思路\"><a href=\"#3-2-1-思路\" class=\"headerlink\" title=\"3.2.1 思路\"></a>3.2.1 思路</h4><p>算法思路描述如下：</p>\n<ol>\n<li>遍历一次数组，以具体的数字作为<code>key</code>，以下表作为<code>value</code>，记录到<code>map</code>中</li>\n<li>在遍历一次数组，针对每一个数字<code>a</code>，计算出<code>target-a</code>，在<code>map</code>中查找<code>target-a</code>是否存在，如果存在则直接返回<code>a</code>的下标和<code>map[target-a]</code>，否则重复执行2</li>\n</ol>\n<h4 id=\"3-2-2-算法复杂度\"><a href=\"#3-2-2-算法复杂度\" class=\"headerlink\" title=\"3.2.2 算法复杂度\"></a>3.2.2 算法复杂度</h4><p>时间复杂度： <code>O(n)</code><br>空间复杂度： <code>O(n)</code></p>\n<h4 id=\"3-2-3-代码实现\"><a href=\"#3-2-3-代码实现\" class=\"headerlink\" title=\"3.2.3 代码实现\"></a>3.2.3 代码实现</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">\t\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; record;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> to_find = target - nums[i];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;::iterator it = record.find(to_find);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (it != record.end())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tresult.push_back(it-&gt;second);</span><br><span class=\"line\">\t\t\t\tresult.push_back(i);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\trecord.insert(make_pair(nums[i], i));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-题目描述\"><a href=\"#1-题目描述\" class=\"headerlink\" title=\"1. 题目描述\"></a>1. 题目描述</h2><p><a href=\"https://leetcode.com/problems/two-sum/\" target=\"_blank\" rel=\"noopener\">Two Sum</a><br>输入：数组nums，数字target<br>输出：两个下标x和y，使得数组a中这两个下标的数的和为t (a[x]+a[y]==t)<br>注意：题目中说明了，假设数组中只有一组下标符合条件</p>\n<h2 id=\"2-示例\"><a href=\"#2-示例\" class=\"headerlink\" title=\"2. 示例\"></a>2. 示例</h2><blockquote>\n<p>输入 nums=[2,7,11,15], target=9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以 输出 [0,1]</p>\n</blockquote>","more":"<hr>\n<h2 id=\"3-题目解答\"><a href=\"#3-题目解答\" class=\"headerlink\" title=\"3. 题目解答\"></a>3. 题目解答</h2><h3 id=\"3-1-排序\"><a href=\"#3-1-排序\" class=\"headerlink\" title=\"3.1 排序\"></a>3.1 排序</h3><h4 id=\"3-1-1-思路\"><a href=\"#3-1-1-思路\" class=\"headerlink\" title=\"3.1.1 思路\"></a>3.1.1 思路</h4><p>算法思路描述如下：</p>\n<ol>\n<li>对数组有大到下进行排序（题目并未指出输入的数组是否为已排序）</li>\n<li>将头部(<code>a[i]</code>)与尾部(<code>a[j]</code>)的和<code>sum</code>作为初始值</li>\n<li>如果<code>sum</code>大于<code>target</code>，说明值取大了，则将尾部指针向前移动一位(<code>j -= 1</code>)，继续执行第2步，否则执行第4步</li>\n<li>如果<code>sum</code>小于<code>target</code>，说明值取小了，则将头部指针向后移动一位(<code>i += 1</code>)，继续执行第2步，否则执行第5步</li>\n<li>找到了<code>i</code>和<code>j</code>，直接返回</li>\n</ol>\n<p>但是这里有一个问题，题目要求返回的是原数组中的下标，如果我们直接给他排序了，下标就丢失了，所以我们需要另外创建一个结构体保存对应数字的下标，或者也可以用一个<code>map</code>来存储数字对应的下表</p>\n<h4 id=\"3-1-2-算法复杂度\"><a href=\"#3-1-2-算法复杂度\" class=\"headerlink\" title=\"3.1.2 算法复杂度\"></a>3.1.2 算法复杂度</h4><p>时间复杂度： <code>O(nlogn)</code><br>空间复杂度： <code>O(n)</code></p>\n<h4 id=\"3-1-3-代码实现\"><a href=\"#3-1-3-代码实现\" class=\"headerlink\" title=\"3.1.3 代码实现\"></a>3.1.3 代码实现</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Num</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;    <span class=\"comment\">//原来的数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;  <span class=\"comment\">//原来的下标</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Num&amp; rhs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num &lt; rhs.num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;Num&gt; numsWithIndex(nums.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化，保存原来的数和下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class=\"line\">            numsWithIndex[i].num = nums[i];</span><br><span class=\"line\">            numsWithIndex[i].index = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sort(numsWithIndex.begin(), numsWithIndex.end());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> smaller = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> larger = numsWithIndex.size() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = numsWithIndex[smaller].num + numsWithIndex[larger].num;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt; target) &#123;</span><br><span class=\"line\">                --larger;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ++smaller;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> indexa = numsWithIndex[smaller].index;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> indexb = numsWithIndex[larger].index;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这里还需要注意的就是返回要求从小到达的顺序</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (indexa &gt; indexb) &#123;</span><br><span class=\"line\">            result.push_back(indexb);</span><br><span class=\"line\">            result.push_back(indexa);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result.push_back(indexa);</span><br><span class=\"line\">            result.push_back(indexb);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3-2-哈希表\"><a href=\"#3-2-哈希表\" class=\"headerlink\" title=\"3.2 哈希表\"></a>3.2 哈希表</h3><h4 id=\"3-2-1-思路\"><a href=\"#3-2-1-思路\" class=\"headerlink\" title=\"3.2.1 思路\"></a>3.2.1 思路</h4><p>算法思路描述如下：</p>\n<ol>\n<li>遍历一次数组，以具体的数字作为<code>key</code>，以下表作为<code>value</code>，记录到<code>map</code>中</li>\n<li>在遍历一次数组，针对每一个数字<code>a</code>，计算出<code>target-a</code>，在<code>map</code>中查找<code>target-a</code>是否存在，如果存在则直接返回<code>a</code>的下标和<code>map[target-a]</code>，否则重复执行2</li>\n</ol>\n<h4 id=\"3-2-2-算法复杂度\"><a href=\"#3-2-2-算法复杂度\" class=\"headerlink\" title=\"3.2.2 算法复杂度\"></a>3.2.2 算法复杂度</h4><p>时间复杂度： <code>O(n)</code><br>空间复杂度： <code>O(n)</code></p>\n<h4 id=\"3-2-3-代码实现\"><a href=\"#3-2-3-代码实现\" class=\"headerlink\" title=\"3.2.3 代码实现\"></a>3.2.3 代码实现</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">\t\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; record;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); ++i)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> to_find = target - nums[i];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;::iterator it = record.find(to_find);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (it != record.end())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tresult.push_back(it-&gt;second);</span><br><span class=\"line\">\t\t\t\tresult.push_back(i);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\trecord.insert(make_pair(nums[i], i));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"云064带你刷leetcode(2)","date":"2018-06-26T10:21:29.000Z","_content":"\n## 1. 题目描述\n[两数相加](https://leetcode-cn.com/problems/add-two-numbers/description/)\n给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。\n\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n## 2. 示例\n> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n> 输出：7 -> 0 -> 8\n> 原因：342 + 465 = 807\n\n<!--more-->\n\n---\n\n## 3. 题目解答\n### 3.1 思路\n本题比较简单，单纯模拟纸上计算两个数字相加即可，只需要遵循十进制加法，然后注意一下进位和边界问题就行了。思路描述如下：\n\n1. 如果`l1`或者`l2`为空时，返回另外一个链表即可\n2. 定义`carry`变量，用于记录前一位加法的进位，初始化为0\n3. 遍历两个链表`l1`和`l2`，得到`node1`和`node2`\n4. 如果`node1`和`node2`都为空，并且`carry`为0，则计算结束，返回结果链表\n5. 如果节点`node`为`nullptr`，则记录值为`0`，否则记录值为`node->val`。可以得到`node1`和`node2`对应的两个值`val1`和`val2`\n6. 计算`val1+val2+carry`的结果`result`\n7. 如果大于`10`，则取对`10`的余数`mod`，新增一个`val`为`mod`的节点添加到结果链表中；对`10`的商记录到`carry`中。继续执行第3步\n8. 如果小于`10`且大于`0`，则直接新增一个`val`为`result`的节点添加到结果链表中；`carry`赋值为0。继续执行第3步\n\n### 3.2 算法复杂度\n时间复杂度： `O(m+n)`\n空间复杂度： `O(m+n)`\n\n### 3.3 代码实现\n```cpp\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        if (l1 == nullptr) return l2;\n        if (l2 == nullptr) return l1;\n\n        int carry = 0;\n        ListNode* result = nullptr;\n        ListNode* prev = nullptr;\n\n        ListNode* node1 = l1;\n        ListNode* node2 = l2;\n        while (node1 != nullptr || node2 != nullptr || carry != 0) {\n            int val1 = (node1 == nullptr ? 0 : node1->val);\n            int val2 = (node2 == nullptr ? 0 : node2->val);\n            int sum = val1 + val2 + carry;\n            int val = sum % 10;\n            carry = sum / 10;\n            ListNode* node = new ListNode(val);\n            if (prev == nullptr) {\n                result = node;\n            } else {\n                prev->next = node;\n            }\n\n            prev = node;\n            node1 = (node1 != nullptr ? node1->next : nullptr);\n            node2 = (node1 != nullptr ? node2->next : nullptr);\n        }\n\n        return result;\n    }\n};\n```\n","source":"_posts/leetcode/2018-06-26-leetcode-chapter2.md","raw":"---\ntitle: 云064带你刷leetcode(2)\ndate: 2018-06-26 18:21:29\ncategories: leetcode\ntags: [algorithm,c++,leetcode]\n---\n\n## 1. 题目描述\n[两数相加](https://leetcode-cn.com/problems/add-two-numbers/description/)\n给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。\n\n你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n\n## 2. 示例\n> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n> 输出：7 -> 0 -> 8\n> 原因：342 + 465 = 807\n\n<!--more-->\n\n---\n\n## 3. 题目解答\n### 3.1 思路\n本题比较简单，单纯模拟纸上计算两个数字相加即可，只需要遵循十进制加法，然后注意一下进位和边界问题就行了。思路描述如下：\n\n1. 如果`l1`或者`l2`为空时，返回另外一个链表即可\n2. 定义`carry`变量，用于记录前一位加法的进位，初始化为0\n3. 遍历两个链表`l1`和`l2`，得到`node1`和`node2`\n4. 如果`node1`和`node2`都为空，并且`carry`为0，则计算结束，返回结果链表\n5. 如果节点`node`为`nullptr`，则记录值为`0`，否则记录值为`node->val`。可以得到`node1`和`node2`对应的两个值`val1`和`val2`\n6. 计算`val1+val2+carry`的结果`result`\n7. 如果大于`10`，则取对`10`的余数`mod`，新增一个`val`为`mod`的节点添加到结果链表中；对`10`的商记录到`carry`中。继续执行第3步\n8. 如果小于`10`且大于`0`，则直接新增一个`val`为`result`的节点添加到结果链表中；`carry`赋值为0。继续执行第3步\n\n### 3.2 算法复杂度\n时间复杂度： `O(m+n)`\n空间复杂度： `O(m+n)`\n\n### 3.3 代码实现\n```cpp\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        if (l1 == nullptr) return l2;\n        if (l2 == nullptr) return l1;\n\n        int carry = 0;\n        ListNode* result = nullptr;\n        ListNode* prev = nullptr;\n\n        ListNode* node1 = l1;\n        ListNode* node2 = l2;\n        while (node1 != nullptr || node2 != nullptr || carry != 0) {\n            int val1 = (node1 == nullptr ? 0 : node1->val);\n            int val2 = (node2 == nullptr ? 0 : node2->val);\n            int sum = val1 + val2 + carry;\n            int val = sum % 10;\n            carry = sum / 10;\n            ListNode* node = new ListNode(val);\n            if (prev == nullptr) {\n                result = node;\n            } else {\n                prev->next = node;\n            }\n\n            prev = node;\n            node1 = (node1 != nullptr ? node1->next : nullptr);\n            node2 = (node1 != nullptr ? node2->next : nullptr);\n        }\n\n        return result;\n    }\n};\n```\n","slug":"leetcode-2018-06-26-leetcode-chapter2","published":1,"updated":"2018-06-26T12:05:03.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjivnhtn800072gustgla2oc0","content":"<h2 id=\"1-题目描述\"><a href=\"#1-题目描述\" class=\"headerlink\" title=\"1. 题目描述\"></a>1. 题目描述</h2><p><a href=\"https://leetcode-cn.com/problems/add-two-numbers/description/\" target=\"_blank\" rel=\"noopener\">两数相加</a><br>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>\n<h2 id=\"2-示例\"><a href=\"#2-示例\" class=\"headerlink\" title=\"2. 示例\"></a>2. 示例</h2><blockquote>\n<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"3-题目解答\"><a href=\"#3-题目解答\" class=\"headerlink\" title=\"3. 题目解答\"></a>3. 题目解答</h2><h3 id=\"3-1-思路\"><a href=\"#3-1-思路\" class=\"headerlink\" title=\"3.1 思路\"></a>3.1 思路</h3><p>本题比较简单，单纯模拟纸上计算两个数字相加即可，只需要遵循十进制加法，然后注意一下进位和边界问题就行了。思路描述如下：</p>\n<ol>\n<li>如果<code>l1</code>或者<code>l2</code>为空时，返回另外一个链表即可</li>\n<li>定义<code>carry</code>变量，用于记录前一位加法的进位，初始化为0</li>\n<li>遍历两个链表<code>l1</code>和<code>l2</code>，得到<code>node1</code>和<code>node2</code></li>\n<li>如果<code>node1</code>和<code>node2</code>都为空，并且<code>carry</code>为0，则计算结束，返回结果链表</li>\n<li>如果节点<code>node</code>为<code>nullptr</code>，则记录值为<code>0</code>，否则记录值为<code>node-&gt;val</code>。可以得到<code>node1</code>和<code>node2</code>对应的两个值<code>val1</code>和<code>val2</code></li>\n<li>计算<code>val1+val2+carry</code>的结果<code>result</code></li>\n<li>如果大于<code>10</code>，则取对<code>10</code>的余数<code>mod</code>，新增一个<code>val</code>为<code>mod</code>的节点添加到结果链表中；对<code>10</code>的商记录到<code>carry</code>中。继续执行第3步</li>\n<li>如果小于<code>10</code>且大于<code>0</code>，则直接新增一个<code>val</code>为<code>result</code>的节点添加到结果链表中；<code>carry</code>赋值为0。继续执行第3步</li>\n</ol>\n<h3 id=\"3-2-算法复杂度\"><a href=\"#3-2-算法复杂度\" class=\"headerlink\" title=\"3.2 算法复杂度\"></a>3.2 算法复杂度</h3><p>时间复杂度： <code>O(m+n)</code><br>空间复杂度： <code>O(m+n)</code></p>\n<h3 id=\"3-3-代码实现\"><a href=\"#3-3-代码实现\" class=\"headerlink\" title=\"3.3 代码实现\"></a>3.3 代码实现</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode* result = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* node1 = l1;</span><br><span class=\"line\">        ListNode* node2 = l2;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node1 != <span class=\"literal\">nullptr</span> || node2 != <span class=\"literal\">nullptr</span> || carry != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val1 = (node1 == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : node1-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val2 = (node2 == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : node2-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = val1 + val2 + carry;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            ListNode* node = <span class=\"keyword\">new</span> ListNode(val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                result = node;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                prev-&gt;next = node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            prev = node;</span><br><span class=\"line\">            node1 = (node1 != <span class=\"literal\">nullptr</span> ? node1-&gt;next : <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">            node2 = (node1 != <span class=\"literal\">nullptr</span> ? node2-&gt;next : <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-题目描述\"><a href=\"#1-题目描述\" class=\"headerlink\" title=\"1. 题目描述\"></a>1. 题目描述</h2><p><a href=\"https://leetcode-cn.com/problems/add-two-numbers/description/\" target=\"_blank\" rel=\"noopener\">两数相加</a><br>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>\n<h2 id=\"2-示例\"><a href=\"#2-示例\" class=\"headerlink\" title=\"2. 示例\"></a>2. 示例</h2><blockquote>\n<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>\n</blockquote>","more":"<hr>\n<h2 id=\"3-题目解答\"><a href=\"#3-题目解答\" class=\"headerlink\" title=\"3. 题目解答\"></a>3. 题目解答</h2><h3 id=\"3-1-思路\"><a href=\"#3-1-思路\" class=\"headerlink\" title=\"3.1 思路\"></a>3.1 思路</h3><p>本题比较简单，单纯模拟纸上计算两个数字相加即可，只需要遵循十进制加法，然后注意一下进位和边界问题就行了。思路描述如下：</p>\n<ol>\n<li>如果<code>l1</code>或者<code>l2</code>为空时，返回另外一个链表即可</li>\n<li>定义<code>carry</code>变量，用于记录前一位加法的进位，初始化为0</li>\n<li>遍历两个链表<code>l1</code>和<code>l2</code>，得到<code>node1</code>和<code>node2</code></li>\n<li>如果<code>node1</code>和<code>node2</code>都为空，并且<code>carry</code>为0，则计算结束，返回结果链表</li>\n<li>如果节点<code>node</code>为<code>nullptr</code>，则记录值为<code>0</code>，否则记录值为<code>node-&gt;val</code>。可以得到<code>node1</code>和<code>node2</code>对应的两个值<code>val1</code>和<code>val2</code></li>\n<li>计算<code>val1+val2+carry</code>的结果<code>result</code></li>\n<li>如果大于<code>10</code>，则取对<code>10</code>的余数<code>mod</code>，新增一个<code>val</code>为<code>mod</code>的节点添加到结果链表中；对<code>10</code>的商记录到<code>carry</code>中。继续执行第3步</li>\n<li>如果小于<code>10</code>且大于<code>0</code>，则直接新增一个<code>val</code>为<code>result</code>的节点添加到结果链表中；<code>carry</code>赋值为0。继续执行第3步</li>\n</ol>\n<h3 id=\"3-2-算法复杂度\"><a href=\"#3-2-算法复杂度\" class=\"headerlink\" title=\"3.2 算法复杂度\"></a>3.2 算法复杂度</h3><p>时间复杂度： <code>O(m+n)</code><br>空间复杂度： <code>O(m+n)</code></p>\n<h3 id=\"3-3-代码实现\"><a href=\"#3-3-代码实现\" class=\"headerlink\" title=\"3.3 代码实现\"></a>3.3 代码实现</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l2 == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode* result = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* node1 = l1;</span><br><span class=\"line\">        ListNode* node2 = l2;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node1 != <span class=\"literal\">nullptr</span> || node2 != <span class=\"literal\">nullptr</span> || carry != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val1 = (node1 == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : node1-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val2 = (node2 == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : node2-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = val1 + val2 + carry;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> val = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            ListNode* node = <span class=\"keyword\">new</span> ListNode(val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                result = node;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                prev-&gt;next = node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            prev = node;</span><br><span class=\"line\">            node1 = (node1 != <span class=\"literal\">nullptr</span> ? node1-&gt;next : <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">            node2 = (node1 != <span class=\"literal\">nullptr</span> ? node2-&gt;next : <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"WinDBG观世界（一）","date":"2016-04-10T04:19:11.000Z","_content":"\n## 导言\n技术的研究是一个无底洞，如果想要在技术上有所突破，首先得耐得住寂寞，三分钟热度的激情、三天打鱼两天晒网都是不可取，确实能在这个浮躁的社会里面要想耐下性子来好好研究一番的人实在是不多。不妨打开浏览器、甚至是你的qq聊天工具，基本上到处都能看到XX天精通C++，月薪XXXX之类的话。其实后一句话才是重点，如果不是为了追求更好的生活，我想程序员的人数应该会减少一大半。我曾经把程序员分为几个档次:初级的就叫API Caller，粗俗一点就叫码农，只需要保证程序能够按照预期的情况运行，不出bug就行，当然这其实也是大多数程序员的愿望啦。至于为什么叫API Caller，大家看名字应该就知道了吧；中级的叫做Programmer，大多数人也处于这个等级中，我也不例外，属于靠着代码吃饭的同时，也会努力在代码的架构上和整洁上下一番功夫；再往上就是researcher和architect，属于小到技术细节，大到程序框架都能研究个透彻，并且能够信手拈来。好吧，扯远了，其实开心就好。我这次做WinDBG的博客，主要是和大家一起探讨一下程序背后的细节，所谓WinDBG观世界，其实就是程序的世界。这里我推荐大家可以看这本书《程序员的自我修养》，本专题和该书的内容有很大的联系，但是本系列内容只会涉及到windows编程，所使用的工具有Visual Studio 2005和WinDBG。通过对该系列文章的学习，你可以认识到程序编译到运行的原理，以及WinDBG的基本使用。那么闲话少叙，切入正题吧。\n<!--more-->\n## 第一个程序\nHello, World!\n\n本着尽可能简单的思想，我把第一个程序简化成如下的样子：\n```cpp\nvoid TestFunc()\n{\n    int a = 10;\n    int b = 20;\n\n    int c = a + b;\n\n    int d = a + 30;\n\n    int e = 1 + 3;\n}\n\nint main(int argc, char** argv)\n{\n    TestFunc();\n    return 0;\n}\n```\n没有任何`include`，可能比Hello, World!都简单，但是这么简单的语句，\n* 在经过编译器之后变成了什么样呢？\n* 开了优化和没有开优化有什么区别呢？\n* 它在生成了exe之后，exe里面又存放了哪些东西呢？\n* 上面的变量和常量在exe中又是怎样体现的？\n\n如果你对上面这些问题都了然于胸，那么这一章不适合你，你可以等下一章了。如果你对C++基本语法都无法理解，那么也很遗憾，本系列你看不懂。\n\n那么仍然继续读下来的同学，首先要做的事情就是把上面这段代码敲到VS中，然后进行编译就行了。\n\n## 一切都是有条不紊\n这里我们针对Debug编译出来的程序作分析，打开你的WinDBG，然后按下`Ctrl+S`，在弹出的对话框中输入微软符号路径和本地符号路径，我的内容如下：\n```\nD:\\localsymbols;SRV*D:\\localsymbols*http://msdl.microsoft.com/download/symbols;\n```\n然后按下`Ctrl+E`，运行我们编译出来的程序。然后WinDBG展示如下：\n{% asset_img runexe.png 程序执行界面 %}\n\n我们需要在main函数执行的地方下一个断点，以便我们观察程序运行情况，那么我们可以使用下面的命令，然后回车：\n```\nbp HelloWorld2005!main\n```\n\n因为我的程序名字叫做HelloWorld2005，如果你的exe是其他名字记得调整。\n\n输入g回车，WinDBG会执行到main函数时暂定，并自动帮你加载程序的源码。我们这里想了解的是程序背后运作的原理，所以这里更想看到的是汇编代码，很简单，按下`Alt+7`就可以了。\n\n这个时候还没准备好开始调试，还需要把Debug下拉菜单中的Source Mode选项去掉，因为在加载了代码的情况下，WinDBG是以单句代码为单位进行调试的：\n{% asset_img sourcemode.png Source Mode %}\n\n那么从现在开始，调试的操作都和VS一样了，F10是Step Over，F11是Step Into,Shift+F11是Step Out。好了，我们先看汇编代码好了，一句一句来理解。从HelloWorld2005!main开始到ret为止，就是main函数的所有的实现了，怎么样很简短吧，但是也很让人头疼，因为分析起来也不是那么容易的：\n{% asset_img disassembly.png 汇编代码 %}\n\n首先看第一行，\n```\npush ebp\n```\n好吧，看到这一句想到的几个问题就是\n* 它是干嘛的？\n* ebp里面放了什么东西？\n\n那么我这里只能大致告诉你这句话究竟发生了什么事情，因为说多了反而不好理解。\n\n`push ebp`是将ebp寄存器中保存的值进行入栈操作，寄存器如果不明白的话，可以把寄存器当做是一个盒子，里面放了一些数值，并且一台电脑会提供给你多个盒子进行使用。你每次在单步调试时，WinDBG都会把这些盒子里面的数字展示给你看，如下图为当前的寄存器的状态：\n{% asset_img registers.png 寄存器 %}\n\n可以看到ebp中存放了0019ff78(Windbg中展示的数字都是十六进制的，没有前缀0x，但是可能会有后缀h)。它的含义其实是当前函数在堆栈上申请的内存的基地址，具体解释我之后会带出来，此处先不做过多说明。\n\n然后就是push操作对ebp做了什么？有一定C++基础的同学一定都知道局部变量使用的是栈内存，而new出来的对象使用的是堆内存。这里push esp就是把ebp的内容放到栈上，那么这个栈在哪里呢？留着这个疑问，我们按下F10单步执行，观察前后的寄存器的值有什么不同：\n{% asset_img pushebp.png push ebp %}\n\n能看出来么？一共只有两个寄存器发生了变化，eip和esp。\n\n我们这里不难发现，eip和汇编代码左边那堆数字好像有点关系，没错，这个寄存器永远都指向了下一步执行的代码的地址。恩恩，汇编代码左边的那8位数字就是该条汇编代码在该exe运行时的具体地址。\n\n然后就是esp了，它才是这次的主角，它的值从0019ff2c变成了0019ff28，减少了4，而ebp的值是0019ff78，正好四个字节，这不是个巧合，esp永远都指向当前栈的栈顶。这次入栈操作一共经过下面两个步骤：\n1. esp-4\n2. [esp]=ebp\n\n我们还可以通过Windbg命令来验证一下，输入`dd 0019ff28`即可查看0019ff28内存地址附近的内容，也可以直接输入`dd esp`。\n{% asset_img pushresult.png push result %}\n\n怎么样，第一个字节是不是和ebp的内容一样？这样的话ebp此时的值就可以认为是被保存了起来，并且如果以后需要用到该值，可以使用`pop ebp`来获取。\n\n要想理解ebp的含义，那么不如在TestFunc的地方下一个断点，还记得什么指令么：`bp HelloWorld2005!TestFunc`。然后输入g，回车。我们便来到了TestFunc函数的入口处：\n{% asset_img testfuncsource.png TestFunc disassembly %}\n\n这时我们可以不忙着看汇编实现，尝试着输入kbn，来看下当前的函数调用堆栈：\n{% asset_img callstack.png Callstack %}\n\n这里我简单说明下程序执行遇到函数调用会发生什么动作（下面的顺序不代表动作的先后顺序）：\n* 保存上一个函数的局部变量等信息\n* 保存函数调用点\n* 将函数调用参数入栈\n* 调用函数\n\n那么这里显示的函数调用堆栈，主要为我们展示了下面几个信息：\n1. ChildEBP: 当前函数在堆栈上申请的内存的基地址\n2. RetAddr: 函数的返回地址，或者理解为该函数返回后，继续执行的那个地址\n3. Args to Child: 函数参数的值\n4. 函数名和所在代码位置信息\n\n那么这里ChildEBP和ebp寄存器名字相似绝对不是偶然，恩恩，你猜对了，ebp中保存的就是当前函数在堆栈上所使用的一小部分内存的基地址。众所周知，在函数中申请局部变量是需要消耗栈上内存的，那么在有多个函数调用发生时，为了能够不破坏彼此函数之间的堆栈信息，操作系统在函数调用时，会将其中一部分堆栈区间划分给该函数，而该函数如果想要申请局部变量，使用这块堆栈区间就可以了。比如下面这块代码：\n```cpp\nvoid func1()\n{\n  int a;\n  int b;\n}\n\nvoid func2()\n{\n  int a;\n  int b;\n  func1();\n}\n\nint main()\n{\n  int a;\n  int b;\n  func2();\n  return 0;\n}\n```\n它们过程中形成的堆栈可能会如下图所示：\n{% asset_img callstackstatus.png 堆栈内容 %}\n\n每一个函数拥有自己的一个局部堆栈，然后在自己的局部堆栈中保存局部变量内容。如果发生了函数调用，那么就会把上一个函数的堆栈区间块的起始地址进行压栈，以便函数返回时对局部堆栈信息进行恢复。\n\n所以每次函数调用一开始的两句话\n```\npush ebp\nmov ebp, esp\n```\n\n就是为了做两个工作：\n1. 保存上一个函数的局部堆栈起始地址\n2. 更新本次函数局部堆栈的起始地址\n\n还记得esp指向的是什么地方吗？恩，当前堆栈的顶部。所以这里需要注意的是，上一个函数的堆栈区间的结束地址就是本次函数堆栈区间的起始位置。但是到目前位置还没有为TestFunc函数分配堆栈空间，那么我们继续往下看：\n```\nsub esp, 0FCh\n```\n\n这里把esp的值减去0x0FC的大小，这样ebp~esp之间的区域就形成了TestFunc这个函数的局部堆栈区间了。\n\n等等，那我怎么使用这块区间呢？你刚刚不是说使用push和pop来对堆栈进行操作的吗？怎么好像和你刚刚说的不一样呢？恩，用一分钟时间仔细想一想这些问题。想完之后，继续跟着我往下面一句一句执行：\n```\npush ebx\npush esi\npush edi\n```\n\n这四句话我目前不想解释，因为也不需要知道他们的用途，但是请记住它的结果，那就是esp减少了3*4=0ch，并且esp指向的是edi的值，esp+4指向的是esi的值，esp+8指向的是ebx的值，如下图所示：\n{% asset_img pushebxesiedi.png 此时esp指向的内容 %}\n\n同时现在局部堆栈内存分布的情况如下：\n{% asset_img stackmemory.png 内存分布 %}\n\n是不是现在一目了然了呢，内存地址由上而下依次变大，(ebp-0fch)~ebp的区间还没有做任何事情，然后由于刚刚压栈了三个寄存器，所以栈的顶部又出现了三个值。然后我们继续往下执行：\n```\nlea edi, [ebp-0FCh]\nmov ecx, 3Fh\nmov eax, 0CCCCCCCCh\nrep stos dword ptr es:[edi]\n```\n\n我承认这四句话一开始我也不知道有啥用，直到我google了rep stos指令，其实这句话就是调用了一个函数，作用就是从es:edi指向的地址开始，以DWORD为单位，填充0CCCCCCCCh(eax)，一共填充3F(ecx)次，并且每次填充edi都会加上4，ecx减去1。我们可以计算一下一共是3F*4=FC个字节，正好和上面的预留的局部堆栈空间大小一致。所以这个函数在这里起到的作用其实就是初始化你预留的堆栈内存。而cc在汇编中其实就是int 3，触发一个中断。我猜windows这么做的原因应该就是为了阻止你的程序跑飞吧，因为如果执行到int 3时，你的程序就会崩溃。你也许会好奇es:edi指向的地址到底是多少，呵，好奇心是好的，只不过这个不是这次的重点，所以这次就不讲了，提供给你几个关键字，自己搜索一下吧：段寄存器，实地址模式，保护模式。这里es:edi的地址就是edi的值。\n\n执行完这三句话之后，我们来比较一下前后寄存器的值变化，主要看ecx和edi:\n{% asset_img afterrepstos.png 执行完rep stos %}\n\n可以看出ecx变成了0，edi变成了0019fe54，值和ebp一样，稍微转一下脑筋其实就知道，上面的这三句话其实就可以翻译成下面的这段代码：\n```cpp\nwhile (ecx > 0)\n{\n  * esi = eax;\n  esi += 4;\n  ecx--;\n}\n```\n\n其次我们可以继续通过dd的方式来查看内存的变化，不过我也推荐你按下`alt+5`，用Memory窗口来查看内存。然后在Virtual的输入框中输入edi初始的值，或者直接输入ebp-0fch：\n{% asset_img afterrepstosmem.png 执行完rep stos之后的内存 %}\n\n可以看到从(ebp-0fch)~ebp的区间，内存全部被清除为0CCCCCCCCh了，恩，就是这么神奇。那位同学，你先别急着走啊喂，坐下，我现在就开始讲函数主体了。\n\n第一句是`int a = 10;`，简单声明了一个变量a，并给他赋值为10，那么我们到汇编里面找找看这个a在哪里。诶，好像整个函数里面都没有单独出现a这个字符？难道是优化？No！还记得以前老师说过或者看书看到，变量名不占任何空间，它只是一个标识符。那么a这个变量它标识的起始就是[ebp-8]这个地址开始的一个DWORD，windows汇编中DWORD就是4个字节，额，你要问我为什么exe能够记住每个地址对应于哪个变量啊，编译器生成的指令呗（有兴趣的可以去看下编译器设计中的代码生成）。所以`int a = 10;`这句话起始就被编译成了`mov dword ptr [ebp-8], 0Ah`。能够在上面我画的图里面指出[ebp-8]位于哪里么？\n{% asset_img aftera10.png 执行完int a = 10 %}\n\n如果你要问我为什么中间留出了4个字节没有用，额......好吧我不知道，诚信。我们继续往下看吧。\n\n所以`int b = 20;`这句代码也不用我说了吧，虽然他中间还是空出来了8个字节。\n\n接下来`int c = a + b;`，它对应于汇编中的语句是下面三句：\n```\nmov eax, dword ptr [ebp-8]\nadd eax, dword ptr [ebp-14h]\nmov dword ptr [ebp-20h], eax\n```\n\n你可能会觉得好繁琐，为什么要先把`dword ptr [ebp-8]`指向的值放到eax中？这个就认了吧，人家硬件厂商提供给你的add指令必须要在寄存器上操作，你有什么办法。所以在得到a和b的和之后，再将值放到ebp-20h指向的地址上。下面的`int d = a + 30;`也是同理，所以会形成下图所示的内存结构：\n{% asset_img afterda30.png 执行完int d= a + 30 %}\n\n最后一句最神奇，汇编里面直接把`int e = 1 + 3;`翻译成了`mov dword ptr [ebp-38h], 4`，也就是说编译器在编译的时候已经帮你把1+3的结果给你算出来了。\n\n那么到现在为止，函数的主体已经展示完成了。那么现在到了函数结束清理堆栈的时间了。\n\n下面的三句和上面的三个push执行了一个逆操作：\n```\npop edi\npop esi\npop ebx\n```\n\n这里就是恢复了上一个函数的堆栈情况。\n\n对于下面一条语句\n```\nmov esp, ebp\n```\n由于上一个函数堆栈的结束位置和本次调用函数的开始位置相等，所以当前ebp的值其实就等于上一个函数esp的值，所以这里其实就起到了恢复局部堆栈的栈顶地址的作用。\n\n最后一句`pop ebp`和函数调用最开始的`push ebp`相对应，恢复上一个函数的局部堆栈基地址。\n\n那么关于TestFunc的调用已经全部讲完了。我们再次回到main函数中，其实接下来执行的语句和刚刚分析TestFunc差不多，不过这里又多了下面这几句：\n{% asset_img checkesp.png 检查ESP %}\n\n为什么能够直接用ebp得到esp上一次的值，还要用esp-0C0h这么麻烦呢？其实这里的作用只是为了检查堆栈是否出现了异常，如果堆栈异常了，esp-0c0h的值可能就不等于ebp，这里仅仅做了一个简单的检查处理。\n\n所以第一期就先讲到这里吧。虽然还有它的优化版本，带参数的函数，函数的重载这些还没讲，不过下次再补上吧。拜拜\n\n\n## 回顾：\n\n### 关于WinDBG\n1. dp 模块名!函数名 用来给一个函数下断点。然后F10单步调试，F11进入到函数实现，Shift+F11跳出函数\n2. alt+7 打开反汇编代码\n3. alt+5 打开内存窗口\n4. dd 内存地址 用来查看该内存地址下的内容\n5. kbn 显示当前函数调用堆栈信息\n\n### 关于汇编\n1. ebp记录了当前函数局部堆栈的基地址，esp记录了当前堆栈的栈顶；随着函数的调用和返回，ebp会被不断的压栈和出栈；调用函数的esp和被调用函数的ebp相等\n2. 函数内局部变量以ebp为基地址，从预留的堆栈空间中分配内存的，esp不会发生变化；而push和pop操作，esp则会发生改变\n3. rep stos指令用于给内存进行赋值，内容记录在eax中，赋值次数记录在ecx中；每次赋值eax都会减1\n4. 再有简单运算可以在编译期决定时，编译期会为你进行优化。\n","source":"_posts/windbg/windbg-chapter1.md","raw":"---\ntitle: WinDBG观世界（一）\ndate: 2016-04-10 12:19:11\ncategories: windbg\ntags: [windbg,disassembly,c++]\n---\n\n## 导言\n技术的研究是一个无底洞，如果想要在技术上有所突破，首先得耐得住寂寞，三分钟热度的激情、三天打鱼两天晒网都是不可取，确实能在这个浮躁的社会里面要想耐下性子来好好研究一番的人实在是不多。不妨打开浏览器、甚至是你的qq聊天工具，基本上到处都能看到XX天精通C++，月薪XXXX之类的话。其实后一句话才是重点，如果不是为了追求更好的生活，我想程序员的人数应该会减少一大半。我曾经把程序员分为几个档次:初级的就叫API Caller，粗俗一点就叫码农，只需要保证程序能够按照预期的情况运行，不出bug就行，当然这其实也是大多数程序员的愿望啦。至于为什么叫API Caller，大家看名字应该就知道了吧；中级的叫做Programmer，大多数人也处于这个等级中，我也不例外，属于靠着代码吃饭的同时，也会努力在代码的架构上和整洁上下一番功夫；再往上就是researcher和architect，属于小到技术细节，大到程序框架都能研究个透彻，并且能够信手拈来。好吧，扯远了，其实开心就好。我这次做WinDBG的博客，主要是和大家一起探讨一下程序背后的细节，所谓WinDBG观世界，其实就是程序的世界。这里我推荐大家可以看这本书《程序员的自我修养》，本专题和该书的内容有很大的联系，但是本系列内容只会涉及到windows编程，所使用的工具有Visual Studio 2005和WinDBG。通过对该系列文章的学习，你可以认识到程序编译到运行的原理，以及WinDBG的基本使用。那么闲话少叙，切入正题吧。\n<!--more-->\n## 第一个程序\nHello, World!\n\n本着尽可能简单的思想，我把第一个程序简化成如下的样子：\n```cpp\nvoid TestFunc()\n{\n    int a = 10;\n    int b = 20;\n\n    int c = a + b;\n\n    int d = a + 30;\n\n    int e = 1 + 3;\n}\n\nint main(int argc, char** argv)\n{\n    TestFunc();\n    return 0;\n}\n```\n没有任何`include`，可能比Hello, World!都简单，但是这么简单的语句，\n* 在经过编译器之后变成了什么样呢？\n* 开了优化和没有开优化有什么区别呢？\n* 它在生成了exe之后，exe里面又存放了哪些东西呢？\n* 上面的变量和常量在exe中又是怎样体现的？\n\n如果你对上面这些问题都了然于胸，那么这一章不适合你，你可以等下一章了。如果你对C++基本语法都无法理解，那么也很遗憾，本系列你看不懂。\n\n那么仍然继续读下来的同学，首先要做的事情就是把上面这段代码敲到VS中，然后进行编译就行了。\n\n## 一切都是有条不紊\n这里我们针对Debug编译出来的程序作分析，打开你的WinDBG，然后按下`Ctrl+S`，在弹出的对话框中输入微软符号路径和本地符号路径，我的内容如下：\n```\nD:\\localsymbols;SRV*D:\\localsymbols*http://msdl.microsoft.com/download/symbols;\n```\n然后按下`Ctrl+E`，运行我们编译出来的程序。然后WinDBG展示如下：\n{% asset_img runexe.png 程序执行界面 %}\n\n我们需要在main函数执行的地方下一个断点，以便我们观察程序运行情况，那么我们可以使用下面的命令，然后回车：\n```\nbp HelloWorld2005!main\n```\n\n因为我的程序名字叫做HelloWorld2005，如果你的exe是其他名字记得调整。\n\n输入g回车，WinDBG会执行到main函数时暂定，并自动帮你加载程序的源码。我们这里想了解的是程序背后运作的原理，所以这里更想看到的是汇编代码，很简单，按下`Alt+7`就可以了。\n\n这个时候还没准备好开始调试，还需要把Debug下拉菜单中的Source Mode选项去掉，因为在加载了代码的情况下，WinDBG是以单句代码为单位进行调试的：\n{% asset_img sourcemode.png Source Mode %}\n\n那么从现在开始，调试的操作都和VS一样了，F10是Step Over，F11是Step Into,Shift+F11是Step Out。好了，我们先看汇编代码好了，一句一句来理解。从HelloWorld2005!main开始到ret为止，就是main函数的所有的实现了，怎么样很简短吧，但是也很让人头疼，因为分析起来也不是那么容易的：\n{% asset_img disassembly.png 汇编代码 %}\n\n首先看第一行，\n```\npush ebp\n```\n好吧，看到这一句想到的几个问题就是\n* 它是干嘛的？\n* ebp里面放了什么东西？\n\n那么我这里只能大致告诉你这句话究竟发生了什么事情，因为说多了反而不好理解。\n\n`push ebp`是将ebp寄存器中保存的值进行入栈操作，寄存器如果不明白的话，可以把寄存器当做是一个盒子，里面放了一些数值，并且一台电脑会提供给你多个盒子进行使用。你每次在单步调试时，WinDBG都会把这些盒子里面的数字展示给你看，如下图为当前的寄存器的状态：\n{% asset_img registers.png 寄存器 %}\n\n可以看到ebp中存放了0019ff78(Windbg中展示的数字都是十六进制的，没有前缀0x，但是可能会有后缀h)。它的含义其实是当前函数在堆栈上申请的内存的基地址，具体解释我之后会带出来，此处先不做过多说明。\n\n然后就是push操作对ebp做了什么？有一定C++基础的同学一定都知道局部变量使用的是栈内存，而new出来的对象使用的是堆内存。这里push esp就是把ebp的内容放到栈上，那么这个栈在哪里呢？留着这个疑问，我们按下F10单步执行，观察前后的寄存器的值有什么不同：\n{% asset_img pushebp.png push ebp %}\n\n能看出来么？一共只有两个寄存器发生了变化，eip和esp。\n\n我们这里不难发现，eip和汇编代码左边那堆数字好像有点关系，没错，这个寄存器永远都指向了下一步执行的代码的地址。恩恩，汇编代码左边的那8位数字就是该条汇编代码在该exe运行时的具体地址。\n\n然后就是esp了，它才是这次的主角，它的值从0019ff2c变成了0019ff28，减少了4，而ebp的值是0019ff78，正好四个字节，这不是个巧合，esp永远都指向当前栈的栈顶。这次入栈操作一共经过下面两个步骤：\n1. esp-4\n2. [esp]=ebp\n\n我们还可以通过Windbg命令来验证一下，输入`dd 0019ff28`即可查看0019ff28内存地址附近的内容，也可以直接输入`dd esp`。\n{% asset_img pushresult.png push result %}\n\n怎么样，第一个字节是不是和ebp的内容一样？这样的话ebp此时的值就可以认为是被保存了起来，并且如果以后需要用到该值，可以使用`pop ebp`来获取。\n\n要想理解ebp的含义，那么不如在TestFunc的地方下一个断点，还记得什么指令么：`bp HelloWorld2005!TestFunc`。然后输入g，回车。我们便来到了TestFunc函数的入口处：\n{% asset_img testfuncsource.png TestFunc disassembly %}\n\n这时我们可以不忙着看汇编实现，尝试着输入kbn，来看下当前的函数调用堆栈：\n{% asset_img callstack.png Callstack %}\n\n这里我简单说明下程序执行遇到函数调用会发生什么动作（下面的顺序不代表动作的先后顺序）：\n* 保存上一个函数的局部变量等信息\n* 保存函数调用点\n* 将函数调用参数入栈\n* 调用函数\n\n那么这里显示的函数调用堆栈，主要为我们展示了下面几个信息：\n1. ChildEBP: 当前函数在堆栈上申请的内存的基地址\n2. RetAddr: 函数的返回地址，或者理解为该函数返回后，继续执行的那个地址\n3. Args to Child: 函数参数的值\n4. 函数名和所在代码位置信息\n\n那么这里ChildEBP和ebp寄存器名字相似绝对不是偶然，恩恩，你猜对了，ebp中保存的就是当前函数在堆栈上所使用的一小部分内存的基地址。众所周知，在函数中申请局部变量是需要消耗栈上内存的，那么在有多个函数调用发生时，为了能够不破坏彼此函数之间的堆栈信息，操作系统在函数调用时，会将其中一部分堆栈区间划分给该函数，而该函数如果想要申请局部变量，使用这块堆栈区间就可以了。比如下面这块代码：\n```cpp\nvoid func1()\n{\n  int a;\n  int b;\n}\n\nvoid func2()\n{\n  int a;\n  int b;\n  func1();\n}\n\nint main()\n{\n  int a;\n  int b;\n  func2();\n  return 0;\n}\n```\n它们过程中形成的堆栈可能会如下图所示：\n{% asset_img callstackstatus.png 堆栈内容 %}\n\n每一个函数拥有自己的一个局部堆栈，然后在自己的局部堆栈中保存局部变量内容。如果发生了函数调用，那么就会把上一个函数的堆栈区间块的起始地址进行压栈，以便函数返回时对局部堆栈信息进行恢复。\n\n所以每次函数调用一开始的两句话\n```\npush ebp\nmov ebp, esp\n```\n\n就是为了做两个工作：\n1. 保存上一个函数的局部堆栈起始地址\n2. 更新本次函数局部堆栈的起始地址\n\n还记得esp指向的是什么地方吗？恩，当前堆栈的顶部。所以这里需要注意的是，上一个函数的堆栈区间的结束地址就是本次函数堆栈区间的起始位置。但是到目前位置还没有为TestFunc函数分配堆栈空间，那么我们继续往下看：\n```\nsub esp, 0FCh\n```\n\n这里把esp的值减去0x0FC的大小，这样ebp~esp之间的区域就形成了TestFunc这个函数的局部堆栈区间了。\n\n等等，那我怎么使用这块区间呢？你刚刚不是说使用push和pop来对堆栈进行操作的吗？怎么好像和你刚刚说的不一样呢？恩，用一分钟时间仔细想一想这些问题。想完之后，继续跟着我往下面一句一句执行：\n```\npush ebx\npush esi\npush edi\n```\n\n这四句话我目前不想解释，因为也不需要知道他们的用途，但是请记住它的结果，那就是esp减少了3*4=0ch，并且esp指向的是edi的值，esp+4指向的是esi的值，esp+8指向的是ebx的值，如下图所示：\n{% asset_img pushebxesiedi.png 此时esp指向的内容 %}\n\n同时现在局部堆栈内存分布的情况如下：\n{% asset_img stackmemory.png 内存分布 %}\n\n是不是现在一目了然了呢，内存地址由上而下依次变大，(ebp-0fch)~ebp的区间还没有做任何事情，然后由于刚刚压栈了三个寄存器，所以栈的顶部又出现了三个值。然后我们继续往下执行：\n```\nlea edi, [ebp-0FCh]\nmov ecx, 3Fh\nmov eax, 0CCCCCCCCh\nrep stos dword ptr es:[edi]\n```\n\n我承认这四句话一开始我也不知道有啥用，直到我google了rep stos指令，其实这句话就是调用了一个函数，作用就是从es:edi指向的地址开始，以DWORD为单位，填充0CCCCCCCCh(eax)，一共填充3F(ecx)次，并且每次填充edi都会加上4，ecx减去1。我们可以计算一下一共是3F*4=FC个字节，正好和上面的预留的局部堆栈空间大小一致。所以这个函数在这里起到的作用其实就是初始化你预留的堆栈内存。而cc在汇编中其实就是int 3，触发一个中断。我猜windows这么做的原因应该就是为了阻止你的程序跑飞吧，因为如果执行到int 3时，你的程序就会崩溃。你也许会好奇es:edi指向的地址到底是多少，呵，好奇心是好的，只不过这个不是这次的重点，所以这次就不讲了，提供给你几个关键字，自己搜索一下吧：段寄存器，实地址模式，保护模式。这里es:edi的地址就是edi的值。\n\n执行完这三句话之后，我们来比较一下前后寄存器的值变化，主要看ecx和edi:\n{% asset_img afterrepstos.png 执行完rep stos %}\n\n可以看出ecx变成了0，edi变成了0019fe54，值和ebp一样，稍微转一下脑筋其实就知道，上面的这三句话其实就可以翻译成下面的这段代码：\n```cpp\nwhile (ecx > 0)\n{\n  * esi = eax;\n  esi += 4;\n  ecx--;\n}\n```\n\n其次我们可以继续通过dd的方式来查看内存的变化，不过我也推荐你按下`alt+5`，用Memory窗口来查看内存。然后在Virtual的输入框中输入edi初始的值，或者直接输入ebp-0fch：\n{% asset_img afterrepstosmem.png 执行完rep stos之后的内存 %}\n\n可以看到从(ebp-0fch)~ebp的区间，内存全部被清除为0CCCCCCCCh了，恩，就是这么神奇。那位同学，你先别急着走啊喂，坐下，我现在就开始讲函数主体了。\n\n第一句是`int a = 10;`，简单声明了一个变量a，并给他赋值为10，那么我们到汇编里面找找看这个a在哪里。诶，好像整个函数里面都没有单独出现a这个字符？难道是优化？No！还记得以前老师说过或者看书看到，变量名不占任何空间，它只是一个标识符。那么a这个变量它标识的起始就是[ebp-8]这个地址开始的一个DWORD，windows汇编中DWORD就是4个字节，额，你要问我为什么exe能够记住每个地址对应于哪个变量啊，编译器生成的指令呗（有兴趣的可以去看下编译器设计中的代码生成）。所以`int a = 10;`这句话起始就被编译成了`mov dword ptr [ebp-8], 0Ah`。能够在上面我画的图里面指出[ebp-8]位于哪里么？\n{% asset_img aftera10.png 执行完int a = 10 %}\n\n如果你要问我为什么中间留出了4个字节没有用，额......好吧我不知道，诚信。我们继续往下看吧。\n\n所以`int b = 20;`这句代码也不用我说了吧，虽然他中间还是空出来了8个字节。\n\n接下来`int c = a + b;`，它对应于汇编中的语句是下面三句：\n```\nmov eax, dword ptr [ebp-8]\nadd eax, dword ptr [ebp-14h]\nmov dword ptr [ebp-20h], eax\n```\n\n你可能会觉得好繁琐，为什么要先把`dword ptr [ebp-8]`指向的值放到eax中？这个就认了吧，人家硬件厂商提供给你的add指令必须要在寄存器上操作，你有什么办法。所以在得到a和b的和之后，再将值放到ebp-20h指向的地址上。下面的`int d = a + 30;`也是同理，所以会形成下图所示的内存结构：\n{% asset_img afterda30.png 执行完int d= a + 30 %}\n\n最后一句最神奇，汇编里面直接把`int e = 1 + 3;`翻译成了`mov dword ptr [ebp-38h], 4`，也就是说编译器在编译的时候已经帮你把1+3的结果给你算出来了。\n\n那么到现在为止，函数的主体已经展示完成了。那么现在到了函数结束清理堆栈的时间了。\n\n下面的三句和上面的三个push执行了一个逆操作：\n```\npop edi\npop esi\npop ebx\n```\n\n这里就是恢复了上一个函数的堆栈情况。\n\n对于下面一条语句\n```\nmov esp, ebp\n```\n由于上一个函数堆栈的结束位置和本次调用函数的开始位置相等，所以当前ebp的值其实就等于上一个函数esp的值，所以这里其实就起到了恢复局部堆栈的栈顶地址的作用。\n\n最后一句`pop ebp`和函数调用最开始的`push ebp`相对应，恢复上一个函数的局部堆栈基地址。\n\n那么关于TestFunc的调用已经全部讲完了。我们再次回到main函数中，其实接下来执行的语句和刚刚分析TestFunc差不多，不过这里又多了下面这几句：\n{% asset_img checkesp.png 检查ESP %}\n\n为什么能够直接用ebp得到esp上一次的值，还要用esp-0C0h这么麻烦呢？其实这里的作用只是为了检查堆栈是否出现了异常，如果堆栈异常了，esp-0c0h的值可能就不等于ebp，这里仅仅做了一个简单的检查处理。\n\n所以第一期就先讲到这里吧。虽然还有它的优化版本，带参数的函数，函数的重载这些还没讲，不过下次再补上吧。拜拜\n\n\n## 回顾：\n\n### 关于WinDBG\n1. dp 模块名!函数名 用来给一个函数下断点。然后F10单步调试，F11进入到函数实现，Shift+F11跳出函数\n2. alt+7 打开反汇编代码\n3. alt+5 打开内存窗口\n4. dd 内存地址 用来查看该内存地址下的内容\n5. kbn 显示当前函数调用堆栈信息\n\n### 关于汇编\n1. ebp记录了当前函数局部堆栈的基地址，esp记录了当前堆栈的栈顶；随着函数的调用和返回，ebp会被不断的压栈和出栈；调用函数的esp和被调用函数的ebp相等\n2. 函数内局部变量以ebp为基地址，从预留的堆栈空间中分配内存的，esp不会发生变化；而push和pop操作，esp则会发生改变\n3. rep stos指令用于给内存进行赋值，内容记录在eax中，赋值次数记录在ecx中；每次赋值eax都会减1\n4. 再有简单运算可以在编译期决定时，编译期会为你进行优化。\n","slug":"windbg-windbg-chapter1","published":1,"updated":"2018-06-25T11:14:49.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjivnhtnc00082guslinn7z4f","content":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>技术的研究是一个无底洞，如果想要在技术上有所突破，首先得耐得住寂寞，三分钟热度的激情、三天打鱼两天晒网都是不可取，确实能在这个浮躁的社会里面要想耐下性子来好好研究一番的人实在是不多。不妨打开浏览器、甚至是你的qq聊天工具，基本上到处都能看到XX天精通C++，月薪XXXX之类的话。其实后一句话才是重点，如果不是为了追求更好的生活，我想程序员的人数应该会减少一大半。我曾经把程序员分为几个档次:初级的就叫API Caller，粗俗一点就叫码农，只需要保证程序能够按照预期的情况运行，不出bug就行，当然这其实也是大多数程序员的愿望啦。至于为什么叫API Caller，大家看名字应该就知道了吧；中级的叫做Programmer，大多数人也处于这个等级中，我也不例外，属于靠着代码吃饭的同时，也会努力在代码的架构上和整洁上下一番功夫；再往上就是researcher和architect，属于小到技术细节，大到程序框架都能研究个透彻，并且能够信手拈来。好吧，扯远了，其实开心就好。我这次做WinDBG的博客，主要是和大家一起探讨一下程序背后的细节，所谓WinDBG观世界，其实就是程序的世界。这里我推荐大家可以看这本书《程序员的自我修养》，本专题和该书的内容有很大的联系，但是本系列内容只会涉及到windows编程，所使用的工具有Visual Studio 2005和WinDBG。通过对该系列文章的学习，你可以认识到程序编译到运行的原理，以及WinDBG的基本使用。那么闲话少叙，切入正题吧。<br><a id=\"more\"></a></p>\n<h2 id=\"第一个程序\"><a href=\"#第一个程序\" class=\"headerlink\" title=\"第一个程序\"></a>第一个程序</h2><p>Hello, World!</p>\n<p>本着尽可能简单的思想，我把第一个程序简化成如下的样子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> d = a + <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> e = <span class=\"number\">1</span> + <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestFunc();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>没有任何<code>include</code>，可能比Hello, World!都简单，但是这么简单的语句，</p>\n<ul>\n<li>在经过编译器之后变成了什么样呢？</li>\n<li>开了优化和没有开优化有什么区别呢？</li>\n<li>它在生成了exe之后，exe里面又存放了哪些东西呢？</li>\n<li>上面的变量和常量在exe中又是怎样体现的？</li>\n</ul>\n<p>如果你对上面这些问题都了然于胸，那么这一章不适合你，你可以等下一章了。如果你对C++基本语法都无法理解，那么也很遗憾，本系列你看不懂。</p>\n<p>那么仍然继续读下来的同学，首先要做的事情就是把上面这段代码敲到VS中，然后进行编译就行了。</p>\n<h2 id=\"一切都是有条不紊\"><a href=\"#一切都是有条不紊\" class=\"headerlink\" title=\"一切都是有条不紊\"></a>一切都是有条不紊</h2><p>这里我们针对Debug编译出来的程序作分析，打开你的WinDBG，然后按下<code>Ctrl+S</code>，在弹出的对话框中输入微软符号路径和本地符号路径，我的内容如下：<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">D:</span>\\localsymbols;SRV*<span class=\"string\">D:</span>\\localsymbols*<span class=\"string\">http:</span><span class=\"comment\">//msdl.microsoft.com/download/symbols;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后按下<code>Ctrl+E</code>，运行我们编译出来的程序。然后WinDBG展示如下：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/runexe.png\" title=\"程序执行界面\"></p>\n<p>我们需要在main函数执行的地方下一个断点，以便我们观察程序运行情况，那么我们可以使用下面的命令，然后回车：<br><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bp </span>HelloWorld2005!main</span><br></pre></td></tr></table></figure></p>\n<p>因为我的程序名字叫做HelloWorld2005，如果你的exe是其他名字记得调整。</p>\n<p>输入g回车，WinDBG会执行到main函数时暂定，并自动帮你加载程序的源码。我们这里想了解的是程序背后运作的原理，所以这里更想看到的是汇编代码，很简单，按下<code>Alt+7</code>就可以了。</p>\n<p>这个时候还没准备好开始调试，还需要把Debug下拉菜单中的Source Mode选项去掉，因为在加载了代码的情况下，WinDBG是以单句代码为单位进行调试的：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/sourcemode.png\" title=\"Source Mode\"></p>\n<p>那么从现在开始，调试的操作都和VS一样了，F10是Step Over，F11是Step Into,Shift+F11是Step Out。好了，我们先看汇编代码好了，一句一句来理解。从HelloWorld2005!main开始到ret为止，就是main函数的所有的实现了，怎么样很简短吧，但是也很让人头疼，因为分析起来也不是那么容易的：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/disassembly.png\" title=\"汇编代码\"></p>\n<p>首先看第一行，<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">push</span> <span class=\"built_in\">ebp</span></span><br></pre></td></tr></table></figure></p>\n<p>好吧，看到这一句想到的几个问题就是</p>\n<ul>\n<li>它是干嘛的？</li>\n<li>ebp里面放了什么东西？</li>\n</ul>\n<p>那么我这里只能大致告诉你这句话究竟发生了什么事情，因为说多了反而不好理解。</p>\n<p><code>push ebp</code>是将ebp寄存器中保存的值进行入栈操作，寄存器如果不明白的话，可以把寄存器当做是一个盒子，里面放了一些数值，并且一台电脑会提供给你多个盒子进行使用。你每次在单步调试时，WinDBG都会把这些盒子里面的数字展示给你看，如下图为当前的寄存器的状态：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/registers.png\" title=\"寄存器\"></p>\n<p>可以看到ebp中存放了0019ff78(Windbg中展示的数字都是十六进制的，没有前缀0x，但是可能会有后缀h)。它的含义其实是当前函数在堆栈上申请的内存的基地址，具体解释我之后会带出来，此处先不做过多说明。</p>\n<p>然后就是push操作对ebp做了什么？有一定C++基础的同学一定都知道局部变量使用的是栈内存，而new出来的对象使用的是堆内存。这里push esp就是把ebp的内容放到栈上，那么这个栈在哪里呢？留着这个疑问，我们按下F10单步执行，观察前后的寄存器的值有什么不同：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/pushebp.png\" title=\"push ebp\"></p>\n<p>能看出来么？一共只有两个寄存器发生了变化，eip和esp。</p>\n<p>我们这里不难发现，eip和汇编代码左边那堆数字好像有点关系，没错，这个寄存器永远都指向了下一步执行的代码的地址。恩恩，汇编代码左边的那8位数字就是该条汇编代码在该exe运行时的具体地址。</p>\n<p>然后就是esp了，它才是这次的主角，它的值从0019ff2c变成了0019ff28，减少了4，而ebp的值是0019ff78，正好四个字节，这不是个巧合，esp永远都指向当前栈的栈顶。这次入栈操作一共经过下面两个步骤：</p>\n<ol>\n<li>esp-4</li>\n<li>[esp]=ebp</li>\n</ol>\n<p>我们还可以通过Windbg命令来验证一下，输入<code>dd 0019ff28</code>即可查看0019ff28内存地址附近的内容，也可以直接输入<code>dd esp</code>。<br><img src=\"/2016/04/10/windbg-windbg-chapter1/pushresult.png\" title=\"push result\"></p>\n<p>怎么样，第一个字节是不是和ebp的内容一样？这样的话ebp此时的值就可以认为是被保存了起来，并且如果以后需要用到该值，可以使用<code>pop ebp</code>来获取。</p>\n<p>要想理解ebp的含义，那么不如在TestFunc的地方下一个断点，还记得什么指令么：<code>bp HelloWorld2005!TestFunc</code>。然后输入g，回车。我们便来到了TestFunc函数的入口处：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/testfuncsource.png\" title=\"TestFunc disassembly\"></p>\n<p>这时我们可以不忙着看汇编实现，尝试着输入kbn，来看下当前的函数调用堆栈：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/callstack.png\" title=\"Callstack\"></p>\n<p>这里我简单说明下程序执行遇到函数调用会发生什么动作（下面的顺序不代表动作的先后顺序）：</p>\n<ul>\n<li>保存上一个函数的局部变量等信息</li>\n<li>保存函数调用点</li>\n<li>将函数调用参数入栈</li>\n<li>调用函数</li>\n</ul>\n<p>那么这里显示的函数调用堆栈，主要为我们展示了下面几个信息：</p>\n<ol>\n<li>ChildEBP: 当前函数在堆栈上申请的内存的基地址</li>\n<li>RetAddr: 函数的返回地址，或者理解为该函数返回后，继续执行的那个地址</li>\n<li>Args to Child: 函数参数的值</li>\n<li>函数名和所在代码位置信息</li>\n</ol>\n<p>那么这里ChildEBP和ebp寄存器名字相似绝对不是偶然，恩恩，你猜对了，ebp中保存的就是当前函数在堆栈上所使用的一小部分内存的基地址。众所周知，在函数中申请局部变量是需要消耗栈上内存的，那么在有多个函数调用发生时，为了能够不破坏彼此函数之间的堆栈信息，操作系统在函数调用时，会将其中一部分堆栈区间划分给该函数，而该函数如果想要申请局部变量，使用这块堆栈区间就可以了。比如下面这块代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">  func1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">  func2();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它们过程中形成的堆栈可能会如下图所示：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/callstackstatus.png\" title=\"堆栈内容\"></p>\n<p>每一个函数拥有自己的一个局部堆栈，然后在自己的局部堆栈中保存局部变量内容。如果发生了函数调用，那么就会把上一个函数的堆栈区间块的起始地址进行压栈，以便函数返回时对局部堆栈信息进行恢复。</p>\n<p>所以每次函数调用一开始的两句话<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">push</span> <span class=\"built_in\">ebp</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">ebp</span>, <span class=\"built_in\">esp</span></span><br></pre></td></tr></table></figure></p>\n<p>就是为了做两个工作：</p>\n<ol>\n<li>保存上一个函数的局部堆栈起始地址</li>\n<li>更新本次函数局部堆栈的起始地址</li>\n</ol>\n<p>还记得esp指向的是什么地方吗？恩，当前堆栈的顶部。所以这里需要注意的是，上一个函数的堆栈区间的结束地址就是本次函数堆栈区间的起始位置。但是到目前位置还没有为TestFunc函数分配堆栈空间，那么我们继续往下看：<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sub</span> <span class=\"built_in\">esp</span>, <span class=\"number\">0FCh</span></span><br></pre></td></tr></table></figure></p>\n<p>这里把esp的值减去0x0FC的大小，这样ebp~esp之间的区域就形成了TestFunc这个函数的局部堆栈区间了。</p>\n<p>等等，那我怎么使用这块区间呢？你刚刚不是说使用push和pop来对堆栈进行操作的吗？怎么好像和你刚刚说的不一样呢？恩，用一分钟时间仔细想一想这些问题。想完之后，继续跟着我往下面一句一句执行：<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">push</span> <span class=\"built_in\">ebx</span></span><br><span class=\"line\"><span class=\"keyword\">push</span> <span class=\"built_in\">esi</span></span><br><span class=\"line\"><span class=\"keyword\">push</span> <span class=\"built_in\">edi</span></span><br></pre></td></tr></table></figure></p>\n<p>这四句话我目前不想解释，因为也不需要知道他们的用途，但是请记住它的结果，那就是esp减少了3*4=0ch，并且esp指向的是edi的值，esp+4指向的是esi的值，esp+8指向的是ebx的值，如下图所示：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/pushebxesiedi.png\" title=\"此时esp指向的内容\"></p>\n<p>同时现在局部堆栈内存分布的情况如下：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/stackmemory.png\" title=\"内存分布\"></p>\n<p>是不是现在一目了然了呢，内存地址由上而下依次变大，(ebp-0fch)~ebp的区间还没有做任何事情，然后由于刚刚压栈了三个寄存器，所以栈的顶部又出现了三个值。然后我们继续往下执行：<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lea</span> <span class=\"built_in\">edi</span>, [<span class=\"built_in\">ebp</span>-<span class=\"number\">0FCh</span>]</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">ecx</span>, <span class=\"number\">3Fh</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, <span class=\"number\">0CCCCCCCCh</span></span><br><span class=\"line\"><span class=\"keyword\">rep</span> stos <span class=\"built_in\">dword</span> <span class=\"built_in\">ptr</span> <span class=\"built_in\">es</span>:[<span class=\"built_in\">edi</span>]</span><br></pre></td></tr></table></figure></p>\n<p>我承认这四句话一开始我也不知道有啥用，直到我google了rep stos指令，其实这句话就是调用了一个函数，作用就是从es:edi指向的地址开始，以DWORD为单位，填充0CCCCCCCCh(eax)，一共填充3F(ecx)次，并且每次填充edi都会加上4，ecx减去1。我们可以计算一下一共是3F*4=FC个字节，正好和上面的预留的局部堆栈空间大小一致。所以这个函数在这里起到的作用其实就是初始化你预留的堆栈内存。而cc在汇编中其实就是int 3，触发一个中断。我猜windows这么做的原因应该就是为了阻止你的程序跑飞吧，因为如果执行到int 3时，你的程序就会崩溃。你也许会好奇es:edi指向的地址到底是多少，呵，好奇心是好的，只不过这个不是这次的重点，所以这次就不讲了，提供给你几个关键字，自己搜索一下吧：段寄存器，实地址模式，保护模式。这里es:edi的地址就是edi的值。</p>\n<p>执行完这三句话之后，我们来比较一下前后寄存器的值变化，主要看ecx和edi:<br><img src=\"/2016/04/10/windbg-windbg-chapter1/afterrepstos.png\" title=\"执行完rep stos\"></p>\n<p>可以看出ecx变成了0，edi变成了0019fe54，值和ebp一样，稍微转一下脑筋其实就知道，上面的这三句话其实就可以翻译成下面的这段代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (ecx &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  * esi = eax;</span><br><span class=\"line\">  esi += <span class=\"number\">4</span>;</span><br><span class=\"line\">  ecx--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其次我们可以继续通过dd的方式来查看内存的变化，不过我也推荐你按下<code>alt+5</code>，用Memory窗口来查看内存。然后在Virtual的输入框中输入edi初始的值，或者直接输入ebp-0fch：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/afterrepstosmem.png\" title=\"执行完rep stos之后的内存\"></p>\n<p>可以看到从(ebp-0fch)~ebp的区间，内存全部被清除为0CCCCCCCCh了，恩，就是这么神奇。那位同学，你先别急着走啊喂，坐下，我现在就开始讲函数主体了。</p>\n<p>第一句是<code>int a = 10;</code>，简单声明了一个变量a，并给他赋值为10，那么我们到汇编里面找找看这个a在哪里。诶，好像整个函数里面都没有单独出现a这个字符？难道是优化？No！还记得以前老师说过或者看书看到，变量名不占任何空间，它只是一个标识符。那么a这个变量它标识的起始就是[ebp-8]这个地址开始的一个DWORD，windows汇编中DWORD就是4个字节，额，你要问我为什么exe能够记住每个地址对应于哪个变量啊，编译器生成的指令呗（有兴趣的可以去看下编译器设计中的代码生成）。所以<code>int a = 10;</code>这句话起始就被编译成了<code>mov dword ptr [ebp-8], 0Ah</code>。能够在上面我画的图里面指出[ebp-8]位于哪里么？<br><img src=\"/2016/04/10/windbg-windbg-chapter1/aftera10.png\" title=\"执行完int a = 10\"></p>\n<p>如果你要问我为什么中间留出了4个字节没有用，额……好吧我不知道，诚信。我们继续往下看吧。</p>\n<p>所以<code>int b = 20;</code>这句代码也不用我说了吧，虽然他中间还是空出来了8个字节。</p>\n<p>接下来<code>int c = a + b;</code>，它对应于汇编中的语句是下面三句：<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, <span class=\"built_in\">dword</span> <span class=\"built_in\">ptr</span> [<span class=\"built_in\">ebp</span>-<span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"keyword\">add</span> <span class=\"built_in\">eax</span>, <span class=\"built_in\">dword</span> <span class=\"built_in\">ptr</span> [<span class=\"built_in\">ebp</span>-<span class=\"number\">14h</span>]</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">dword</span> <span class=\"built_in\">ptr</span> [<span class=\"built_in\">ebp</span>-<span class=\"number\">20h</span>], <span class=\"built_in\">eax</span></span><br></pre></td></tr></table></figure></p>\n<p>你可能会觉得好繁琐，为什么要先把<code>dword ptr [ebp-8]</code>指向的值放到eax中？这个就认了吧，人家硬件厂商提供给你的add指令必须要在寄存器上操作，你有什么办法。所以在得到a和b的和之后，再将值放到ebp-20h指向的地址上。下面的<code>int d = a + 30;</code>也是同理，所以会形成下图所示的内存结构：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/afterda30.png\" title=\"执行完int d= a + 30\"></p>\n<p>最后一句最神奇，汇编里面直接把<code>int e = 1 + 3;</code>翻译成了<code>mov dword ptr [ebp-38h], 4</code>，也就是说编译器在编译的时候已经帮你把1+3的结果给你算出来了。</p>\n<p>那么到现在为止，函数的主体已经展示完成了。那么现在到了函数结束清理堆栈的时间了。</p>\n<p>下面的三句和上面的三个push执行了一个逆操作：<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pop</span> <span class=\"built_in\">edi</span></span><br><span class=\"line\"><span class=\"keyword\">pop</span> <span class=\"built_in\">esi</span></span><br><span class=\"line\"><span class=\"keyword\">pop</span> <span class=\"built_in\">ebx</span></span><br></pre></td></tr></table></figure></p>\n<p>这里就是恢复了上一个函数的堆栈情况。</p>\n<p>对于下面一条语句<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">esp</span>, <span class=\"built_in\">ebp</span></span><br></pre></td></tr></table></figure></p>\n<p>由于上一个函数堆栈的结束位置和本次调用函数的开始位置相等，所以当前ebp的值其实就等于上一个函数esp的值，所以这里其实就起到了恢复局部堆栈的栈顶地址的作用。</p>\n<p>最后一句<code>pop ebp</code>和函数调用最开始的<code>push ebp</code>相对应，恢复上一个函数的局部堆栈基地址。</p>\n<p>那么关于TestFunc的调用已经全部讲完了。我们再次回到main函数中，其实接下来执行的语句和刚刚分析TestFunc差不多，不过这里又多了下面这几句：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/checkesp.png\" title=\"检查ESP\"></p>\n<p>为什么能够直接用ebp得到esp上一次的值，还要用esp-0C0h这么麻烦呢？其实这里的作用只是为了检查堆栈是否出现了异常，如果堆栈异常了，esp-0c0h的值可能就不等于ebp，这里仅仅做了一个简单的检查处理。</p>\n<p>所以第一期就先讲到这里吧。虽然还有它的优化版本，带参数的函数，函数的重载这些还没讲，不过下次再补上吧。拜拜</p>\n<h2 id=\"回顾：\"><a href=\"#回顾：\" class=\"headerlink\" title=\"回顾：\"></a>回顾：</h2><h3 id=\"关于WinDBG\"><a href=\"#关于WinDBG\" class=\"headerlink\" title=\"关于WinDBG\"></a>关于WinDBG</h3><ol>\n<li>dp 模块名!函数名 用来给一个函数下断点。然后F10单步调试，F11进入到函数实现，Shift+F11跳出函数</li>\n<li>alt+7 打开反汇编代码</li>\n<li>alt+5 打开内存窗口</li>\n<li>dd 内存地址 用来查看该内存地址下的内容</li>\n<li>kbn 显示当前函数调用堆栈信息</li>\n</ol>\n<h3 id=\"关于汇编\"><a href=\"#关于汇编\" class=\"headerlink\" title=\"关于汇编\"></a>关于汇编</h3><ol>\n<li>ebp记录了当前函数局部堆栈的基地址，esp记录了当前堆栈的栈顶；随着函数的调用和返回，ebp会被不断的压栈和出栈；调用函数的esp和被调用函数的ebp相等</li>\n<li>函数内局部变量以ebp为基地址，从预留的堆栈空间中分配内存的，esp不会发生变化；而push和pop操作，esp则会发生改变</li>\n<li>rep stos指令用于给内存进行赋值，内容记录在eax中，赋值次数记录在ecx中；每次赋值eax都会减1</li>\n<li>再有简单运算可以在编译期决定时，编译期会为你进行优化。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>技术的研究是一个无底洞，如果想要在技术上有所突破，首先得耐得住寂寞，三分钟热度的激情、三天打鱼两天晒网都是不可取，确实能在这个浮躁的社会里面要想耐下性子来好好研究一番的人实在是不多。不妨打开浏览器、甚至是你的qq聊天工具，基本上到处都能看到XX天精通C++，月薪XXXX之类的话。其实后一句话才是重点，如果不是为了追求更好的生活，我想程序员的人数应该会减少一大半。我曾经把程序员分为几个档次:初级的就叫API Caller，粗俗一点就叫码农，只需要保证程序能够按照预期的情况运行，不出bug就行，当然这其实也是大多数程序员的愿望啦。至于为什么叫API Caller，大家看名字应该就知道了吧；中级的叫做Programmer，大多数人也处于这个等级中，我也不例外，属于靠着代码吃饭的同时，也会努力在代码的架构上和整洁上下一番功夫；再往上就是researcher和architect，属于小到技术细节，大到程序框架都能研究个透彻，并且能够信手拈来。好吧，扯远了，其实开心就好。我这次做WinDBG的博客，主要是和大家一起探讨一下程序背后的细节，所谓WinDBG观世界，其实就是程序的世界。这里我推荐大家可以看这本书《程序员的自我修养》，本专题和该书的内容有很大的联系，但是本系列内容只会涉及到windows编程，所使用的工具有Visual Studio 2005和WinDBG。通过对该系列文章的学习，你可以认识到程序编译到运行的原理，以及WinDBG的基本使用。那么闲话少叙，切入正题吧。<br>","more":"</p>\n<h2 id=\"第一个程序\"><a href=\"#第一个程序\" class=\"headerlink\" title=\"第一个程序\"></a>第一个程序</h2><p>Hello, World!</p>\n<p>本着尽可能简单的思想，我把第一个程序简化成如下的样子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestFunc</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = a + b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> d = a + <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> e = <span class=\"number\">1</span> + <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestFunc();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>没有任何<code>include</code>，可能比Hello, World!都简单，但是这么简单的语句，</p>\n<ul>\n<li>在经过编译器之后变成了什么样呢？</li>\n<li>开了优化和没有开优化有什么区别呢？</li>\n<li>它在生成了exe之后，exe里面又存放了哪些东西呢？</li>\n<li>上面的变量和常量在exe中又是怎样体现的？</li>\n</ul>\n<p>如果你对上面这些问题都了然于胸，那么这一章不适合你，你可以等下一章了。如果你对C++基本语法都无法理解，那么也很遗憾，本系列你看不懂。</p>\n<p>那么仍然继续读下来的同学，首先要做的事情就是把上面这段代码敲到VS中，然后进行编译就行了。</p>\n<h2 id=\"一切都是有条不紊\"><a href=\"#一切都是有条不紊\" class=\"headerlink\" title=\"一切都是有条不紊\"></a>一切都是有条不紊</h2><p>这里我们针对Debug编译出来的程序作分析，打开你的WinDBG，然后按下<code>Ctrl+S</code>，在弹出的对话框中输入微软符号路径和本地符号路径，我的内容如下：<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">D:</span>\\localsymbols;SRV*<span class=\"string\">D:</span>\\localsymbols*<span class=\"string\">http:</span><span class=\"comment\">//msdl.microsoft.com/download/symbols;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后按下<code>Ctrl+E</code>，运行我们编译出来的程序。然后WinDBG展示如下：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/runexe.png\" title=\"程序执行界面\"></p>\n<p>我们需要在main函数执行的地方下一个断点，以便我们观察程序运行情况，那么我们可以使用下面的命令，然后回车：<br><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bp </span>HelloWorld2005!main</span><br></pre></td></tr></table></figure></p>\n<p>因为我的程序名字叫做HelloWorld2005，如果你的exe是其他名字记得调整。</p>\n<p>输入g回车，WinDBG会执行到main函数时暂定，并自动帮你加载程序的源码。我们这里想了解的是程序背后运作的原理，所以这里更想看到的是汇编代码，很简单，按下<code>Alt+7</code>就可以了。</p>\n<p>这个时候还没准备好开始调试，还需要把Debug下拉菜单中的Source Mode选项去掉，因为在加载了代码的情况下，WinDBG是以单句代码为单位进行调试的：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/sourcemode.png\" title=\"Source Mode\"></p>\n<p>那么从现在开始，调试的操作都和VS一样了，F10是Step Over，F11是Step Into,Shift+F11是Step Out。好了，我们先看汇编代码好了，一句一句来理解。从HelloWorld2005!main开始到ret为止，就是main函数的所有的实现了，怎么样很简短吧，但是也很让人头疼，因为分析起来也不是那么容易的：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/disassembly.png\" title=\"汇编代码\"></p>\n<p>首先看第一行，<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">push</span> <span class=\"built_in\">ebp</span></span><br></pre></td></tr></table></figure></p>\n<p>好吧，看到这一句想到的几个问题就是</p>\n<ul>\n<li>它是干嘛的？</li>\n<li>ebp里面放了什么东西？</li>\n</ul>\n<p>那么我这里只能大致告诉你这句话究竟发生了什么事情，因为说多了反而不好理解。</p>\n<p><code>push ebp</code>是将ebp寄存器中保存的值进行入栈操作，寄存器如果不明白的话，可以把寄存器当做是一个盒子，里面放了一些数值，并且一台电脑会提供给你多个盒子进行使用。你每次在单步调试时，WinDBG都会把这些盒子里面的数字展示给你看，如下图为当前的寄存器的状态：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/registers.png\" title=\"寄存器\"></p>\n<p>可以看到ebp中存放了0019ff78(Windbg中展示的数字都是十六进制的，没有前缀0x，但是可能会有后缀h)。它的含义其实是当前函数在堆栈上申请的内存的基地址，具体解释我之后会带出来，此处先不做过多说明。</p>\n<p>然后就是push操作对ebp做了什么？有一定C++基础的同学一定都知道局部变量使用的是栈内存，而new出来的对象使用的是堆内存。这里push esp就是把ebp的内容放到栈上，那么这个栈在哪里呢？留着这个疑问，我们按下F10单步执行，观察前后的寄存器的值有什么不同：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/pushebp.png\" title=\"push ebp\"></p>\n<p>能看出来么？一共只有两个寄存器发生了变化，eip和esp。</p>\n<p>我们这里不难发现，eip和汇编代码左边那堆数字好像有点关系，没错，这个寄存器永远都指向了下一步执行的代码的地址。恩恩，汇编代码左边的那8位数字就是该条汇编代码在该exe运行时的具体地址。</p>\n<p>然后就是esp了，它才是这次的主角，它的值从0019ff2c变成了0019ff28，减少了4，而ebp的值是0019ff78，正好四个字节，这不是个巧合，esp永远都指向当前栈的栈顶。这次入栈操作一共经过下面两个步骤：</p>\n<ol>\n<li>esp-4</li>\n<li>[esp]=ebp</li>\n</ol>\n<p>我们还可以通过Windbg命令来验证一下，输入<code>dd 0019ff28</code>即可查看0019ff28内存地址附近的内容，也可以直接输入<code>dd esp</code>。<br><img src=\"/2016/04/10/windbg-windbg-chapter1/pushresult.png\" title=\"push result\"></p>\n<p>怎么样，第一个字节是不是和ebp的内容一样？这样的话ebp此时的值就可以认为是被保存了起来，并且如果以后需要用到该值，可以使用<code>pop ebp</code>来获取。</p>\n<p>要想理解ebp的含义，那么不如在TestFunc的地方下一个断点，还记得什么指令么：<code>bp HelloWorld2005!TestFunc</code>。然后输入g，回车。我们便来到了TestFunc函数的入口处：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/testfuncsource.png\" title=\"TestFunc disassembly\"></p>\n<p>这时我们可以不忙着看汇编实现，尝试着输入kbn，来看下当前的函数调用堆栈：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/callstack.png\" title=\"Callstack\"></p>\n<p>这里我简单说明下程序执行遇到函数调用会发生什么动作（下面的顺序不代表动作的先后顺序）：</p>\n<ul>\n<li>保存上一个函数的局部变量等信息</li>\n<li>保存函数调用点</li>\n<li>将函数调用参数入栈</li>\n<li>调用函数</li>\n</ul>\n<p>那么这里显示的函数调用堆栈，主要为我们展示了下面几个信息：</p>\n<ol>\n<li>ChildEBP: 当前函数在堆栈上申请的内存的基地址</li>\n<li>RetAddr: 函数的返回地址，或者理解为该函数返回后，继续执行的那个地址</li>\n<li>Args to Child: 函数参数的值</li>\n<li>函数名和所在代码位置信息</li>\n</ol>\n<p>那么这里ChildEBP和ebp寄存器名字相似绝对不是偶然，恩恩，你猜对了，ebp中保存的就是当前函数在堆栈上所使用的一小部分内存的基地址。众所周知，在函数中申请局部变量是需要消耗栈上内存的，那么在有多个函数调用发生时，为了能够不破坏彼此函数之间的堆栈信息，操作系统在函数调用时，会将其中一部分堆栈区间划分给该函数，而该函数如果想要申请局部变量，使用这块堆栈区间就可以了。比如下面这块代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">  func1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">  func2();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它们过程中形成的堆栈可能会如下图所示：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/callstackstatus.png\" title=\"堆栈内容\"></p>\n<p>每一个函数拥有自己的一个局部堆栈，然后在自己的局部堆栈中保存局部变量内容。如果发生了函数调用，那么就会把上一个函数的堆栈区间块的起始地址进行压栈，以便函数返回时对局部堆栈信息进行恢复。</p>\n<p>所以每次函数调用一开始的两句话<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">push</span> <span class=\"built_in\">ebp</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">ebp</span>, <span class=\"built_in\">esp</span></span><br></pre></td></tr></table></figure></p>\n<p>就是为了做两个工作：</p>\n<ol>\n<li>保存上一个函数的局部堆栈起始地址</li>\n<li>更新本次函数局部堆栈的起始地址</li>\n</ol>\n<p>还记得esp指向的是什么地方吗？恩，当前堆栈的顶部。所以这里需要注意的是，上一个函数的堆栈区间的结束地址就是本次函数堆栈区间的起始位置。但是到目前位置还没有为TestFunc函数分配堆栈空间，那么我们继续往下看：<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">sub</span> <span class=\"built_in\">esp</span>, <span class=\"number\">0FCh</span></span><br></pre></td></tr></table></figure></p>\n<p>这里把esp的值减去0x0FC的大小，这样ebp~esp之间的区域就形成了TestFunc这个函数的局部堆栈区间了。</p>\n<p>等等，那我怎么使用这块区间呢？你刚刚不是说使用push和pop来对堆栈进行操作的吗？怎么好像和你刚刚说的不一样呢？恩，用一分钟时间仔细想一想这些问题。想完之后，继续跟着我往下面一句一句执行：<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">push</span> <span class=\"built_in\">ebx</span></span><br><span class=\"line\"><span class=\"keyword\">push</span> <span class=\"built_in\">esi</span></span><br><span class=\"line\"><span class=\"keyword\">push</span> <span class=\"built_in\">edi</span></span><br></pre></td></tr></table></figure></p>\n<p>这四句话我目前不想解释，因为也不需要知道他们的用途，但是请记住它的结果，那就是esp减少了3*4=0ch，并且esp指向的是edi的值，esp+4指向的是esi的值，esp+8指向的是ebx的值，如下图所示：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/pushebxesiedi.png\" title=\"此时esp指向的内容\"></p>\n<p>同时现在局部堆栈内存分布的情况如下：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/stackmemory.png\" title=\"内存分布\"></p>\n<p>是不是现在一目了然了呢，内存地址由上而下依次变大，(ebp-0fch)~ebp的区间还没有做任何事情，然后由于刚刚压栈了三个寄存器，所以栈的顶部又出现了三个值。然后我们继续往下执行：<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lea</span> <span class=\"built_in\">edi</span>, [<span class=\"built_in\">ebp</span>-<span class=\"number\">0FCh</span>]</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">ecx</span>, <span class=\"number\">3Fh</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, <span class=\"number\">0CCCCCCCCh</span></span><br><span class=\"line\"><span class=\"keyword\">rep</span> stos <span class=\"built_in\">dword</span> <span class=\"built_in\">ptr</span> <span class=\"built_in\">es</span>:[<span class=\"built_in\">edi</span>]</span><br></pre></td></tr></table></figure></p>\n<p>我承认这四句话一开始我也不知道有啥用，直到我google了rep stos指令，其实这句话就是调用了一个函数，作用就是从es:edi指向的地址开始，以DWORD为单位，填充0CCCCCCCCh(eax)，一共填充3F(ecx)次，并且每次填充edi都会加上4，ecx减去1。我们可以计算一下一共是3F*4=FC个字节，正好和上面的预留的局部堆栈空间大小一致。所以这个函数在这里起到的作用其实就是初始化你预留的堆栈内存。而cc在汇编中其实就是int 3，触发一个中断。我猜windows这么做的原因应该就是为了阻止你的程序跑飞吧，因为如果执行到int 3时，你的程序就会崩溃。你也许会好奇es:edi指向的地址到底是多少，呵，好奇心是好的，只不过这个不是这次的重点，所以这次就不讲了，提供给你几个关键字，自己搜索一下吧：段寄存器，实地址模式，保护模式。这里es:edi的地址就是edi的值。</p>\n<p>执行完这三句话之后，我们来比较一下前后寄存器的值变化，主要看ecx和edi:<br><img src=\"/2016/04/10/windbg-windbg-chapter1/afterrepstos.png\" title=\"执行完rep stos\"></p>\n<p>可以看出ecx变成了0，edi变成了0019fe54，值和ebp一样，稍微转一下脑筋其实就知道，上面的这三句话其实就可以翻译成下面的这段代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (ecx &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  * esi = eax;</span><br><span class=\"line\">  esi += <span class=\"number\">4</span>;</span><br><span class=\"line\">  ecx--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其次我们可以继续通过dd的方式来查看内存的变化，不过我也推荐你按下<code>alt+5</code>，用Memory窗口来查看内存。然后在Virtual的输入框中输入edi初始的值，或者直接输入ebp-0fch：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/afterrepstosmem.png\" title=\"执行完rep stos之后的内存\"></p>\n<p>可以看到从(ebp-0fch)~ebp的区间，内存全部被清除为0CCCCCCCCh了，恩，就是这么神奇。那位同学，你先别急着走啊喂，坐下，我现在就开始讲函数主体了。</p>\n<p>第一句是<code>int a = 10;</code>，简单声明了一个变量a，并给他赋值为10，那么我们到汇编里面找找看这个a在哪里。诶，好像整个函数里面都没有单独出现a这个字符？难道是优化？No！还记得以前老师说过或者看书看到，变量名不占任何空间，它只是一个标识符。那么a这个变量它标识的起始就是[ebp-8]这个地址开始的一个DWORD，windows汇编中DWORD就是4个字节，额，你要问我为什么exe能够记住每个地址对应于哪个变量啊，编译器生成的指令呗（有兴趣的可以去看下编译器设计中的代码生成）。所以<code>int a = 10;</code>这句话起始就被编译成了<code>mov dword ptr [ebp-8], 0Ah</code>。能够在上面我画的图里面指出[ebp-8]位于哪里么？<br><img src=\"/2016/04/10/windbg-windbg-chapter1/aftera10.png\" title=\"执行完int a = 10\"></p>\n<p>如果你要问我为什么中间留出了4个字节没有用，额……好吧我不知道，诚信。我们继续往下看吧。</p>\n<p>所以<code>int b = 20;</code>这句代码也不用我说了吧，虽然他中间还是空出来了8个字节。</p>\n<p>接下来<code>int c = a + b;</code>，它对应于汇编中的语句是下面三句：<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, <span class=\"built_in\">dword</span> <span class=\"built_in\">ptr</span> [<span class=\"built_in\">ebp</span>-<span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"keyword\">add</span> <span class=\"built_in\">eax</span>, <span class=\"built_in\">dword</span> <span class=\"built_in\">ptr</span> [<span class=\"built_in\">ebp</span>-<span class=\"number\">14h</span>]</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">dword</span> <span class=\"built_in\">ptr</span> [<span class=\"built_in\">ebp</span>-<span class=\"number\">20h</span>], <span class=\"built_in\">eax</span></span><br></pre></td></tr></table></figure></p>\n<p>你可能会觉得好繁琐，为什么要先把<code>dword ptr [ebp-8]</code>指向的值放到eax中？这个就认了吧，人家硬件厂商提供给你的add指令必须要在寄存器上操作，你有什么办法。所以在得到a和b的和之后，再将值放到ebp-20h指向的地址上。下面的<code>int d = a + 30;</code>也是同理，所以会形成下图所示的内存结构：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/afterda30.png\" title=\"执行完int d= a + 30\"></p>\n<p>最后一句最神奇，汇编里面直接把<code>int e = 1 + 3;</code>翻译成了<code>mov dword ptr [ebp-38h], 4</code>，也就是说编译器在编译的时候已经帮你把1+3的结果给你算出来了。</p>\n<p>那么到现在为止，函数的主体已经展示完成了。那么现在到了函数结束清理堆栈的时间了。</p>\n<p>下面的三句和上面的三个push执行了一个逆操作：<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pop</span> <span class=\"built_in\">edi</span></span><br><span class=\"line\"><span class=\"keyword\">pop</span> <span class=\"built_in\">esi</span></span><br><span class=\"line\"><span class=\"keyword\">pop</span> <span class=\"built_in\">ebx</span></span><br></pre></td></tr></table></figure></p>\n<p>这里就是恢复了上一个函数的堆栈情况。</p>\n<p>对于下面一条语句<br><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">esp</span>, <span class=\"built_in\">ebp</span></span><br></pre></td></tr></table></figure></p>\n<p>由于上一个函数堆栈的结束位置和本次调用函数的开始位置相等，所以当前ebp的值其实就等于上一个函数esp的值，所以这里其实就起到了恢复局部堆栈的栈顶地址的作用。</p>\n<p>最后一句<code>pop ebp</code>和函数调用最开始的<code>push ebp</code>相对应，恢复上一个函数的局部堆栈基地址。</p>\n<p>那么关于TestFunc的调用已经全部讲完了。我们再次回到main函数中，其实接下来执行的语句和刚刚分析TestFunc差不多，不过这里又多了下面这几句：<br><img src=\"/2016/04/10/windbg-windbg-chapter1/checkesp.png\" title=\"检查ESP\"></p>\n<p>为什么能够直接用ebp得到esp上一次的值，还要用esp-0C0h这么麻烦呢？其实这里的作用只是为了检查堆栈是否出现了异常，如果堆栈异常了，esp-0c0h的值可能就不等于ebp，这里仅仅做了一个简单的检查处理。</p>\n<p>所以第一期就先讲到这里吧。虽然还有它的优化版本，带参数的函数，函数的重载这些还没讲，不过下次再补上吧。拜拜</p>\n<h2 id=\"回顾：\"><a href=\"#回顾：\" class=\"headerlink\" title=\"回顾：\"></a>回顾：</h2><h3 id=\"关于WinDBG\"><a href=\"#关于WinDBG\" class=\"headerlink\" title=\"关于WinDBG\"></a>关于WinDBG</h3><ol>\n<li>dp 模块名!函数名 用来给一个函数下断点。然后F10单步调试，F11进入到函数实现，Shift+F11跳出函数</li>\n<li>alt+7 打开反汇编代码</li>\n<li>alt+5 打开内存窗口</li>\n<li>dd 内存地址 用来查看该内存地址下的内容</li>\n<li>kbn 显示当前函数调用堆栈信息</li>\n</ol>\n<h3 id=\"关于汇编\"><a href=\"#关于汇编\" class=\"headerlink\" title=\"关于汇编\"></a>关于汇编</h3><ol>\n<li>ebp记录了当前函数局部堆栈的基地址，esp记录了当前堆栈的栈顶；随着函数的调用和返回，ebp会被不断的压栈和出栈；调用函数的esp和被调用函数的ebp相等</li>\n<li>函数内局部变量以ebp为基地址，从预留的堆栈空间中分配内存的，esp不会发生变化；而push和pop操作，esp则会发生改变</li>\n<li>rep stos指令用于给内存进行赋值，内容记录在eax中，赋值次数记录在ecx中；每次赋值eax都会减1</li>\n<li>再有简单运算可以在编译期决定时，编译期会为你进行优化。</li>\n</ol>"},{"title":"WinDBG观世界（三）","date":"2016-04-20T16:48:07.000Z","_content":"\n## 导言\n已经介绍了函数和结构体的内容了，我想这次应该可以大致研究一下类相关的知识了。不过这次照例还是没有release版本的分析内容，而且这次讲类也只是讲解基础知识，对于类的高级用法，比如继承、成员函数指针这些都留到以后去研究。那么进入正题吧（貌似导言越来越短了，我在想以后要不要去掉）。\n<!--more-->\n## 给结构体加上一点控制！再加上一点函数！\n国际惯例，先贴分析的代码：\n```cpp\nclass SimpleClass\n{\npublic:\n    SimpleClass(int m)\n        : a(m)\n    {\n        b = 3;\n    }\n\n    SimpleClass(const SimpleClass& rhs)\n        : a(rhs.a)\n        , b(rhs.b)\n    {\n\n    }\n\n    ~SimpleClass()\n    {\n\n    }\n\npublic:\n    void TestMemberFunc()\n    {\n        a += b;\n    }\n\n    void TestConstMemberFunc() const\n    {\n        int m = a;\n        m += b;\n    }\n\npublic:\n    virtual void TestVirtual(int m)\n    {\n        a += m;\n    }\n\npublic:\n    static int TestStatic(int m, int n)\n    {\n        return m + n;\n    }\n\nprivate:\n    int a;\n    int b;\n\nprivate:\n    static const char* str;\n};\n\nconst char* SimpleClass::str = \"joker\";\n\nSimpleClass k(12);\n\nint main(int argc, char** argv)\n{\n    SimpleClass j = 233;\n    SimpleClass k = ::k;\n    SimpleClass a(k);\n\n    k.TestMemberFunc();\n    k.TestConstMemberFunc();\n\n    a.TestVirtual(14);\n\n    int d = SimpleClass::TestStatic(12, 13);\n\n    return 0;\n}\n```\n\n这次需要分析的东西还是挺多的，我把几个需要带到分析过程中的问题罗列出来吧：\n1. 全局变量什么时候初始化\n2. 类的初始化器和普通的赋值有什么不同\n3. 成员变量的初始化顺序是什么\n4. 没有给初始化值的成员变量编译器会做什么操作\n5. 静态函数存放在什么地方，是否存放在类空间内部\n6. 静态成员变量又存放在什么地方，是否存放在类空间的内部\n7. 虚函数和普通成员函数有什么区别\n8. 普通成员函数和const成员函数有什么区别\n9. 静态函数和普通成员函数有什么区别\n10. 全局变量和局部变量编译器是怎么区分开的\n\n看了下真的是任重而道远，其实我已经做了很多压缩了，比如“静态成员变量和全局变量谁先被初始化”这个问题由于难度问题，没有把它列进来。\n\n那么我们先挑个最恶心人的问题来吧，全局变量什么时候初始化。要想了解这个问题，最好的方法就是在类的构造函数处下一个断点，来，跟着我输入指令`bp HelloWorld2005!SimpleClass::SimpleClass`，然后回车。好吧，坑爹了，WinDBG认为这个断点有歧义，因为`SimpleClass`类有两个构造函数，所以它不知道给哪个构造函数下断点，哎，真是笨：\n{% asset_img SetConstructorBreakPoint.png 设置构造函数断点 %}\n\n没办法了，只能根据WinDBG给我们的提示，用构造函数的具体地址来设置断点，来输入`bp 00401140`，然后输入`g`继续执行代码，直到运行到断点处：\n{% asset_img HitConstructorBreakPoint.png 执行到断点处 %}\n\n这时我们只是想直到这个构造函数是谁调用过来的，那么我们就需要直到函数调用的堆栈，输入`kbn`回车即可：\n{% asset_img GlobalVarCallStack.png 全局变量构造时的调用堆栈 %}\n\n可以看到它是由一个叫做`_initterm`的函数调用过来的，上面的哪个`dynamic initializer for 'k'`可以先忽略，那个就是初始化全局变量k的地方，简单来说这个函数就对应了SimpleClass k(12)这句代码。那么我们现在要做的事情就是在_initterm这个函数调用的地方下一个断点。好了，按下`Ctrl+Shift+F5`重启程序，然后输入`bp MSVCR80D!_initterm`，输入`g`回车即可：\n{% asset_img InInitTermFunction.png 调用_initterm的地方 %}\n\n前面保存堆栈就不用看了，主要看下面这块\n```asm\nmov eax, dword ptr [ebp+8]\ncmp eax, dword ptr [ebp+0Ch]\njae MSVCR80D!_initterm+0x25\n```\n\n注意`ebp+8`指向了上一个堆栈的栈顶的第一个DWORD，`ebp+0Ch`指向了上一个堆栈栈顶的第二个DWORD，其实应该也是传递给`_initterm`函数的两个参数，这里只是比较这两个数值是否相等。这时肯定有人会问了，`cmp`比较之后的结果存放在哪里呢？当然是寄存器了，只是这个寄存器比较特殊，它叫标志寄存器，你平时在WinDBG中看不到这个寄存器，但是你可以通过按下`Alt+4`弹出一个罗列了所有寄存器的对话框：\n{% asset_img AllRegisters.png 所有的寄存器 %}\n\n确实相当多，不过这里我只介绍`cmp`会用到的，一个是进位标记`cf`（carry flag）和零位标记`zf`（zero flag）。`cmp`比较下来不过就是小中大三种结果，那么对应到标志寄存器上的表现如下：\n{% asset_img CmpResult.png cmp比较的结果 %}\n\n那么我们这里执行完`cmp`之后看到这两个寄存器的内容如下：\n{% asset_img AfterCmpOperation.png cmp执行之后寄存器的内容 %}\n\n我们再人肉比较一下这两个值吧：\n{% asset_img ActualValueForCmp.png 两个值的具体内容 %}\n\n可以发现`ebp+8`的值小于`ebp+0Ch`的值，所以说`zf`应该是0，`cf`应该是1，对照寄存器的内容，怎么样，我没有忽悠你吧。\n\n下面是一条新的指令`jae MSVCR80D!_initterm+0x25`，当然其实我现在也记不住那么多指令，只能依靠谷歌和翻书。`jae`指令的意思是：基于无符号数的比较结果，如果大于等于就执行后面的跳转。而前面比较的结果是小于，所以不会执行后面的跳转，指令选择继续往下执行。同样的指令还有很多，我这里不想介绍太多，大家可以自行翻书。\n\n下面三条语句也执行了同样的操作\n```asm\nmov ecx, dword ptr [ebp+8]\ncmp dword ptr [ecx], 0\nje MSVCR80D!_initterm+0x1a\n```\n\n这里的意思也差不多，它先取`ebp+8`指向地址的值，把它放到ecx中，然后在将这个值指向的值与0进行比较，如果等于0的话就跳转到`MSVCR80D!_initterm+0x1a`处执行。这里具体比较内容和结果自己去探索，我这里就看到它执行了后面的跳转。然后他又执行了下面的这段代码：\n```asm\nmov ecx, dword ptr [ebp+8]\nadd ecx, 4\njmp MSVCR80D!_initterm+0x3\n```\n\n它又一次取了`ebp+8`的值，并把它加4,所以更加肯定了`ebp+8`存放的是一个指针，这里只是对指针做了一个偏移操作。然后将`ecx`的值又放回了`ebp+8`指向的地址，接着跳转到了`_initterm+0x3`的位置，也就是下面这段代码：\n{% asset_img InitTermJmpBackToFuncHead.png 跳转回去开头 %}\n\n好了，整个函数就只剩下一段汇编没有分析了：\n```asm\nmov edx, dword ptr [ebp+8]\nmov eax, dword ptr [edx]\ncall eax\n```\n\n看到`call eax`第一反应应该就是这肯定是调用了一个函数，只是这个函数可能是通过参数传递进来的。这里继续引用`ebp+8`指向的值，放到edx中，然后把这个值指向的内存内容放到eax中，而这个值则正好是一个函数的地址。\n\n因此我有理由相信，这个函数接受两个参数，第一个是`ebp+8`,第二个是`ebp+0Ch`，并且从`ebp+8`到`ebp+0Ch`这个范围中存放了一系列的函数的地址，而这个函数做的事情就是不断地循环，如果遇到不是空指针的就调用这个函数。我把这段函数具体化为C++代码，应该大致如下：\n```cpp\nvoid _initterm(void* from, void* to)\n{\n    while (from < to)\n    {\n        if (*from != NULL)\n        {\n            functype func = (functype)*from;\n            func();\n        }\n\n        from++;\n    }\n}\n```\n\n其中functype我也不知道是什么类型，所以就遗留着吧。搞定了这个函数的含义，下面就好办了，就是不断地尝试进入函数体的内部，直到调用到了`SimpleClass`的构造函数位置。\n\n那我们调用到`eax`中函数的时候，就用F11调试进入函数内部（记得用`kbn`看下调用堆栈，以防调试错了地方，因为一共会调用两次`_initterm`函数，我们需要分析的是`__tmainCRTStartup`调用过来的`_initterm`函数）\n\n第一次调进来好像是调到了一个叫做`pre_cpp_init`的函数中了，这货居然还是HelloWorld2005中的函数，看看也无妨，可以更加了解一下运行的机制：\n{% asset_img HelloWorld2005PreCppInit.png pre_cpp_init函数 %}\n\n国际惯例，前面两句保存堆栈，但是注意这里其实少了我们以前看到的那些`sub esp 120h`这样的语句，额，可能是没有声明局部变量？或者是被优化掉了？以后讨论。然后它将一个叫做`_RTC_Terminate`的函数进行压栈，这个函数我查了好久都没有找到是干嘛的，有熟悉的可以告诉我一下(cloudy064@gmail.com)，或者等我加了评论模块再说，万分感谢。\n\n然后就是熟悉的两个个操作：\n```asm\ncall HelloWorld2005!atexit\nadd esp, 4\n```\n\n现在我们应该会知道之前压栈的`_RTC_Terminate`是一个`atexit`需要用到的参数，然后`pre_cpp_init`调用`atexit`函数，返回之后，利用`add esp, 4`清除临时变量，恢复堆栈。这里我就不进去`atexit`里面看了，我觉得会吐血，以后安排补丁文章来搞定这些一直没有分析的问题吧。\n\n继续看后面几句：\n```asm\nmov eax, dword ptr [HelloWorld2005!_newmode]\nmov dword ptr [HelloWorld2005!startinfo], eax\npush offset HelloWorld2005!startinfo\n```\n\n依据以前的经验，这里的`HelloWorld2005!_newmode`和`HelloWorld2005!startinfo`应该是`HelloWorld2005`里面的全局变量，虽然我不知道它是在哪里初始化的，但是不妨碍我们继续分析。我们可以通过`dv`（dump value）指令来查看这两个变量的内容：\n{% asset_img PreCppInitDvResult.png 用dv查看结果 %}\n\n发现我们只能看到startinfo的类型信息，却得不到它的内容，这个时候应该介绍新指令:`dt`（dump type），这个指令可以在变量类型为符合类型（比如结构体）的时候发挥作用。利用`dt`指令查看到的结果如下：\n{% asset_img PreCppInitDtValueResult.png dt查看得到的结果%}\n\n恩，这下能够看到它的成员变量的值这些信息了。额，你还不放心，还想看它的结构体内部变量是怎么分布的？没问题，用`dt _startupinfo`来查看就行了，这里我就不贴出来结果了，大家自己试验吧。\n\n所以这里就只是初始化了全局变量`startinfo`，最后一句`push offset HelloWorld2005!startinfo`你就可以把它理解为将`startinfo`的地址入栈了。将一个变量或者地址进行入栈，在没有优化的情况下，十有八九就是准备调用函数了。\n\n接着看下面的语句中，有连续好几个压栈的操作，然后接一个函数调用，最后恢复堆栈：\n```asm\nmov ecx, dword ptr [HelloWorld2005!_dowildcard]\npush ecx\npush offset HelloWorld2005!envp\npush offset HelloWorld2005!argv\npush offset HelloWorld2005!argc\ncall dword ptr [HelloWorld2005!_imp____getmainargs]\nadd esp, 14h\n```\n\n当然这些也全部都是全局变量了，不过第一个是将`_dowildcard`这个变量压栈，下面三个是将`envp`,`argv`,`argc`的内存地址进行压栈，所以你可以把`_imp____getmainargs`函数看做是下面这个签名：\n```cpp\nvoid _imp____getmainargs(\n    void* argc, \n    void* argv, \n    void* envp, \n    int _dowildcard,\n    _startupinfo* startinfo)\n{\n//.......\n}\n```\n\n关于函数调用的参数顺序和入栈顺序以后会安排专题详细分析，这里就当参数是这个顺序吧。而这个函数从名字上来看就是用来初始化参数信息的，和我们的全局变量没有多大的关系，所以就不进去继续看了，直接跳过。\n\n往下再看几行：\n```asm\nmov dword ptr [HelloWorld2005!argret], eax\ncmp dword ptr [HelloWorld2005!argret], 0\njge HelloWorld2005!pre_cpp_init+0x56\n```\n\n这里eax应该存放了刚刚调用`_imp____getmainargs`的返回值，之所以把它存放到另外一个全局变量里面，恩，可能是因为没有优化吧= =。这三句概括起来就是将返回值和0进行比较，如果返回值大于等于0（`jge`的意思就是jump if greater than or equal），那么就跳转到`pre_cpp_init+0x56`的位置；否则就继续执行。\n\n还剩下最后一段代码了：\n```asm\npush 8\ncall HelloWorld2005!amsg_exit\nadd esp, 4\n```\n\n这段应该是强迫程序退出的一个函数吧，8是错误码。意思就是说，如果上面的返回值小于0，那么肯定就是程序出现了什么错误了，然后执行到这里就让程序已错误码8的结果退出。\n\n好了，我们整理一下这个`pre_cpp_init`函数，其实可以用C++代码表示成下面这个样子：\n```cpp\nvoid pre_cpp_init()\n{\n    atexit(&_RTC_Terminate);\n    startinfo.newmode = _newmode;\n    argret = _imp____getmainargs(&argc, &argv, &envp, _dowildcard, &startinfo);\n    if (argret >= 0)\n        return;\n\n    amsg_exit(8);\n}\n```\n\n虽然可能和真实实现会有不一样，但是大致的流程应该不会错的。\n\n好吧，分析了半天我们还是没有找到调用`SimpleClass`构造函数的地方。不要急嘛，函数返回了继续看下去。\n\n第二次进入`call eax`，我们这个时候就看到了全局变量k的初始化了，代码如下所示：\n{% asset_img DynamicInitializerForK.png 初始化全局变量K %}\n\n又是人肉分析代码的艰辛历程，前面一大坨就是我们以前熟悉的，先保存上一个堆栈以及寄存器的内容，然后分配一个`30h`大小局部变量堆栈空间给当前函数（我也不知道函数名叫啥），然后将这块内存初始化为`0xCCCCCCCC`，下面的这段代码才是真正执行构造函数的地方：\n```cpp\npush 0Ch\nmov ecx, offset HelloWorld2005!k\ncall HelloWorld2005!SimpleClass::SimpleClass\n```\n\n这里其实可以看到在调用构造函数之前，编译器已经确定好全局变量`k`应该存放在什么位置了，而我们调用构造函数只是初始化`k`这块内存区域而已。这里讲12这个数进行压栈，然后将`k`的地址保存到`ecx`寄存器中，我猜ecx保存就一定是this指针！不然构造函数不知道初始化哪片内存。最后我们调用了构造函数。因为这里二进制代码已经写死了调用函数的地址，而不是通过函数名进行调用，所以不存在函数名有二义性的问题。\n\n我们进入到了构造函数里面，看到如下的代码：\n{% asset_img SimpleClassConstructorCode.png SimpleClass的构造函数 %}\n\n前面里面有一个不同，那就是多了一句`push ecx`，要知道后面再执行初始化堆栈的时候，需要使用到`ecx`这个计数器的，而ecx之前保存了this指针的地址，所以说需要先将`ecx`的值压栈进行保存，这样才能保证this指针地址不会丢失。然后继续往下看，看到`pop ecx`处，这里就是执行一次出栈操作，恢复`ecx`中原有的this指针。\n\n接着函数执行了`mov dword ptr [ebp-8], ecx`这句话，要知道在没有开优化的情况下，`ebp-8`这个位置是第一个局部变量声明的位置，也就是说其实构造函数中隐藏了一个定义变量的操作`SimpleClass* this = ecx;`，所以现在大家知道this指针是怎么来的了吗？它保存在哪里也应该知道了吧。\n\n继续看，下面一句话是`mov eax, dword ptr [ebp-8]`，我要掀桌了（(╯‵□′)╯︵┻━┻），好好一个this指针到处传，就不能一步到位么。把桌子摆好，努力思考一下，我觉得将this指针放在局部变量的位置，可能是为了将this指针保存起来，能够随时获取，因为寄存器是经常变化的，一堆操作需要用到寄存器。而把this指针放到寄存器中，则是因为对于`dword ptr`这种类似于析址操作只支持寄存器的。哎，Intel的指令就是这么麻烦（我感到背后有一股杀气）。\n\n接下来就开始进行调用初始化器以及调用函数体了：\n```asm\nmov dword ptr [eax], offset HelloWorld2005!SimpleClass::`vftable'\n```\n\n= =天哪，忘记了还有这货，这个看名字就知道是SimpleClass的虚函数表，因为我这里声明了一个虚函数，所以说这个类就会有一个虚函数表来承载虚函数的地址。而这个虚函数表就存放在this指针的基地址的位置。我们现在可以简单瞄一眼虚函数表，利用`dd eax`可以看到this指针指向内存的内容：\n{% asset_img SimpleClassThisPointToMemory.png this指针指向的内容 %}\n\n第一个值就是虚表的地址了，至于虚拟地址里面存放了什么，我现在还不想研究，等真正讲到虚函数的时候再说吧。\n\n然后继续往下看：\n```asm\nmov eax, dword ptr [ebp-8] ;取this指针\nmov ecx, dword ptr [ebp+8] ;获取最后一个压栈的参数，这里只有一个就是12\nmov dword ptr [eax+4], ecx ;给this指针偏移四个字节的地址进行赋值\n```\n\n前面两个都比较好理解吧，就是单纯的取值，对于最后一个的话，恩，看一看SimpleClass的内存分布大家应该就了解了，输入`dt SimpleClass`即可：\n{% asset_img DtSimpleClass.png SimpleClass的内存分布 %}\n\n可以很容易看到，对于一个具体的`SimpleClass`实例，它的基地址存放了虚函数表指针，偏移4字节的地方存放了`a`变量的值，偏移8字节的地方存放了`b`变量的值。额最后一个就太奇怪了，它给我们的信息是它存放在一个固定的地址，并且它的类型是(null)，明明是`char*`好吧。所以它的内存结构用图来表示的话如下：\n{% asset_img SimpleClassMemoryMap.png SimpleClass的内存结构图 %}\n\n最后那个静态变量不管它，讲到它的时候再说。\n\n所以上面的那句`mov dword ptr [eax+4], ecx`其实就是给成员变量`a`进行赋值，所以这三句其实就对应了代码中的初始化器`:a(m)`了。\n\n然后在往下看两行：\n```asm\nmov eax, dowrd ptr [ebp-8]\nmov dword ptr [eax+8], 3\n```\n\n不用我说大家也明白了，这个就是给成员变量`b`进行赋值。\n\n那么这么一看，其实初始化器和在构造函数体中对变量进行初始化并没有什么区别啊。当然有！最明显的区别就是初始化的顺序，这个顺序后面会用多个例子来进行试验，这里先不说；另外一个区别就是初始化器调用的是构造函数，而函数体中的初始化调用的是赋值操作符，因为这里都是`int`，所以无法看出区别。\n\n好了分析完成构造函数了。等等，最后那个`ret`后面怎么多了个4，以前都是没有的啊。嗯嗯，这里的4只是恢复堆栈用的，这个具体会在函数调用约定里面详细讲解。这里只要知道`ret 4`其实就相当于下面两条指令就行了:\n```asm\nret\nadd esp, 4\n```\n\n---\n\n画一个分隔线，只是因为前面讲的太多了，其实这里还有一个问题没有讲清楚，就是那个`dynamic initializer for 'k'`的地址是谁传递过来的，这又是一个坑，还是得填啊。但是我现在不想填，好麻烦= =，留着以后想了解main函数之前做了什么的时候再来看这个坑吧，恩。（我中途发现了这样一个东西[http://wiki.osdev.org/Visual_C%2B%2B_Runtime](http://wiki.osdev.org/Visual_C%2B%2B_Runtime)，打开有兴趣可以参考参考）\n\n然后不知不觉我们就来到了`main`函数调用的地方：\n{% asset_img ThePlaceWhereCallMain.png main函数调用的地放 %}\n\n我们仍然可以看一下`main`函数它完整的函数签名是什么：\n```asm\nmov eax, dword ptr [HelloWorld2005!envp]\npush eax\n\nmov ecx, dword ptr [HelloWorld2005!argv]\npush ecx\n\nmov edx, dword ptr [HelloWorld2005!argc]\npush edx\n\ncall HelloWorld2005!main \n```\n\n可以看到它其实传给main函数三个参数，分别是`argc`,`argv`,`envp`，至于具体什么意思，自己百度一下啦。\n\n现在我们进入到`main`函数的主体，并定位到第一句代码执行的位置，如下：\n{% asset_img MainSimpleClassJ=233.png main函数执行的第一句代码 %}\n\n准备数据没啥好说的，将`0E9h`(也就是233)进行压栈，然后将变量`j`的栈上地址，也就是this指针的值传递给`SimpleClass`的构造函数：\n```asm\npush 0E9h\nlea ecx, [ebp-1Ch]\ncall HelloWorld2005!SimpleClass::SimpleClass\n```\n\n这里唯一的问题就是为什么`j`是保存在那个地址上，我们来算嘛。首先我们根据上面各种语句，可以得到当前函数局部堆栈的内存分布图如下：\n{% asset_img MainSimpleClassJ=233Stack.png 此时的堆栈情况 %}\n\n我把函数参数的区域标为黄色，分配给变量j的内存标为红色。好吧，这样看来没优化的时候，系统真的是有浪费4字节内存的习惯。\n\n然后代码就开始调用`SimpleClass`构造函数了，如此看来单参数构造函数的调用，下面两种调用方法所生成的汇编代码是相同的（此处只针对了系统内置类型，结构体的之后再验证）：\n```cpp\nSimpleClass a(10);\nSimpleClass b = 10;\n```\n\n构造函数已经详细分析过了，所以就不进去继续看了。\n\n看下一句代码`SimpleClass k = ::k;`，这个从C++的层面来看的话，他应该调用我写的拷贝构造函数才对，那么我们来看对应的汇编代码吧：\n```asm\npush offset HelloWorld2005!k\nlea ecx, [ebp-30h]\ncall HelloWorld2005!SimpleClass::SimpleClass\n```\n\n额，它好像没有对局部变量和全局变量进行直接的区分，因为，编译器TM就没有给局部变量取名字！！！局部变量是没有符号的。好吧，我的哪个局部变量和全局变量什么区别的问题就不是问题了。至于分配内存我也就不说了。这里主要就说明一下`SimpleClass`的拷贝构造函数好了：\n{% asset_img SimpleClassCopyConstructorCode.png 拷贝构造函数 %}\n\n我们直接跳到`004011b3`这一行\n```asm\nmov eax, dword ptr [ebp-8]\nmov dword ptr [eax], offset HelloWorld2005!SimpleClass::`vftable'\n\nmov eax, dword ptr [ebp-8] ; 拿到this指针\nmov ecx, dword ptr [ebp+8] ; 拿到全局变量k的地址\nmov edx, dword ptr [ecx+4] ; edx = k.a\nmov dword ptr [eax+4], edx ; this.a = edx\n\nmov eax, dword ptr [ebp-8] ; 拿到this指针\nmov ecx, dword ptr [ebp+8] ; 拿到全局变量k的地址\nmov edx, dword ptr [ecx+8] ; edx = k.b\nmov dword ptr [eax+8], edx ; this.b = edx\n\nmov eax, dword ptr [ebp-8]\n```\n\n= =好复杂的感觉，一句一句分析，此时`ebp-8`中保存的就是this指针的值。然后前面两句的意思就是初始化this指针的虚函数表，没有任何疑问。\n\n接下来的四句，因为在调用拷贝构造函数之前调用了一句`push offset HelloWorld2005!k`，所以现在上一个堆栈的顶部保存的其实就是全局变量`k`的地址。所以这里`mov ecx, dword ptr [ebp+8]`就是讲全局变量`k`的地址保存到`ecx`寄存器中。所以有了上面的注释之后基本上就不需要我讲解了。拷贝构造函数搞定！\n\n再往下看`Simple Class a(k)`的汇编代码：\n```asm\nlea     eax, [ebp-30h]  ; 将局部变量k的地址保存到eax\npush    eax             ; 将eax的值压栈\nlea     ecx, [ebp-44h]  ; 分配局部变量内存，从ebp-44h开始的12个字节\ncall    HelloWorld2005!SimpleClass:SimpleClass  ;调用拷贝构造函数\n```\n\n不解释，依然和上面的构造过程一模一样。所以其实拷贝构造函数的调用下面两种方式也是完全相同的：\n```cpp\nSimpleClass a = k;\nSimpleClass b(k);\n```\n\n---\n\n一个华丽的分割线之后，开始看函数的调用，我们这里主要是看各个函数之间的区别，对于函数主体，我们其实并不关注，看前面两个函数:\n{% asset_img MainCompareTestAndTestConst.png 比较const和非const函数 %}\n\n他们几乎完全一样，通过ecx传递指针，然后调用对应的函数，const函数最后的const修饰符可以说是没有起到任何作用，要知道这个const是用来修饰this指针的，也就是说const成员函数中你不能对this指针指向的成员进行修改。但是就如同我上一章里面说的，const只是从语义上让你能够在编译期就能发现问题，要知道编译期找bug的代价比运行期找bug代价小很多的。\n\n这一次我们不去看它真正的实现，我们不如自己来写一个TestMemberFunc出来？\n```asm\npush ebp        ; 保存上一个堆栈的基地址\nmov ebp, esp    ; 确定新的堆栈基地址\nsub esp, 0C0h   ; 分配足够的堆栈，其实我觉得这里没有用到堆栈啊，可以不用这一步\npush xxx        ; 忘记是啥\npush xxx        ; 忘记是啥\npush xxx        ; 忘记是啥\npush ecx        ; 保存this指针\n; 初始化这块堆栈区域，忘记什么命令了\npop ecx         ; 恢复this指针\nmov dword ptr [ebp-8], ecx ; 将this指针保存到栈底\nmov eax, dword ptr [ebp-8] ; 将this指针拷贝到eax中\nmov ecx, dword ptr [eax+4] ; 拿到a的值\nadd ecx, dword ptr [eax+8] ; 加上b的值\nmov dword ptr [eax+4], ecx ; 将得到的和保存到a的位置中\npop xxx\npop xxx\npop xxx \nmov esp, ebp\npop ebp\nret\n```\n\n我觉得差不多应该是这个样子，不管那么多了。这个只是一个我自己想做的一个练习而已，继续往下面执行。\n\n接着就是虚函数，汇编代码如下图所示:\n{% asset_img MainCallTestVirtual.png 调用虚函数 %}\n\n好像我还是觉得没什么特别的地方，通过`push`传递参数，通过`ecx`传递this指针，进去函数实现的地方看也和普通函数的调用没有什么区别。好吧，可能要等到用到继承的时候才会出现区别吧。\n\n所以在这种没有继承的情况下，成员函数，const成员函数和虚函数之间完全是没有任何区别的。\n\n看完最后一个`int d = SimpleClass::TestStatic(12, 13)`就可以解放了，相信看了汇编代码的人会觉得，这个函数是最没有技术含量的了：\n{% asset_img MainCallTestStatic.png 调用静态函数 %}\n\n简单来说就和普通的全局函数是一模一样的，唯一的区别就是静态函数前面要加一个类名加一个域操作符。\n\n啊！终于都分析完了。“诶，好像还有一个静态成员变量你还没说吧？”，我。。。。。。你这个同学记性能不能放差一点，我现在好累了= =\n\n好的，之前我们用`dt`命令查看了`SimpleClass`的内存结构，我们再看一下：\n{% asset_img DtSimpleClass.png SimpleClass的内存结构 %}\n\n发现str的地址并不是一个偏移量，而是一个固定的地址`00406000`，记住这个是`str`变量保存的地址，而不是`\"joker\"`这个字符串的地址。如果要确定它指向字符串的地址，那么就输入`dd 0040600`：\n{% asset_img dd00406000.png str指向的内存内容 %}\n\n拿到第一个值，这个值就是`\"joker\"`存放的地址了，继续输入`da 0040412c`（`da`的意思应该是dump ansi）：\n{% asset_img da0040412c.png 查看str指向的字符串 %}\n\n好吧，既然讲到静态变量了，那么我问大家一个问题，静态变量存放在程序的什么区段：\n1. text段\n2. rdata段\n3. data段\n4. rsrc段\n\n能搞明白么？好吧，为了寻找这个问题的答案，我们不妨打印出这个程序所有的头部信息吧。利用`dh! -s HelloWorld2005`（dh的意思是表示dump header,-s表示只展示区段信息）\n{% asset_img DumpHelloWorldHeaders.png 程序的头部区段信息 %}\n\n但是这里所有的数据都是相对于HelloWorld2005.exe最开始的地方，\n{% asset_img lmvmHelloWorld2005.png HelloWorld2005.exe在程序中的真实地址范围 %}\n\n那这样的话我们就能确认到各个区段的实际内存范围：\n```\ntext段       00401000~0040313C\nrdata段      00404000~0040515C\ndata段       00406000~00406418\nrsrc段       00407000~004071B4\n```\n\n先来看`str`变量的地址，是`00406000`，它好像正好就是data段的起始地址，毫无疑问了那就，静态成员变量被存放在data段中。\n\n我们再来看看`\"joker\"`这个字符串，它的地址是`0040412C`，而这个地址落在了rdata段中。我们不妨把rdata段中的所有的字符串都列举出来，眼见为实。我们可以用`s -sa HelloWorld2005+4000 L115C`命令来搜索这个rdata内存区间里面所有的ANSI字符串，我这里输出的结果如下：\n{% asset_img s-saHelloWorld2005+4000L115C.png rdata段中的所有ANSI字符串 %}\n\n毫无悬念你可以找到`\"joker\"`这个字符串。\n\n好了这些就把所有的东西都讲完了，遗留下来的坑，下一个章节会填完。大家慢慢消化吧，拜拜！\n\n## 回顾：\n\n### 关于WinDBG\n1. `dv`命令用于查看局部变量，如果想查看全局变量记得前面加上`模块名!`\n2. `dt`命令用于查看结构体的分布情况，也可以以结构体来解析对应的内存\n3. `!dh`命令可以用于查看模块的头部信息，具体参数请自行补充\n4. `s`命令可以用于搜索内存，具体参数请自行补充\n\n\n### 关于汇编\n1. `ret 4`指令在返回的同时，也会将栈顶指针加4（清空堆栈）\n2. 在调用类函数的时候，包括构造函数，通过`ecx`寄存器传递this指针，并在函数内部，将this指针的值保存在`ebp-8`的位置\n\n\n### 关于C++\n1. 全局变量在是main函数之前初始化的\n2. 全局变量的内存是在编译期就已经被决定了的\n3. 类的虚函数表是在构造函数中进行初始化的\n4. 虚函数表放在this指针指向的基地址位置\n5. const成员函数和非const成员函数在实现上并没有任何不同，只是便于编译器能够在编译期就把问题抛出来\n6. 在没有继承的情况下，成员函数和虚函数并没有什么不同\n7. 静态函数和普通函数也没有什么不同，只是静态函数调用的时候需要加上类名加上域作用符\n8. 静态成员变量存放在`data`区段\n9. 常量字符串存放在`rdata`区段\n10. main函数的完整签名是int main(int argc, char** argv, char** envp);\n11. 函数入口并不存放在类的结构中","source":"_posts/windbg/windbg-chapter3.md","raw":"---\ntitle: WinDBG观世界（三）\ndate: 2016-04-21 00:48:07\ncategories: windbg\ntags: [windbg,disassembly,c++]\n---\n\n## 导言\n已经介绍了函数和结构体的内容了，我想这次应该可以大致研究一下类相关的知识了。不过这次照例还是没有release版本的分析内容，而且这次讲类也只是讲解基础知识，对于类的高级用法，比如继承、成员函数指针这些都留到以后去研究。那么进入正题吧（貌似导言越来越短了，我在想以后要不要去掉）。\n<!--more-->\n## 给结构体加上一点控制！再加上一点函数！\n国际惯例，先贴分析的代码：\n```cpp\nclass SimpleClass\n{\npublic:\n    SimpleClass(int m)\n        : a(m)\n    {\n        b = 3;\n    }\n\n    SimpleClass(const SimpleClass& rhs)\n        : a(rhs.a)\n        , b(rhs.b)\n    {\n\n    }\n\n    ~SimpleClass()\n    {\n\n    }\n\npublic:\n    void TestMemberFunc()\n    {\n        a += b;\n    }\n\n    void TestConstMemberFunc() const\n    {\n        int m = a;\n        m += b;\n    }\n\npublic:\n    virtual void TestVirtual(int m)\n    {\n        a += m;\n    }\n\npublic:\n    static int TestStatic(int m, int n)\n    {\n        return m + n;\n    }\n\nprivate:\n    int a;\n    int b;\n\nprivate:\n    static const char* str;\n};\n\nconst char* SimpleClass::str = \"joker\";\n\nSimpleClass k(12);\n\nint main(int argc, char** argv)\n{\n    SimpleClass j = 233;\n    SimpleClass k = ::k;\n    SimpleClass a(k);\n\n    k.TestMemberFunc();\n    k.TestConstMemberFunc();\n\n    a.TestVirtual(14);\n\n    int d = SimpleClass::TestStatic(12, 13);\n\n    return 0;\n}\n```\n\n这次需要分析的东西还是挺多的，我把几个需要带到分析过程中的问题罗列出来吧：\n1. 全局变量什么时候初始化\n2. 类的初始化器和普通的赋值有什么不同\n3. 成员变量的初始化顺序是什么\n4. 没有给初始化值的成员变量编译器会做什么操作\n5. 静态函数存放在什么地方，是否存放在类空间内部\n6. 静态成员变量又存放在什么地方，是否存放在类空间的内部\n7. 虚函数和普通成员函数有什么区别\n8. 普通成员函数和const成员函数有什么区别\n9. 静态函数和普通成员函数有什么区别\n10. 全局变量和局部变量编译器是怎么区分开的\n\n看了下真的是任重而道远，其实我已经做了很多压缩了，比如“静态成员变量和全局变量谁先被初始化”这个问题由于难度问题，没有把它列进来。\n\n那么我们先挑个最恶心人的问题来吧，全局变量什么时候初始化。要想了解这个问题，最好的方法就是在类的构造函数处下一个断点，来，跟着我输入指令`bp HelloWorld2005!SimpleClass::SimpleClass`，然后回车。好吧，坑爹了，WinDBG认为这个断点有歧义，因为`SimpleClass`类有两个构造函数，所以它不知道给哪个构造函数下断点，哎，真是笨：\n{% asset_img SetConstructorBreakPoint.png 设置构造函数断点 %}\n\n没办法了，只能根据WinDBG给我们的提示，用构造函数的具体地址来设置断点，来输入`bp 00401140`，然后输入`g`继续执行代码，直到运行到断点处：\n{% asset_img HitConstructorBreakPoint.png 执行到断点处 %}\n\n这时我们只是想直到这个构造函数是谁调用过来的，那么我们就需要直到函数调用的堆栈，输入`kbn`回车即可：\n{% asset_img GlobalVarCallStack.png 全局变量构造时的调用堆栈 %}\n\n可以看到它是由一个叫做`_initterm`的函数调用过来的，上面的哪个`dynamic initializer for 'k'`可以先忽略，那个就是初始化全局变量k的地方，简单来说这个函数就对应了SimpleClass k(12)这句代码。那么我们现在要做的事情就是在_initterm这个函数调用的地方下一个断点。好了，按下`Ctrl+Shift+F5`重启程序，然后输入`bp MSVCR80D!_initterm`，输入`g`回车即可：\n{% asset_img InInitTermFunction.png 调用_initterm的地方 %}\n\n前面保存堆栈就不用看了，主要看下面这块\n```asm\nmov eax, dword ptr [ebp+8]\ncmp eax, dword ptr [ebp+0Ch]\njae MSVCR80D!_initterm+0x25\n```\n\n注意`ebp+8`指向了上一个堆栈的栈顶的第一个DWORD，`ebp+0Ch`指向了上一个堆栈栈顶的第二个DWORD，其实应该也是传递给`_initterm`函数的两个参数，这里只是比较这两个数值是否相等。这时肯定有人会问了，`cmp`比较之后的结果存放在哪里呢？当然是寄存器了，只是这个寄存器比较特殊，它叫标志寄存器，你平时在WinDBG中看不到这个寄存器，但是你可以通过按下`Alt+4`弹出一个罗列了所有寄存器的对话框：\n{% asset_img AllRegisters.png 所有的寄存器 %}\n\n确实相当多，不过这里我只介绍`cmp`会用到的，一个是进位标记`cf`（carry flag）和零位标记`zf`（zero flag）。`cmp`比较下来不过就是小中大三种结果，那么对应到标志寄存器上的表现如下：\n{% asset_img CmpResult.png cmp比较的结果 %}\n\n那么我们这里执行完`cmp`之后看到这两个寄存器的内容如下：\n{% asset_img AfterCmpOperation.png cmp执行之后寄存器的内容 %}\n\n我们再人肉比较一下这两个值吧：\n{% asset_img ActualValueForCmp.png 两个值的具体内容 %}\n\n可以发现`ebp+8`的值小于`ebp+0Ch`的值，所以说`zf`应该是0，`cf`应该是1，对照寄存器的内容，怎么样，我没有忽悠你吧。\n\n下面是一条新的指令`jae MSVCR80D!_initterm+0x25`，当然其实我现在也记不住那么多指令，只能依靠谷歌和翻书。`jae`指令的意思是：基于无符号数的比较结果，如果大于等于就执行后面的跳转。而前面比较的结果是小于，所以不会执行后面的跳转，指令选择继续往下执行。同样的指令还有很多，我这里不想介绍太多，大家可以自行翻书。\n\n下面三条语句也执行了同样的操作\n```asm\nmov ecx, dword ptr [ebp+8]\ncmp dword ptr [ecx], 0\nje MSVCR80D!_initterm+0x1a\n```\n\n这里的意思也差不多，它先取`ebp+8`指向地址的值，把它放到ecx中，然后在将这个值指向的值与0进行比较，如果等于0的话就跳转到`MSVCR80D!_initterm+0x1a`处执行。这里具体比较内容和结果自己去探索，我这里就看到它执行了后面的跳转。然后他又执行了下面的这段代码：\n```asm\nmov ecx, dword ptr [ebp+8]\nadd ecx, 4\njmp MSVCR80D!_initterm+0x3\n```\n\n它又一次取了`ebp+8`的值，并把它加4,所以更加肯定了`ebp+8`存放的是一个指针，这里只是对指针做了一个偏移操作。然后将`ecx`的值又放回了`ebp+8`指向的地址，接着跳转到了`_initterm+0x3`的位置，也就是下面这段代码：\n{% asset_img InitTermJmpBackToFuncHead.png 跳转回去开头 %}\n\n好了，整个函数就只剩下一段汇编没有分析了：\n```asm\nmov edx, dword ptr [ebp+8]\nmov eax, dword ptr [edx]\ncall eax\n```\n\n看到`call eax`第一反应应该就是这肯定是调用了一个函数，只是这个函数可能是通过参数传递进来的。这里继续引用`ebp+8`指向的值，放到edx中，然后把这个值指向的内存内容放到eax中，而这个值则正好是一个函数的地址。\n\n因此我有理由相信，这个函数接受两个参数，第一个是`ebp+8`,第二个是`ebp+0Ch`，并且从`ebp+8`到`ebp+0Ch`这个范围中存放了一系列的函数的地址，而这个函数做的事情就是不断地循环，如果遇到不是空指针的就调用这个函数。我把这段函数具体化为C++代码，应该大致如下：\n```cpp\nvoid _initterm(void* from, void* to)\n{\n    while (from < to)\n    {\n        if (*from != NULL)\n        {\n            functype func = (functype)*from;\n            func();\n        }\n\n        from++;\n    }\n}\n```\n\n其中functype我也不知道是什么类型，所以就遗留着吧。搞定了这个函数的含义，下面就好办了，就是不断地尝试进入函数体的内部，直到调用到了`SimpleClass`的构造函数位置。\n\n那我们调用到`eax`中函数的时候，就用F11调试进入函数内部（记得用`kbn`看下调用堆栈，以防调试错了地方，因为一共会调用两次`_initterm`函数，我们需要分析的是`__tmainCRTStartup`调用过来的`_initterm`函数）\n\n第一次调进来好像是调到了一个叫做`pre_cpp_init`的函数中了，这货居然还是HelloWorld2005中的函数，看看也无妨，可以更加了解一下运行的机制：\n{% asset_img HelloWorld2005PreCppInit.png pre_cpp_init函数 %}\n\n国际惯例，前面两句保存堆栈，但是注意这里其实少了我们以前看到的那些`sub esp 120h`这样的语句，额，可能是没有声明局部变量？或者是被优化掉了？以后讨论。然后它将一个叫做`_RTC_Terminate`的函数进行压栈，这个函数我查了好久都没有找到是干嘛的，有熟悉的可以告诉我一下(cloudy064@gmail.com)，或者等我加了评论模块再说，万分感谢。\n\n然后就是熟悉的两个个操作：\n```asm\ncall HelloWorld2005!atexit\nadd esp, 4\n```\n\n现在我们应该会知道之前压栈的`_RTC_Terminate`是一个`atexit`需要用到的参数，然后`pre_cpp_init`调用`atexit`函数，返回之后，利用`add esp, 4`清除临时变量，恢复堆栈。这里我就不进去`atexit`里面看了，我觉得会吐血，以后安排补丁文章来搞定这些一直没有分析的问题吧。\n\n继续看后面几句：\n```asm\nmov eax, dword ptr [HelloWorld2005!_newmode]\nmov dword ptr [HelloWorld2005!startinfo], eax\npush offset HelloWorld2005!startinfo\n```\n\n依据以前的经验，这里的`HelloWorld2005!_newmode`和`HelloWorld2005!startinfo`应该是`HelloWorld2005`里面的全局变量，虽然我不知道它是在哪里初始化的，但是不妨碍我们继续分析。我们可以通过`dv`（dump value）指令来查看这两个变量的内容：\n{% asset_img PreCppInitDvResult.png 用dv查看结果 %}\n\n发现我们只能看到startinfo的类型信息，却得不到它的内容，这个时候应该介绍新指令:`dt`（dump type），这个指令可以在变量类型为符合类型（比如结构体）的时候发挥作用。利用`dt`指令查看到的结果如下：\n{% asset_img PreCppInitDtValueResult.png dt查看得到的结果%}\n\n恩，这下能够看到它的成员变量的值这些信息了。额，你还不放心，还想看它的结构体内部变量是怎么分布的？没问题，用`dt _startupinfo`来查看就行了，这里我就不贴出来结果了，大家自己试验吧。\n\n所以这里就只是初始化了全局变量`startinfo`，最后一句`push offset HelloWorld2005!startinfo`你就可以把它理解为将`startinfo`的地址入栈了。将一个变量或者地址进行入栈，在没有优化的情况下，十有八九就是准备调用函数了。\n\n接着看下面的语句中，有连续好几个压栈的操作，然后接一个函数调用，最后恢复堆栈：\n```asm\nmov ecx, dword ptr [HelloWorld2005!_dowildcard]\npush ecx\npush offset HelloWorld2005!envp\npush offset HelloWorld2005!argv\npush offset HelloWorld2005!argc\ncall dword ptr [HelloWorld2005!_imp____getmainargs]\nadd esp, 14h\n```\n\n当然这些也全部都是全局变量了，不过第一个是将`_dowildcard`这个变量压栈，下面三个是将`envp`,`argv`,`argc`的内存地址进行压栈，所以你可以把`_imp____getmainargs`函数看做是下面这个签名：\n```cpp\nvoid _imp____getmainargs(\n    void* argc, \n    void* argv, \n    void* envp, \n    int _dowildcard,\n    _startupinfo* startinfo)\n{\n//.......\n}\n```\n\n关于函数调用的参数顺序和入栈顺序以后会安排专题详细分析，这里就当参数是这个顺序吧。而这个函数从名字上来看就是用来初始化参数信息的，和我们的全局变量没有多大的关系，所以就不进去继续看了，直接跳过。\n\n往下再看几行：\n```asm\nmov dword ptr [HelloWorld2005!argret], eax\ncmp dword ptr [HelloWorld2005!argret], 0\njge HelloWorld2005!pre_cpp_init+0x56\n```\n\n这里eax应该存放了刚刚调用`_imp____getmainargs`的返回值，之所以把它存放到另外一个全局变量里面，恩，可能是因为没有优化吧= =。这三句概括起来就是将返回值和0进行比较，如果返回值大于等于0（`jge`的意思就是jump if greater than or equal），那么就跳转到`pre_cpp_init+0x56`的位置；否则就继续执行。\n\n还剩下最后一段代码了：\n```asm\npush 8\ncall HelloWorld2005!amsg_exit\nadd esp, 4\n```\n\n这段应该是强迫程序退出的一个函数吧，8是错误码。意思就是说，如果上面的返回值小于0，那么肯定就是程序出现了什么错误了，然后执行到这里就让程序已错误码8的结果退出。\n\n好了，我们整理一下这个`pre_cpp_init`函数，其实可以用C++代码表示成下面这个样子：\n```cpp\nvoid pre_cpp_init()\n{\n    atexit(&_RTC_Terminate);\n    startinfo.newmode = _newmode;\n    argret = _imp____getmainargs(&argc, &argv, &envp, _dowildcard, &startinfo);\n    if (argret >= 0)\n        return;\n\n    amsg_exit(8);\n}\n```\n\n虽然可能和真实实现会有不一样，但是大致的流程应该不会错的。\n\n好吧，分析了半天我们还是没有找到调用`SimpleClass`构造函数的地方。不要急嘛，函数返回了继续看下去。\n\n第二次进入`call eax`，我们这个时候就看到了全局变量k的初始化了，代码如下所示：\n{% asset_img DynamicInitializerForK.png 初始化全局变量K %}\n\n又是人肉分析代码的艰辛历程，前面一大坨就是我们以前熟悉的，先保存上一个堆栈以及寄存器的内容，然后分配一个`30h`大小局部变量堆栈空间给当前函数（我也不知道函数名叫啥），然后将这块内存初始化为`0xCCCCCCCC`，下面的这段代码才是真正执行构造函数的地方：\n```cpp\npush 0Ch\nmov ecx, offset HelloWorld2005!k\ncall HelloWorld2005!SimpleClass::SimpleClass\n```\n\n这里其实可以看到在调用构造函数之前，编译器已经确定好全局变量`k`应该存放在什么位置了，而我们调用构造函数只是初始化`k`这块内存区域而已。这里讲12这个数进行压栈，然后将`k`的地址保存到`ecx`寄存器中，我猜ecx保存就一定是this指针！不然构造函数不知道初始化哪片内存。最后我们调用了构造函数。因为这里二进制代码已经写死了调用函数的地址，而不是通过函数名进行调用，所以不存在函数名有二义性的问题。\n\n我们进入到了构造函数里面，看到如下的代码：\n{% asset_img SimpleClassConstructorCode.png SimpleClass的构造函数 %}\n\n前面里面有一个不同，那就是多了一句`push ecx`，要知道后面再执行初始化堆栈的时候，需要使用到`ecx`这个计数器的，而ecx之前保存了this指针的地址，所以说需要先将`ecx`的值压栈进行保存，这样才能保证this指针地址不会丢失。然后继续往下看，看到`pop ecx`处，这里就是执行一次出栈操作，恢复`ecx`中原有的this指针。\n\n接着函数执行了`mov dword ptr [ebp-8], ecx`这句话，要知道在没有开优化的情况下，`ebp-8`这个位置是第一个局部变量声明的位置，也就是说其实构造函数中隐藏了一个定义变量的操作`SimpleClass* this = ecx;`，所以现在大家知道this指针是怎么来的了吗？它保存在哪里也应该知道了吧。\n\n继续看，下面一句话是`mov eax, dword ptr [ebp-8]`，我要掀桌了（(╯‵□′)╯︵┻━┻），好好一个this指针到处传，就不能一步到位么。把桌子摆好，努力思考一下，我觉得将this指针放在局部变量的位置，可能是为了将this指针保存起来，能够随时获取，因为寄存器是经常变化的，一堆操作需要用到寄存器。而把this指针放到寄存器中，则是因为对于`dword ptr`这种类似于析址操作只支持寄存器的。哎，Intel的指令就是这么麻烦（我感到背后有一股杀气）。\n\n接下来就开始进行调用初始化器以及调用函数体了：\n```asm\nmov dword ptr [eax], offset HelloWorld2005!SimpleClass::`vftable'\n```\n\n= =天哪，忘记了还有这货，这个看名字就知道是SimpleClass的虚函数表，因为我这里声明了一个虚函数，所以说这个类就会有一个虚函数表来承载虚函数的地址。而这个虚函数表就存放在this指针的基地址的位置。我们现在可以简单瞄一眼虚函数表，利用`dd eax`可以看到this指针指向内存的内容：\n{% asset_img SimpleClassThisPointToMemory.png this指针指向的内容 %}\n\n第一个值就是虚表的地址了，至于虚拟地址里面存放了什么，我现在还不想研究，等真正讲到虚函数的时候再说吧。\n\n然后继续往下看：\n```asm\nmov eax, dword ptr [ebp-8] ;取this指针\nmov ecx, dword ptr [ebp+8] ;获取最后一个压栈的参数，这里只有一个就是12\nmov dword ptr [eax+4], ecx ;给this指针偏移四个字节的地址进行赋值\n```\n\n前面两个都比较好理解吧，就是单纯的取值，对于最后一个的话，恩，看一看SimpleClass的内存分布大家应该就了解了，输入`dt SimpleClass`即可：\n{% asset_img DtSimpleClass.png SimpleClass的内存分布 %}\n\n可以很容易看到，对于一个具体的`SimpleClass`实例，它的基地址存放了虚函数表指针，偏移4字节的地方存放了`a`变量的值，偏移8字节的地方存放了`b`变量的值。额最后一个就太奇怪了，它给我们的信息是它存放在一个固定的地址，并且它的类型是(null)，明明是`char*`好吧。所以它的内存结构用图来表示的话如下：\n{% asset_img SimpleClassMemoryMap.png SimpleClass的内存结构图 %}\n\n最后那个静态变量不管它，讲到它的时候再说。\n\n所以上面的那句`mov dword ptr [eax+4], ecx`其实就是给成员变量`a`进行赋值，所以这三句其实就对应了代码中的初始化器`:a(m)`了。\n\n然后在往下看两行：\n```asm\nmov eax, dowrd ptr [ebp-8]\nmov dword ptr [eax+8], 3\n```\n\n不用我说大家也明白了，这个就是给成员变量`b`进行赋值。\n\n那么这么一看，其实初始化器和在构造函数体中对变量进行初始化并没有什么区别啊。当然有！最明显的区别就是初始化的顺序，这个顺序后面会用多个例子来进行试验，这里先不说；另外一个区别就是初始化器调用的是构造函数，而函数体中的初始化调用的是赋值操作符，因为这里都是`int`，所以无法看出区别。\n\n好了分析完成构造函数了。等等，最后那个`ret`后面怎么多了个4，以前都是没有的啊。嗯嗯，这里的4只是恢复堆栈用的，这个具体会在函数调用约定里面详细讲解。这里只要知道`ret 4`其实就相当于下面两条指令就行了:\n```asm\nret\nadd esp, 4\n```\n\n---\n\n画一个分隔线，只是因为前面讲的太多了，其实这里还有一个问题没有讲清楚，就是那个`dynamic initializer for 'k'`的地址是谁传递过来的，这又是一个坑，还是得填啊。但是我现在不想填，好麻烦= =，留着以后想了解main函数之前做了什么的时候再来看这个坑吧，恩。（我中途发现了这样一个东西[http://wiki.osdev.org/Visual_C%2B%2B_Runtime](http://wiki.osdev.org/Visual_C%2B%2B_Runtime)，打开有兴趣可以参考参考）\n\n然后不知不觉我们就来到了`main`函数调用的地方：\n{% asset_img ThePlaceWhereCallMain.png main函数调用的地放 %}\n\n我们仍然可以看一下`main`函数它完整的函数签名是什么：\n```asm\nmov eax, dword ptr [HelloWorld2005!envp]\npush eax\n\nmov ecx, dword ptr [HelloWorld2005!argv]\npush ecx\n\nmov edx, dword ptr [HelloWorld2005!argc]\npush edx\n\ncall HelloWorld2005!main \n```\n\n可以看到它其实传给main函数三个参数，分别是`argc`,`argv`,`envp`，至于具体什么意思，自己百度一下啦。\n\n现在我们进入到`main`函数的主体，并定位到第一句代码执行的位置，如下：\n{% asset_img MainSimpleClassJ=233.png main函数执行的第一句代码 %}\n\n准备数据没啥好说的，将`0E9h`(也就是233)进行压栈，然后将变量`j`的栈上地址，也就是this指针的值传递给`SimpleClass`的构造函数：\n```asm\npush 0E9h\nlea ecx, [ebp-1Ch]\ncall HelloWorld2005!SimpleClass::SimpleClass\n```\n\n这里唯一的问题就是为什么`j`是保存在那个地址上，我们来算嘛。首先我们根据上面各种语句，可以得到当前函数局部堆栈的内存分布图如下：\n{% asset_img MainSimpleClassJ=233Stack.png 此时的堆栈情况 %}\n\n我把函数参数的区域标为黄色，分配给变量j的内存标为红色。好吧，这样看来没优化的时候，系统真的是有浪费4字节内存的习惯。\n\n然后代码就开始调用`SimpleClass`构造函数了，如此看来单参数构造函数的调用，下面两种调用方法所生成的汇编代码是相同的（此处只针对了系统内置类型，结构体的之后再验证）：\n```cpp\nSimpleClass a(10);\nSimpleClass b = 10;\n```\n\n构造函数已经详细分析过了，所以就不进去继续看了。\n\n看下一句代码`SimpleClass k = ::k;`，这个从C++的层面来看的话，他应该调用我写的拷贝构造函数才对，那么我们来看对应的汇编代码吧：\n```asm\npush offset HelloWorld2005!k\nlea ecx, [ebp-30h]\ncall HelloWorld2005!SimpleClass::SimpleClass\n```\n\n额，它好像没有对局部变量和全局变量进行直接的区分，因为，编译器TM就没有给局部变量取名字！！！局部变量是没有符号的。好吧，我的哪个局部变量和全局变量什么区别的问题就不是问题了。至于分配内存我也就不说了。这里主要就说明一下`SimpleClass`的拷贝构造函数好了：\n{% asset_img SimpleClassCopyConstructorCode.png 拷贝构造函数 %}\n\n我们直接跳到`004011b3`这一行\n```asm\nmov eax, dword ptr [ebp-8]\nmov dword ptr [eax], offset HelloWorld2005!SimpleClass::`vftable'\n\nmov eax, dword ptr [ebp-8] ; 拿到this指针\nmov ecx, dword ptr [ebp+8] ; 拿到全局变量k的地址\nmov edx, dword ptr [ecx+4] ; edx = k.a\nmov dword ptr [eax+4], edx ; this.a = edx\n\nmov eax, dword ptr [ebp-8] ; 拿到this指针\nmov ecx, dword ptr [ebp+8] ; 拿到全局变量k的地址\nmov edx, dword ptr [ecx+8] ; edx = k.b\nmov dword ptr [eax+8], edx ; this.b = edx\n\nmov eax, dword ptr [ebp-8]\n```\n\n= =好复杂的感觉，一句一句分析，此时`ebp-8`中保存的就是this指针的值。然后前面两句的意思就是初始化this指针的虚函数表，没有任何疑问。\n\n接下来的四句，因为在调用拷贝构造函数之前调用了一句`push offset HelloWorld2005!k`，所以现在上一个堆栈的顶部保存的其实就是全局变量`k`的地址。所以这里`mov ecx, dword ptr [ebp+8]`就是讲全局变量`k`的地址保存到`ecx`寄存器中。所以有了上面的注释之后基本上就不需要我讲解了。拷贝构造函数搞定！\n\n再往下看`Simple Class a(k)`的汇编代码：\n```asm\nlea     eax, [ebp-30h]  ; 将局部变量k的地址保存到eax\npush    eax             ; 将eax的值压栈\nlea     ecx, [ebp-44h]  ; 分配局部变量内存，从ebp-44h开始的12个字节\ncall    HelloWorld2005!SimpleClass:SimpleClass  ;调用拷贝构造函数\n```\n\n不解释，依然和上面的构造过程一模一样。所以其实拷贝构造函数的调用下面两种方式也是完全相同的：\n```cpp\nSimpleClass a = k;\nSimpleClass b(k);\n```\n\n---\n\n一个华丽的分割线之后，开始看函数的调用，我们这里主要是看各个函数之间的区别，对于函数主体，我们其实并不关注，看前面两个函数:\n{% asset_img MainCompareTestAndTestConst.png 比较const和非const函数 %}\n\n他们几乎完全一样，通过ecx传递指针，然后调用对应的函数，const函数最后的const修饰符可以说是没有起到任何作用，要知道这个const是用来修饰this指针的，也就是说const成员函数中你不能对this指针指向的成员进行修改。但是就如同我上一章里面说的，const只是从语义上让你能够在编译期就能发现问题，要知道编译期找bug的代价比运行期找bug代价小很多的。\n\n这一次我们不去看它真正的实现，我们不如自己来写一个TestMemberFunc出来？\n```asm\npush ebp        ; 保存上一个堆栈的基地址\nmov ebp, esp    ; 确定新的堆栈基地址\nsub esp, 0C0h   ; 分配足够的堆栈，其实我觉得这里没有用到堆栈啊，可以不用这一步\npush xxx        ; 忘记是啥\npush xxx        ; 忘记是啥\npush xxx        ; 忘记是啥\npush ecx        ; 保存this指针\n; 初始化这块堆栈区域，忘记什么命令了\npop ecx         ; 恢复this指针\nmov dword ptr [ebp-8], ecx ; 将this指针保存到栈底\nmov eax, dword ptr [ebp-8] ; 将this指针拷贝到eax中\nmov ecx, dword ptr [eax+4] ; 拿到a的值\nadd ecx, dword ptr [eax+8] ; 加上b的值\nmov dword ptr [eax+4], ecx ; 将得到的和保存到a的位置中\npop xxx\npop xxx\npop xxx \nmov esp, ebp\npop ebp\nret\n```\n\n我觉得差不多应该是这个样子，不管那么多了。这个只是一个我自己想做的一个练习而已，继续往下面执行。\n\n接着就是虚函数，汇编代码如下图所示:\n{% asset_img MainCallTestVirtual.png 调用虚函数 %}\n\n好像我还是觉得没什么特别的地方，通过`push`传递参数，通过`ecx`传递this指针，进去函数实现的地方看也和普通函数的调用没有什么区别。好吧，可能要等到用到继承的时候才会出现区别吧。\n\n所以在这种没有继承的情况下，成员函数，const成员函数和虚函数之间完全是没有任何区别的。\n\n看完最后一个`int d = SimpleClass::TestStatic(12, 13)`就可以解放了，相信看了汇编代码的人会觉得，这个函数是最没有技术含量的了：\n{% asset_img MainCallTestStatic.png 调用静态函数 %}\n\n简单来说就和普通的全局函数是一模一样的，唯一的区别就是静态函数前面要加一个类名加一个域操作符。\n\n啊！终于都分析完了。“诶，好像还有一个静态成员变量你还没说吧？”，我。。。。。。你这个同学记性能不能放差一点，我现在好累了= =\n\n好的，之前我们用`dt`命令查看了`SimpleClass`的内存结构，我们再看一下：\n{% asset_img DtSimpleClass.png SimpleClass的内存结构 %}\n\n发现str的地址并不是一个偏移量，而是一个固定的地址`00406000`，记住这个是`str`变量保存的地址，而不是`\"joker\"`这个字符串的地址。如果要确定它指向字符串的地址，那么就输入`dd 0040600`：\n{% asset_img dd00406000.png str指向的内存内容 %}\n\n拿到第一个值，这个值就是`\"joker\"`存放的地址了，继续输入`da 0040412c`（`da`的意思应该是dump ansi）：\n{% asset_img da0040412c.png 查看str指向的字符串 %}\n\n好吧，既然讲到静态变量了，那么我问大家一个问题，静态变量存放在程序的什么区段：\n1. text段\n2. rdata段\n3. data段\n4. rsrc段\n\n能搞明白么？好吧，为了寻找这个问题的答案，我们不妨打印出这个程序所有的头部信息吧。利用`dh! -s HelloWorld2005`（dh的意思是表示dump header,-s表示只展示区段信息）\n{% asset_img DumpHelloWorldHeaders.png 程序的头部区段信息 %}\n\n但是这里所有的数据都是相对于HelloWorld2005.exe最开始的地方，\n{% asset_img lmvmHelloWorld2005.png HelloWorld2005.exe在程序中的真实地址范围 %}\n\n那这样的话我们就能确认到各个区段的实际内存范围：\n```\ntext段       00401000~0040313C\nrdata段      00404000~0040515C\ndata段       00406000~00406418\nrsrc段       00407000~004071B4\n```\n\n先来看`str`变量的地址，是`00406000`，它好像正好就是data段的起始地址，毫无疑问了那就，静态成员变量被存放在data段中。\n\n我们再来看看`\"joker\"`这个字符串，它的地址是`0040412C`，而这个地址落在了rdata段中。我们不妨把rdata段中的所有的字符串都列举出来，眼见为实。我们可以用`s -sa HelloWorld2005+4000 L115C`命令来搜索这个rdata内存区间里面所有的ANSI字符串，我这里输出的结果如下：\n{% asset_img s-saHelloWorld2005+4000L115C.png rdata段中的所有ANSI字符串 %}\n\n毫无悬念你可以找到`\"joker\"`这个字符串。\n\n好了这些就把所有的东西都讲完了，遗留下来的坑，下一个章节会填完。大家慢慢消化吧，拜拜！\n\n## 回顾：\n\n### 关于WinDBG\n1. `dv`命令用于查看局部变量，如果想查看全局变量记得前面加上`模块名!`\n2. `dt`命令用于查看结构体的分布情况，也可以以结构体来解析对应的内存\n3. `!dh`命令可以用于查看模块的头部信息，具体参数请自行补充\n4. `s`命令可以用于搜索内存，具体参数请自行补充\n\n\n### 关于汇编\n1. `ret 4`指令在返回的同时，也会将栈顶指针加4（清空堆栈）\n2. 在调用类函数的时候，包括构造函数，通过`ecx`寄存器传递this指针，并在函数内部，将this指针的值保存在`ebp-8`的位置\n\n\n### 关于C++\n1. 全局变量在是main函数之前初始化的\n2. 全局变量的内存是在编译期就已经被决定了的\n3. 类的虚函数表是在构造函数中进行初始化的\n4. 虚函数表放在this指针指向的基地址位置\n5. const成员函数和非const成员函数在实现上并没有任何不同，只是便于编译器能够在编译期就把问题抛出来\n6. 在没有继承的情况下，成员函数和虚函数并没有什么不同\n7. 静态函数和普通函数也没有什么不同，只是静态函数调用的时候需要加上类名加上域作用符\n8. 静态成员变量存放在`data`区段\n9. 常量字符串存放在`rdata`区段\n10. main函数的完整签名是int main(int argc, char** argv, char** envp);\n11. 函数入口并不存放在类的结构中","slug":"windbg-windbg-chapter3","published":1,"updated":"2018-06-25T11:14:49.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjivnhtne000b2gusea2baouz","content":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>已经介绍了函数和结构体的内容了，我想这次应该可以大致研究一下类相关的知识了。不过这次照例还是没有release版本的分析内容，而且这次讲类也只是讲解基础知识，对于类的高级用法，比如继承、成员函数指针这些都留到以后去研究。那么进入正题吧（貌似导言越来越短了，我在想以后要不要去掉）。<br><a id=\"more\"></a></p>\n<h2 id=\"给结构体加上一点控制！再加上一点函数！\"><a href=\"#给结构体加上一点控制！再加上一点函数！\" class=\"headerlink\" title=\"给结构体加上一点控制！再加上一点函数！\"></a>给结构体加上一点控制！再加上一点函数！</h2><p>国际惯例，先贴分析的代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleClass</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    SimpleClass(<span class=\"keyword\">int</span> m)</span><br><span class=\"line\">        : a(m)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SimpleClass(<span class=\"keyword\">const</span> SimpleClass&amp; rhs)</span><br><span class=\"line\">        : a(rhs.a)</span><br><span class=\"line\">        , b(rhs.b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~SimpleClass()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestMemberFunc</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        a += b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestConstMemberFunc</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = a;</span><br><span class=\"line\">        m += b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">TestVirtual</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        a += m;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">TestStatic</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m + n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* SimpleClass::str = <span class=\"string\">\"joker\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">SimpleClass <span class=\"title\">k</span><span class=\"params\">(<span class=\"number\">12</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SimpleClass j = <span class=\"number\">233</span>;</span><br><span class=\"line\">    SimpleClass k = ::k;</span><br><span class=\"line\">    <span class=\"function\">SimpleClass <span class=\"title\">a</span><span class=\"params\">(k)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    k.TestMemberFunc();</span><br><span class=\"line\">    k.TestConstMemberFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    a.TestVirtual(<span class=\"number\">14</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> d = SimpleClass::TestStatic(<span class=\"number\">12</span>, <span class=\"number\">13</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这次需要分析的东西还是挺多的，我把几个需要带到分析过程中的问题罗列出来吧：</p>\n<ol>\n<li>全局变量什么时候初始化</li>\n<li>类的初始化器和普通的赋值有什么不同</li>\n<li>成员变量的初始化顺序是什么</li>\n<li>没有给初始化值的成员变量编译器会做什么操作</li>\n<li>静态函数存放在什么地方，是否存放在类空间内部</li>\n<li>静态成员变量又存放在什么地方，是否存放在类空间的内部</li>\n<li>虚函数和普通成员函数有什么区别</li>\n<li>普通成员函数和const成员函数有什么区别</li>\n<li>静态函数和普通成员函数有什么区别</li>\n<li>全局变量和局部变量编译器是怎么区分开的</li>\n</ol>\n<p>看了下真的是任重而道远，其实我已经做了很多压缩了，比如“静态成员变量和全局变量谁先被初始化”这个问题由于难度问题，没有把它列进来。</p>\n<p>那么我们先挑个最恶心人的问题来吧，全局变量什么时候初始化。要想了解这个问题，最好的方法就是在类的构造函数处下一个断点，来，跟着我输入指令<code>bp HelloWorld2005!SimpleClass::SimpleClass</code>，然后回车。好吧，坑爹了，WinDBG认为这个断点有歧义，因为<code>SimpleClass</code>类有两个构造函数，所以它不知道给哪个构造函数下断点，哎，真是笨：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/SetConstructorBreakPoint.png\" title=\"设置构造函数断点\"></p>\n<p>没办法了，只能根据WinDBG给我们的提示，用构造函数的具体地址来设置断点，来输入<code>bp 00401140</code>，然后输入<code>g</code>继续执行代码，直到运行到断点处：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/HitConstructorBreakPoint.png\" title=\"执行到断点处\"></p>\n<p>这时我们只是想直到这个构造函数是谁调用过来的，那么我们就需要直到函数调用的堆栈，输入<code>kbn</code>回车即可：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/GlobalVarCallStack.png\" title=\"全局变量构造时的调用堆栈\"></p>\n<p>可以看到它是由一个叫做<code>_initterm</code>的函数调用过来的，上面的哪个<code>dynamic initializer for &#39;k&#39;</code>可以先忽略，那个就是初始化全局变量k的地方，简单来说这个函数就对应了SimpleClass k(12)这句代码。那么我们现在要做的事情就是在_initterm这个函数调用的地方下一个断点。好了，按下<code>Ctrl+Shift+F5</code>重启程序，然后输入<code>bp MSVCR80D!_initterm</code>，输入<code>g</code>回车即可：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/InInitTermFunction.png\" title=\"调用_initterm的地方\"></p>\n<p>前面保存堆栈就不用看了，主要看下面这块<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp+8]</span><br><span class=\"line\">cmp eax, dword ptr [ebp+0Ch]</span><br><span class=\"line\">jae MSVCR80D!_initterm+0x25</span><br></pre></td></tr></table></figure></p>\n<p>注意<code>ebp+8</code>指向了上一个堆栈的栈顶的第一个DWORD，<code>ebp+0Ch</code>指向了上一个堆栈栈顶的第二个DWORD，其实应该也是传递给<code>_initterm</code>函数的两个参数，这里只是比较这两个数值是否相等。这时肯定有人会问了，<code>cmp</code>比较之后的结果存放在哪里呢？当然是寄存器了，只是这个寄存器比较特殊，它叫标志寄存器，你平时在WinDBG中看不到这个寄存器，但是你可以通过按下<code>Alt+4</code>弹出一个罗列了所有寄存器的对话框：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/AllRegisters.png\" title=\"所有的寄存器\"></p>\n<p>确实相当多，不过这里我只介绍<code>cmp</code>会用到的，一个是进位标记<code>cf</code>（carry flag）和零位标记<code>zf</code>（zero flag）。<code>cmp</code>比较下来不过就是小中大三种结果，那么对应到标志寄存器上的表现如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/CmpResult.png\" title=\"cmp比较的结果\"></p>\n<p>那么我们这里执行完<code>cmp</code>之后看到这两个寄存器的内容如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/AfterCmpOperation.png\" title=\"cmp执行之后寄存器的内容\"></p>\n<p>我们再人肉比较一下这两个值吧：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/ActualValueForCmp.png\" title=\"两个值的具体内容\"></p>\n<p>可以发现<code>ebp+8</code>的值小于<code>ebp+0Ch</code>的值，所以说<code>zf</code>应该是0，<code>cf</code>应该是1，对照寄存器的内容，怎么样，我没有忽悠你吧。</p>\n<p>下面是一条新的指令<code>jae MSVCR80D!_initterm+0x25</code>，当然其实我现在也记不住那么多指令，只能依靠谷歌和翻书。<code>jae</code>指令的意思是：基于无符号数的比较结果，如果大于等于就执行后面的跳转。而前面比较的结果是小于，所以不会执行后面的跳转，指令选择继续往下执行。同样的指令还有很多，我这里不想介绍太多，大家可以自行翻书。</p>\n<p>下面三条语句也执行了同样的操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx, dword ptr [ebp+8]</span><br><span class=\"line\">cmp dword ptr [ecx], 0</span><br><span class=\"line\">je MSVCR80D!_initterm+0x1a</span><br></pre></td></tr></table></figure></p>\n<p>这里的意思也差不多，它先取<code>ebp+8</code>指向地址的值，把它放到ecx中，然后在将这个值指向的值与0进行比较，如果等于0的话就跳转到<code>MSVCR80D!_initterm+0x1a</code>处执行。这里具体比较内容和结果自己去探索，我这里就看到它执行了后面的跳转。然后他又执行了下面的这段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx, dword ptr [ebp+8]</span><br><span class=\"line\">add ecx, 4</span><br><span class=\"line\">jmp MSVCR80D!_initterm+0x3</span><br></pre></td></tr></table></figure></p>\n<p>它又一次取了<code>ebp+8</code>的值，并把它加4,所以更加肯定了<code>ebp+8</code>存放的是一个指针，这里只是对指针做了一个偏移操作。然后将<code>ecx</code>的值又放回了<code>ebp+8</code>指向的地址，接着跳转到了<code>_initterm+0x3</code>的位置，也就是下面这段代码：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/InitTermJmpBackToFuncHead.png\" title=\"跳转回去开头\"></p>\n<p>好了，整个函数就只剩下一段汇编没有分析了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov edx, dword ptr [ebp+8]</span><br><span class=\"line\">mov eax, dword ptr [edx]</span><br><span class=\"line\">call eax</span><br></pre></td></tr></table></figure></p>\n<p>看到<code>call eax</code>第一反应应该就是这肯定是调用了一个函数，只是这个函数可能是通过参数传递进来的。这里继续引用<code>ebp+8</code>指向的值，放到edx中，然后把这个值指向的内存内容放到eax中，而这个值则正好是一个函数的地址。</p>\n<p>因此我有理由相信，这个函数接受两个参数，第一个是<code>ebp+8</code>,第二个是<code>ebp+0Ch</code>，并且从<code>ebp+8</code>到<code>ebp+0Ch</code>这个范围中存放了一系列的函数的地址，而这个函数做的事情就是不断地循环，如果遇到不是空指针的就调用这个函数。我把这段函数具体化为C++代码，应该大致如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _initterm(<span class=\"keyword\">void</span>* from, <span class=\"keyword\">void</span>* to)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (from &lt; to)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*from != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            functype func = (functype)*from;</span><br><span class=\"line\">            func();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        from++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中functype我也不知道是什么类型，所以就遗留着吧。搞定了这个函数的含义，下面就好办了，就是不断地尝试进入函数体的内部，直到调用到了<code>SimpleClass</code>的构造函数位置。</p>\n<p>那我们调用到<code>eax</code>中函数的时候，就用F11调试进入函数内部（记得用<code>kbn</code>看下调用堆栈，以防调试错了地方，因为一共会调用两次<code>_initterm</code>函数，我们需要分析的是<code>__tmainCRTStartup</code>调用过来的<code>_initterm</code>函数）</p>\n<p>第一次调进来好像是调到了一个叫做<code>pre_cpp_init</code>的函数中了，这货居然还是HelloWorld2005中的函数，看看也无妨，可以更加了解一下运行的机制：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/HelloWorld2005PreCppInit.png\" title=\"pre_cpp_init函数\"></p>\n<p>国际惯例，前面两句保存堆栈，但是注意这里其实少了我们以前看到的那些<code>sub esp 120h</code>这样的语句，额，可能是没有声明局部变量？或者是被优化掉了？以后讨论。然后它将一个叫做<code>_RTC_Terminate</code>的函数进行压栈，这个函数我查了好久都没有找到是干嘛的，有熟悉的可以告诉我一下(<a href=\"mailto:cloudy064@gmail.com\" target=\"_blank\" rel=\"noopener\">cloudy064@gmail.com</a>)，或者等我加了评论模块再说，万分感谢。</p>\n<p>然后就是熟悉的两个个操作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call HelloWorld2005!atexit</span><br><span class=\"line\">add esp, 4</span><br></pre></td></tr></table></figure></p>\n<p>现在我们应该会知道之前压栈的<code>_RTC_Terminate</code>是一个<code>atexit</code>需要用到的参数，然后<code>pre_cpp_init</code>调用<code>atexit</code>函数，返回之后，利用<code>add esp, 4</code>清除临时变量，恢复堆栈。这里我就不进去<code>atexit</code>里面看了，我觉得会吐血，以后安排补丁文章来搞定这些一直没有分析的问题吧。</p>\n<p>继续看后面几句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [HelloWorld2005!_newmode]</span><br><span class=\"line\">mov dword ptr [HelloWorld2005!startinfo], eax</span><br><span class=\"line\">push offset HelloWorld2005!startinfo</span><br></pre></td></tr></table></figure></p>\n<p>依据以前的经验，这里的<code>HelloWorld2005!_newmode</code>和<code>HelloWorld2005!startinfo</code>应该是<code>HelloWorld2005</code>里面的全局变量，虽然我不知道它是在哪里初始化的，但是不妨碍我们继续分析。我们可以通过<code>dv</code>（dump value）指令来查看这两个变量的内容：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/PreCppInitDvResult.png\" title=\"用dv查看结果\"></p>\n<p>发现我们只能看到startinfo的类型信息，却得不到它的内容，这个时候应该介绍新指令:<code>dt</code>（dump type），这个指令可以在变量类型为符合类型（比如结构体）的时候发挥作用。利用<code>dt</code>指令查看到的结果如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/PreCppInitDtValueResult.png\" title=\"dt查看得到的结果\"></p>\n<p>恩，这下能够看到它的成员变量的值这些信息了。额，你还不放心，还想看它的结构体内部变量是怎么分布的？没问题，用<code>dt _startupinfo</code>来查看就行了，这里我就不贴出来结果了，大家自己试验吧。</p>\n<p>所以这里就只是初始化了全局变量<code>startinfo</code>，最后一句<code>push offset HelloWorld2005!startinfo</code>你就可以把它理解为将<code>startinfo</code>的地址入栈了。将一个变量或者地址进行入栈，在没有优化的情况下，十有八九就是准备调用函数了。</p>\n<p>接着看下面的语句中，有连续好几个压栈的操作，然后接一个函数调用，最后恢复堆栈：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx, dword ptr [HelloWorld2005!_dowildcard]</span><br><span class=\"line\">push ecx</span><br><span class=\"line\">push offset HelloWorld2005!envp</span><br><span class=\"line\">push offset HelloWorld2005!argv</span><br><span class=\"line\">push offset HelloWorld2005!argc</span><br><span class=\"line\">call dword ptr [HelloWorld2005!_imp____getmainargs]</span><br><span class=\"line\">add esp, 14h</span><br></pre></td></tr></table></figure></p>\n<p>当然这些也全部都是全局变量了，不过第一个是将<code>_dowildcard</code>这个变量压栈，下面三个是将<code>envp</code>,<code>argv</code>,<code>argc</code>的内存地址进行压栈，所以你可以把<code>_imp____getmainargs</code>函数看做是下面这个签名：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _imp____getmainargs(</span><br><span class=\"line\">    <span class=\"keyword\">void</span>* argc, </span><br><span class=\"line\">    <span class=\"keyword\">void</span>* argv, </span><br><span class=\"line\">    <span class=\"keyword\">void</span>* envp, </span><br><span class=\"line\">    <span class=\"keyword\">int</span> _dowildcard,</span><br><span class=\"line\">    _startupinfo* startinfo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">//.......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于函数调用的参数顺序和入栈顺序以后会安排专题详细分析，这里就当参数是这个顺序吧。而这个函数从名字上来看就是用来初始化参数信息的，和我们的全局变量没有多大的关系，所以就不进去继续看了，直接跳过。</p>\n<p>往下再看几行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [HelloWorld2005!argret], eax</span><br><span class=\"line\">cmp dword ptr [HelloWorld2005!argret], 0</span><br><span class=\"line\">jge HelloWorld2005!pre_cpp_init+0x56</span><br></pre></td></tr></table></figure></p>\n<p>这里eax应该存放了刚刚调用<code>_imp____getmainargs</code>的返回值，之所以把它存放到另外一个全局变量里面，恩，可能是因为没有优化吧= =。这三句概括起来就是将返回值和0进行比较，如果返回值大于等于0（<code>jge</code>的意思就是jump if greater than or equal），那么就跳转到<code>pre_cpp_init+0x56</code>的位置；否则就继续执行。</p>\n<p>还剩下最后一段代码了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push 8</span><br><span class=\"line\">call HelloWorld2005!amsg_exit</span><br><span class=\"line\">add esp, 4</span><br></pre></td></tr></table></figure></p>\n<p>这段应该是强迫程序退出的一个函数吧，8是错误码。意思就是说，如果上面的返回值小于0，那么肯定就是程序出现了什么错误了，然后执行到这里就让程序已错误码8的结果退出。</p>\n<p>好了，我们整理一下这个<code>pre_cpp_init</code>函数，其实可以用C++代码表示成下面这个样子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pre_cpp_init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    atexit(&amp;_RTC_Terminate);</span><br><span class=\"line\">    startinfo.newmode = _newmode;</span><br><span class=\"line\">    argret = _imp____getmainargs(&amp;argc, &amp;argv, &amp;envp, _dowildcard, &amp;startinfo);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argret &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    amsg_exit(<span class=\"number\">8</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然可能和真实实现会有不一样，但是大致的流程应该不会错的。</p>\n<p>好吧，分析了半天我们还是没有找到调用<code>SimpleClass</code>构造函数的地方。不要急嘛，函数返回了继续看下去。</p>\n<p>第二次进入<code>call eax</code>，我们这个时候就看到了全局变量k的初始化了，代码如下所示：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/DynamicInitializerForK.png\" title=\"初始化全局变量K\"></p>\n<p>又是人肉分析代码的艰辛历程，前面一大坨就是我们以前熟悉的，先保存上一个堆栈以及寄存器的内容，然后分配一个<code>30h</code>大小局部变量堆栈空间给当前函数（我也不知道函数名叫啥），然后将这块内存初始化为<code>0xCCCCCCCC</code>，下面的这段代码才是真正执行构造函数的地方：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push <span class=\"number\">0</span>Ch</span><br><span class=\"line\">mov ecx, offset HelloWorld2005!k</span><br><span class=\"line\">call HelloWorld2005!SimpleClass::SimpleClass</span><br></pre></td></tr></table></figure></p>\n<p>这里其实可以看到在调用构造函数之前，编译器已经确定好全局变量<code>k</code>应该存放在什么位置了，而我们调用构造函数只是初始化<code>k</code>这块内存区域而已。这里讲12这个数进行压栈，然后将<code>k</code>的地址保存到<code>ecx</code>寄存器中，我猜ecx保存就一定是this指针！不然构造函数不知道初始化哪片内存。最后我们调用了构造函数。因为这里二进制代码已经写死了调用函数的地址，而不是通过函数名进行调用，所以不存在函数名有二义性的问题。</p>\n<p>我们进入到了构造函数里面，看到如下的代码：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/SimpleClassConstructorCode.png\" title=\"SimpleClass的构造函数\"></p>\n<p>前面里面有一个不同，那就是多了一句<code>push ecx</code>，要知道后面再执行初始化堆栈的时候，需要使用到<code>ecx</code>这个计数器的，而ecx之前保存了this指针的地址，所以说需要先将<code>ecx</code>的值压栈进行保存，这样才能保证this指针地址不会丢失。然后继续往下看，看到<code>pop ecx</code>处，这里就是执行一次出栈操作，恢复<code>ecx</code>中原有的this指针。</p>\n<p>接着函数执行了<code>mov dword ptr [ebp-8], ecx</code>这句话，要知道在没有开优化的情况下，<code>ebp-8</code>这个位置是第一个局部变量声明的位置，也就是说其实构造函数中隐藏了一个定义变量的操作<code>SimpleClass* this = ecx;</code>，所以现在大家知道this指针是怎么来的了吗？它保存在哪里也应该知道了吧。</p>\n<p>继续看，下面一句话是<code>mov eax, dword ptr [ebp-8]</code>，我要掀桌了（(╯‵□′)╯︵┻━┻），好好一个this指针到处传，就不能一步到位么。把桌子摆好，努力思考一下，我觉得将this指针放在局部变量的位置，可能是为了将this指针保存起来，能够随时获取，因为寄存器是经常变化的，一堆操作需要用到寄存器。而把this指针放到寄存器中，则是因为对于<code>dword ptr</code>这种类似于析址操作只支持寄存器的。哎，Intel的指令就是这么麻烦（我感到背后有一股杀气）。</p>\n<p>接下来就开始进行调用初始化器以及调用函数体了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [eax], offset HelloWorld2005!SimpleClass::`vftable&apos;</span><br></pre></td></tr></table></figure></p>\n<p>= =天哪，忘记了还有这货，这个看名字就知道是SimpleClass的虚函数表，因为我这里声明了一个虚函数，所以说这个类就会有一个虚函数表来承载虚函数的地址。而这个虚函数表就存放在this指针的基地址的位置。我们现在可以简单瞄一眼虚函数表，利用<code>dd eax</code>可以看到this指针指向内存的内容：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/SimpleClassThisPointToMemory.png\" title=\"this指针指向的内容\"></p>\n<p>第一个值就是虚表的地址了，至于虚拟地址里面存放了什么，我现在还不想研究，等真正讲到虚函数的时候再说吧。</p>\n<p>然后继续往下看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-8] ;取this指针</span><br><span class=\"line\">mov ecx, dword ptr [ebp+8] ;获取最后一个压栈的参数，这里只有一个就是12</span><br><span class=\"line\">mov dword ptr [eax+4], ecx ;给this指针偏移四个字节的地址进行赋值</span><br></pre></td></tr></table></figure></p>\n<p>前面两个都比较好理解吧，就是单纯的取值，对于最后一个的话，恩，看一看SimpleClass的内存分布大家应该就了解了，输入<code>dt SimpleClass</code>即可：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/DtSimpleClass.png\" title=\"SimpleClass的内存分布\"></p>\n<p>可以很容易看到，对于一个具体的<code>SimpleClass</code>实例，它的基地址存放了虚函数表指针，偏移4字节的地方存放了<code>a</code>变量的值，偏移8字节的地方存放了<code>b</code>变量的值。额最后一个就太奇怪了，它给我们的信息是它存放在一个固定的地址，并且它的类型是(null)，明明是<code>char*</code>好吧。所以它的内存结构用图来表示的话如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/SimpleClassMemoryMap.png\" title=\"SimpleClass的内存结构图\"></p>\n<p>最后那个静态变量不管它，讲到它的时候再说。</p>\n<p>所以上面的那句<code>mov dword ptr [eax+4], ecx</code>其实就是给成员变量<code>a</code>进行赋值，所以这三句其实就对应了代码中的初始化器<code>:a(m)</code>了。</p>\n<p>然后在往下看两行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dowrd ptr [ebp-8]</span><br><span class=\"line\">mov dword ptr [eax+8], 3</span><br></pre></td></tr></table></figure></p>\n<p>不用我说大家也明白了，这个就是给成员变量<code>b</code>进行赋值。</p>\n<p>那么这么一看，其实初始化器和在构造函数体中对变量进行初始化并没有什么区别啊。当然有！最明显的区别就是初始化的顺序，这个顺序后面会用多个例子来进行试验，这里先不说；另外一个区别就是初始化器调用的是构造函数，而函数体中的初始化调用的是赋值操作符，因为这里都是<code>int</code>，所以无法看出区别。</p>\n<p>好了分析完成构造函数了。等等，最后那个<code>ret</code>后面怎么多了个4，以前都是没有的啊。嗯嗯，这里的4只是恢复堆栈用的，这个具体会在函数调用约定里面详细讲解。这里只要知道<code>ret 4</code>其实就相当于下面两条指令就行了:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret</span><br><span class=\"line\">add esp, 4</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>画一个分隔线，只是因为前面讲的太多了，其实这里还有一个问题没有讲清楚，就是那个<code>dynamic initializer for &#39;k&#39;</code>的地址是谁传递过来的，这又是一个坑，还是得填啊。但是我现在不想填，好麻烦= =，留着以后想了解main函数之前做了什么的时候再来看这个坑吧，恩。（我中途发现了这样一个东西<a href=\"http://wiki.osdev.org/Visual_C%2B%2B_Runtime\" target=\"_blank\" rel=\"noopener\">http://wiki.osdev.org/Visual_C%2B%2B_Runtime</a>，打开有兴趣可以参考参考）</p>\n<p>然后不知不觉我们就来到了<code>main</code>函数调用的地方：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/ThePlaceWhereCallMain.png\" title=\"main函数调用的地放\"></p>\n<p>我们仍然可以看一下<code>main</code>函数它完整的函数签名是什么：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [HelloWorld2005!envp]</span><br><span class=\"line\">push eax</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [HelloWorld2005!argv]</span><br><span class=\"line\">push ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [HelloWorld2005!argc]</span><br><span class=\"line\">push edx</span><br><span class=\"line\"></span><br><span class=\"line\">call HelloWorld2005!main</span><br></pre></td></tr></table></figure></p>\n<p>可以看到它其实传给main函数三个参数，分别是<code>argc</code>,<code>argv</code>,<code>envp</code>，至于具体什么意思，自己百度一下啦。</p>\n<p>现在我们进入到<code>main</code>函数的主体，并定位到第一句代码执行的位置，如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/MainSimpleClassJ=233.png\" title=\"main函数执行的第一句代码\"></p>\n<p>准备数据没啥好说的，将<code>0E9h</code>(也就是233)进行压栈，然后将变量<code>j</code>的栈上地址，也就是this指针的值传递给<code>SimpleClass</code>的构造函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push 0E9h</span><br><span class=\"line\">lea ecx, [ebp-1Ch]</span><br><span class=\"line\">call HelloWorld2005!SimpleClass::SimpleClass</span><br></pre></td></tr></table></figure></p>\n<p>这里唯一的问题就是为什么<code>j</code>是保存在那个地址上，我们来算嘛。首先我们根据上面各种语句，可以得到当前函数局部堆栈的内存分布图如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/MainSimpleClassJ=233Stack.png\" title=\"此时的堆栈情况\"></p>\n<p>我把函数参数的区域标为黄色，分配给变量j的内存标为红色。好吧，这样看来没优化的时候，系统真的是有浪费4字节内存的习惯。</p>\n<p>然后代码就开始调用<code>SimpleClass</code>构造函数了，如此看来单参数构造函数的调用，下面两种调用方法所生成的汇编代码是相同的（此处只针对了系统内置类型，结构体的之后再验证）：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">SimpleClass <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">SimpleClass b = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure></p>\n<p>构造函数已经详细分析过了，所以就不进去继续看了。</p>\n<p>看下一句代码<code>SimpleClass k = ::k;</code>，这个从C++的层面来看的话，他应该调用我写的拷贝构造函数才对，那么我们来看对应的汇编代码吧：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push offset HelloWorld2005!k</span><br><span class=\"line\">lea ecx, [ebp-30h]</span><br><span class=\"line\">call HelloWorld2005!SimpleClass::SimpleClass</span><br></pre></td></tr></table></figure></p>\n<p>额，它好像没有对局部变量和全局变量进行直接的区分，因为，编译器TM就没有给局部变量取名字！！！局部变量是没有符号的。好吧，我的哪个局部变量和全局变量什么区别的问题就不是问题了。至于分配内存我也就不说了。这里主要就说明一下<code>SimpleClass</code>的拷贝构造函数好了：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/SimpleClassCopyConstructorCode.png\" title=\"拷贝构造函数\"></p>\n<p>我们直接跳到<code>004011b3</code>这一行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-8]</span><br><span class=\"line\">mov dword ptr [eax], offset HelloWorld2005!SimpleClass::`vftable&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-8] ; 拿到this指针</span><br><span class=\"line\">mov ecx, dword ptr [ebp+8] ; 拿到全局变量k的地址</span><br><span class=\"line\">mov edx, dword ptr [ecx+4] ; edx = k.a</span><br><span class=\"line\">mov dword ptr [eax+4], edx ; this.a = edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-8] ; 拿到this指针</span><br><span class=\"line\">mov ecx, dword ptr [ebp+8] ; 拿到全局变量k的地址</span><br><span class=\"line\">mov edx, dword ptr [ecx+8] ; edx = k.b</span><br><span class=\"line\">mov dword ptr [eax+8], edx ; this.b = edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-8]</span><br></pre></td></tr></table></figure></p>\n<p>= =好复杂的感觉，一句一句分析，此时<code>ebp-8</code>中保存的就是this指针的值。然后前面两句的意思就是初始化this指针的虚函数表，没有任何疑问。</p>\n<p>接下来的四句，因为在调用拷贝构造函数之前调用了一句<code>push offset HelloWorld2005!k</code>，所以现在上一个堆栈的顶部保存的其实就是全局变量<code>k</code>的地址。所以这里<code>mov ecx, dword ptr [ebp+8]</code>就是讲全局变量<code>k</code>的地址保存到<code>ecx</code>寄存器中。所以有了上面的注释之后基本上就不需要我讲解了。拷贝构造函数搞定！</p>\n<p>再往下看<code>Simple Class a(k)</code>的汇编代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea     eax, [ebp-30h]  ; 将局部变量k的地址保存到eax</span><br><span class=\"line\">push    eax             ; 将eax的值压栈</span><br><span class=\"line\">lea     ecx, [ebp-44h]  ; 分配局部变量内存，从ebp-44h开始的12个字节</span><br><span class=\"line\">call    HelloWorld2005!SimpleClass:SimpleClass  ;调用拷贝构造函数</span><br></pre></td></tr></table></figure></p>\n<p>不解释，依然和上面的构造过程一模一样。所以其实拷贝构造函数的调用下面两种方式也是完全相同的：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SimpleClass a = k;</span><br><span class=\"line\"><span class=\"function\">SimpleClass <span class=\"title\">b</span><span class=\"params\">(k)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>一个华丽的分割线之后，开始看函数的调用，我们这里主要是看各个函数之间的区别，对于函数主体，我们其实并不关注，看前面两个函数:<br><img src=\"/2016/04/21/windbg-windbg-chapter3/MainCompareTestAndTestConst.png\" title=\"比较const和非const函数\"></p>\n<p>他们几乎完全一样，通过ecx传递指针，然后调用对应的函数，const函数最后的const修饰符可以说是没有起到任何作用，要知道这个const是用来修饰this指针的，也就是说const成员函数中你不能对this指针指向的成员进行修改。但是就如同我上一章里面说的，const只是从语义上让你能够在编译期就能发现问题，要知道编译期找bug的代价比运行期找bug代价小很多的。</p>\n<p>这一次我们不去看它真正的实现，我们不如自己来写一个TestMemberFunc出来？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push ebp        ; 保存上一个堆栈的基地址</span><br><span class=\"line\">mov ebp, esp    ; 确定新的堆栈基地址</span><br><span class=\"line\">sub esp, 0C0h   ; 分配足够的堆栈，其实我觉得这里没有用到堆栈啊，可以不用这一步</span><br><span class=\"line\">push xxx        ; 忘记是啥</span><br><span class=\"line\">push xxx        ; 忘记是啥</span><br><span class=\"line\">push xxx        ; 忘记是啥</span><br><span class=\"line\">push ecx        ; 保存this指针</span><br><span class=\"line\">; 初始化这块堆栈区域，忘记什么命令了</span><br><span class=\"line\">pop ecx         ; 恢复this指针</span><br><span class=\"line\">mov dword ptr [ebp-8], ecx ; 将this指针保存到栈底</span><br><span class=\"line\">mov eax, dword ptr [ebp-8] ; 将this指针拷贝到eax中</span><br><span class=\"line\">mov ecx, dword ptr [eax+4] ; 拿到a的值</span><br><span class=\"line\">add ecx, dword ptr [eax+8] ; 加上b的值</span><br><span class=\"line\">mov dword ptr [eax+4], ecx ; 将得到的和保存到a的位置中</span><br><span class=\"line\">pop xxx</span><br><span class=\"line\">pop xxx</span><br><span class=\"line\">pop xxx </span><br><span class=\"line\">mov esp, ebp</span><br><span class=\"line\">pop ebp</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure></p>\n<p>我觉得差不多应该是这个样子，不管那么多了。这个只是一个我自己想做的一个练习而已，继续往下面执行。</p>\n<p>接着就是虚函数，汇编代码如下图所示:<br><img src=\"/2016/04/21/windbg-windbg-chapter3/MainCallTestVirtual.png\" title=\"调用虚函数\"></p>\n<p>好像我还是觉得没什么特别的地方，通过<code>push</code>传递参数，通过<code>ecx</code>传递this指针，进去函数实现的地方看也和普通函数的调用没有什么区别。好吧，可能要等到用到继承的时候才会出现区别吧。</p>\n<p>所以在这种没有继承的情况下，成员函数，const成员函数和虚函数之间完全是没有任何区别的。</p>\n<p>看完最后一个<code>int d = SimpleClass::TestStatic(12, 13)</code>就可以解放了，相信看了汇编代码的人会觉得，这个函数是最没有技术含量的了：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/MainCallTestStatic.png\" title=\"调用静态函数\"></p>\n<p>简单来说就和普通的全局函数是一模一样的，唯一的区别就是静态函数前面要加一个类名加一个域操作符。</p>\n<p>啊！终于都分析完了。“诶，好像还有一个静态成员变量你还没说吧？”，我。。。。。。你这个同学记性能不能放差一点，我现在好累了= =</p>\n<p>好的，之前我们用<code>dt</code>命令查看了<code>SimpleClass</code>的内存结构，我们再看一下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/DtSimpleClass.png\" title=\"SimpleClass的内存结构\"></p>\n<p>发现str的地址并不是一个偏移量，而是一个固定的地址<code>00406000</code>，记住这个是<code>str</code>变量保存的地址，而不是<code>&quot;joker&quot;</code>这个字符串的地址。如果要确定它指向字符串的地址，那么就输入<code>dd 0040600</code>：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/dd00406000.png\" title=\"str指向的内存内容\"></p>\n<p>拿到第一个值，这个值就是<code>&quot;joker&quot;</code>存放的地址了，继续输入<code>da 0040412c</code>（<code>da</code>的意思应该是dump ansi）：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/da0040412c.png\" title=\"查看str指向的字符串\"></p>\n<p>好吧，既然讲到静态变量了，那么我问大家一个问题，静态变量存放在程序的什么区段：</p>\n<ol>\n<li>text段</li>\n<li>rdata段</li>\n<li>data段</li>\n<li>rsrc段</li>\n</ol>\n<p>能搞明白么？好吧，为了寻找这个问题的答案，我们不妨打印出这个程序所有的头部信息吧。利用<code>dh! -s HelloWorld2005</code>（dh的意思是表示dump header,-s表示只展示区段信息）<br><img src=\"/2016/04/21/windbg-windbg-chapter3/DumpHelloWorldHeaders.png\" title=\"程序的头部区段信息\"></p>\n<p>但是这里所有的数据都是相对于HelloWorld2005.exe最开始的地方，<br><img src=\"/2016/04/21/windbg-windbg-chapter3/lmvmHelloWorld2005.png\" title=\"HelloWorld2005.exe在程序中的真实地址范围\"></p>\n<p>那这样的话我们就能确认到各个区段的实际内存范围：<br><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text段       <span class=\"number\">00401000</span>~<span class=\"number\">0040313C</span></span><br><span class=\"line\">rdata段      <span class=\"number\">00404000</span>~<span class=\"number\">0040515C</span></span><br><span class=\"line\">data段       <span class=\"number\">00406000</span>~<span class=\"number\">00406418</span></span><br><span class=\"line\">rsrc段       <span class=\"number\">00407000</span>~<span class=\"number\">004071B4</span></span><br></pre></td></tr></table></figure></p>\n<p>先来看<code>str</code>变量的地址，是<code>00406000</code>，它好像正好就是data段的起始地址，毫无疑问了那就，静态成员变量被存放在data段中。</p>\n<p>我们再来看看<code>&quot;joker&quot;</code>这个字符串，它的地址是<code>0040412C</code>，而这个地址落在了rdata段中。我们不妨把rdata段中的所有的字符串都列举出来，眼见为实。我们可以用<code>s -sa HelloWorld2005+4000 L115C</code>命令来搜索这个rdata内存区间里面所有的ANSI字符串，我这里输出的结果如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/s-saHelloWorld2005+4000L115C.png\" title=\"rdata段中的所有ANSI字符串\"></p>\n<p>毫无悬念你可以找到<code>&quot;joker&quot;</code>这个字符串。</p>\n<p>好了这些就把所有的东西都讲完了，遗留下来的坑，下一个章节会填完。大家慢慢消化吧，拜拜！</p>\n<h2 id=\"回顾：\"><a href=\"#回顾：\" class=\"headerlink\" title=\"回顾：\"></a>回顾：</h2><h3 id=\"关于WinDBG\"><a href=\"#关于WinDBG\" class=\"headerlink\" title=\"关于WinDBG\"></a>关于WinDBG</h3><ol>\n<li><code>dv</code>命令用于查看局部变量，如果想查看全局变量记得前面加上<code>模块名!</code></li>\n<li><code>dt</code>命令用于查看结构体的分布情况，也可以以结构体来解析对应的内存</li>\n<li><code>!dh</code>命令可以用于查看模块的头部信息，具体参数请自行补充</li>\n<li><code>s</code>命令可以用于搜索内存，具体参数请自行补充</li>\n</ol>\n<h3 id=\"关于汇编\"><a href=\"#关于汇编\" class=\"headerlink\" title=\"关于汇编\"></a>关于汇编</h3><ol>\n<li><code>ret 4</code>指令在返回的同时，也会将栈顶指针加4（清空堆栈）</li>\n<li>在调用类函数的时候，包括构造函数，通过<code>ecx</code>寄存器传递this指针，并在函数内部，将this指针的值保存在<code>ebp-8</code>的位置</li>\n</ol>\n<h3 id=\"关于C\"><a href=\"#关于C\" class=\"headerlink\" title=\"关于C++\"></a>关于C++</h3><ol>\n<li>全局变量在是main函数之前初始化的</li>\n<li>全局变量的内存是在编译期就已经被决定了的</li>\n<li>类的虚函数表是在构造函数中进行初始化的</li>\n<li>虚函数表放在this指针指向的基地址位置</li>\n<li>const成员函数和非const成员函数在实现上并没有任何不同，只是便于编译器能够在编译期就把问题抛出来</li>\n<li>在没有继承的情况下，成员函数和虚函数并没有什么不同</li>\n<li>静态函数和普通函数也没有什么不同，只是静态函数调用的时候需要加上类名加上域作用符</li>\n<li>静态成员变量存放在<code>data</code>区段</li>\n<li>常量字符串存放在<code>rdata</code>区段</li>\n<li>main函数的完整签名是int main(int argc, char<strong> argv, char</strong> envp);</li>\n<li>函数入口并不存放在类的结构中</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>已经介绍了函数和结构体的内容了，我想这次应该可以大致研究一下类相关的知识了。不过这次照例还是没有release版本的分析内容，而且这次讲类也只是讲解基础知识，对于类的高级用法，比如继承、成员函数指针这些都留到以后去研究。那么进入正题吧（貌似导言越来越短了，我在想以后要不要去掉）。<br>","more":"</p>\n<h2 id=\"给结构体加上一点控制！再加上一点函数！\"><a href=\"#给结构体加上一点控制！再加上一点函数！\" class=\"headerlink\" title=\"给结构体加上一点控制！再加上一点函数！\"></a>给结构体加上一点控制！再加上一点函数！</h2><p>国际惯例，先贴分析的代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleClass</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    SimpleClass(<span class=\"keyword\">int</span> m)</span><br><span class=\"line\">        : a(m)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        b = <span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SimpleClass(<span class=\"keyword\">const</span> SimpleClass&amp; rhs)</span><br><span class=\"line\">        : a(rhs.a)</span><br><span class=\"line\">        , b(rhs.b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~SimpleClass()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestMemberFunc</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        a += b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestConstMemberFunc</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = a;</span><br><span class=\"line\">        m += b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">TestVirtual</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        a += m;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">TestStatic</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m + n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* SimpleClass::str = <span class=\"string\">\"joker\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">SimpleClass <span class=\"title\">k</span><span class=\"params\">(<span class=\"number\">12</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SimpleClass j = <span class=\"number\">233</span>;</span><br><span class=\"line\">    SimpleClass k = ::k;</span><br><span class=\"line\">    <span class=\"function\">SimpleClass <span class=\"title\">a</span><span class=\"params\">(k)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    k.TestMemberFunc();</span><br><span class=\"line\">    k.TestConstMemberFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    a.TestVirtual(<span class=\"number\">14</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> d = SimpleClass::TestStatic(<span class=\"number\">12</span>, <span class=\"number\">13</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这次需要分析的东西还是挺多的，我把几个需要带到分析过程中的问题罗列出来吧：</p>\n<ol>\n<li>全局变量什么时候初始化</li>\n<li>类的初始化器和普通的赋值有什么不同</li>\n<li>成员变量的初始化顺序是什么</li>\n<li>没有给初始化值的成员变量编译器会做什么操作</li>\n<li>静态函数存放在什么地方，是否存放在类空间内部</li>\n<li>静态成员变量又存放在什么地方，是否存放在类空间的内部</li>\n<li>虚函数和普通成员函数有什么区别</li>\n<li>普通成员函数和const成员函数有什么区别</li>\n<li>静态函数和普通成员函数有什么区别</li>\n<li>全局变量和局部变量编译器是怎么区分开的</li>\n</ol>\n<p>看了下真的是任重而道远，其实我已经做了很多压缩了，比如“静态成员变量和全局变量谁先被初始化”这个问题由于难度问题，没有把它列进来。</p>\n<p>那么我们先挑个最恶心人的问题来吧，全局变量什么时候初始化。要想了解这个问题，最好的方法就是在类的构造函数处下一个断点，来，跟着我输入指令<code>bp HelloWorld2005!SimpleClass::SimpleClass</code>，然后回车。好吧，坑爹了，WinDBG认为这个断点有歧义，因为<code>SimpleClass</code>类有两个构造函数，所以它不知道给哪个构造函数下断点，哎，真是笨：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/SetConstructorBreakPoint.png\" title=\"设置构造函数断点\"></p>\n<p>没办法了，只能根据WinDBG给我们的提示，用构造函数的具体地址来设置断点，来输入<code>bp 00401140</code>，然后输入<code>g</code>继续执行代码，直到运行到断点处：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/HitConstructorBreakPoint.png\" title=\"执行到断点处\"></p>\n<p>这时我们只是想直到这个构造函数是谁调用过来的，那么我们就需要直到函数调用的堆栈，输入<code>kbn</code>回车即可：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/GlobalVarCallStack.png\" title=\"全局变量构造时的调用堆栈\"></p>\n<p>可以看到它是由一个叫做<code>_initterm</code>的函数调用过来的，上面的哪个<code>dynamic initializer for &#39;k&#39;</code>可以先忽略，那个就是初始化全局变量k的地方，简单来说这个函数就对应了SimpleClass k(12)这句代码。那么我们现在要做的事情就是在_initterm这个函数调用的地方下一个断点。好了，按下<code>Ctrl+Shift+F5</code>重启程序，然后输入<code>bp MSVCR80D!_initterm</code>，输入<code>g</code>回车即可：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/InInitTermFunction.png\" title=\"调用_initterm的地方\"></p>\n<p>前面保存堆栈就不用看了，主要看下面这块<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp+8]</span><br><span class=\"line\">cmp eax, dword ptr [ebp+0Ch]</span><br><span class=\"line\">jae MSVCR80D!_initterm+0x25</span><br></pre></td></tr></table></figure></p>\n<p>注意<code>ebp+8</code>指向了上一个堆栈的栈顶的第一个DWORD，<code>ebp+0Ch</code>指向了上一个堆栈栈顶的第二个DWORD，其实应该也是传递给<code>_initterm</code>函数的两个参数，这里只是比较这两个数值是否相等。这时肯定有人会问了，<code>cmp</code>比较之后的结果存放在哪里呢？当然是寄存器了，只是这个寄存器比较特殊，它叫标志寄存器，你平时在WinDBG中看不到这个寄存器，但是你可以通过按下<code>Alt+4</code>弹出一个罗列了所有寄存器的对话框：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/AllRegisters.png\" title=\"所有的寄存器\"></p>\n<p>确实相当多，不过这里我只介绍<code>cmp</code>会用到的，一个是进位标记<code>cf</code>（carry flag）和零位标记<code>zf</code>（zero flag）。<code>cmp</code>比较下来不过就是小中大三种结果，那么对应到标志寄存器上的表现如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/CmpResult.png\" title=\"cmp比较的结果\"></p>\n<p>那么我们这里执行完<code>cmp</code>之后看到这两个寄存器的内容如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/AfterCmpOperation.png\" title=\"cmp执行之后寄存器的内容\"></p>\n<p>我们再人肉比较一下这两个值吧：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/ActualValueForCmp.png\" title=\"两个值的具体内容\"></p>\n<p>可以发现<code>ebp+8</code>的值小于<code>ebp+0Ch</code>的值，所以说<code>zf</code>应该是0，<code>cf</code>应该是1，对照寄存器的内容，怎么样，我没有忽悠你吧。</p>\n<p>下面是一条新的指令<code>jae MSVCR80D!_initterm+0x25</code>，当然其实我现在也记不住那么多指令，只能依靠谷歌和翻书。<code>jae</code>指令的意思是：基于无符号数的比较结果，如果大于等于就执行后面的跳转。而前面比较的结果是小于，所以不会执行后面的跳转，指令选择继续往下执行。同样的指令还有很多，我这里不想介绍太多，大家可以自行翻书。</p>\n<p>下面三条语句也执行了同样的操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx, dword ptr [ebp+8]</span><br><span class=\"line\">cmp dword ptr [ecx], 0</span><br><span class=\"line\">je MSVCR80D!_initterm+0x1a</span><br></pre></td></tr></table></figure></p>\n<p>这里的意思也差不多，它先取<code>ebp+8</code>指向地址的值，把它放到ecx中，然后在将这个值指向的值与0进行比较，如果等于0的话就跳转到<code>MSVCR80D!_initterm+0x1a</code>处执行。这里具体比较内容和结果自己去探索，我这里就看到它执行了后面的跳转。然后他又执行了下面的这段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx, dword ptr [ebp+8]</span><br><span class=\"line\">add ecx, 4</span><br><span class=\"line\">jmp MSVCR80D!_initterm+0x3</span><br></pre></td></tr></table></figure></p>\n<p>它又一次取了<code>ebp+8</code>的值，并把它加4,所以更加肯定了<code>ebp+8</code>存放的是一个指针，这里只是对指针做了一个偏移操作。然后将<code>ecx</code>的值又放回了<code>ebp+8</code>指向的地址，接着跳转到了<code>_initterm+0x3</code>的位置，也就是下面这段代码：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/InitTermJmpBackToFuncHead.png\" title=\"跳转回去开头\"></p>\n<p>好了，整个函数就只剩下一段汇编没有分析了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov edx, dword ptr [ebp+8]</span><br><span class=\"line\">mov eax, dword ptr [edx]</span><br><span class=\"line\">call eax</span><br></pre></td></tr></table></figure></p>\n<p>看到<code>call eax</code>第一反应应该就是这肯定是调用了一个函数，只是这个函数可能是通过参数传递进来的。这里继续引用<code>ebp+8</code>指向的值，放到edx中，然后把这个值指向的内存内容放到eax中，而这个值则正好是一个函数的地址。</p>\n<p>因此我有理由相信，这个函数接受两个参数，第一个是<code>ebp+8</code>,第二个是<code>ebp+0Ch</code>，并且从<code>ebp+8</code>到<code>ebp+0Ch</code>这个范围中存放了一系列的函数的地址，而这个函数做的事情就是不断地循环，如果遇到不是空指针的就调用这个函数。我把这段函数具体化为C++代码，应该大致如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _initterm(<span class=\"keyword\">void</span>* from, <span class=\"keyword\">void</span>* to)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (from &lt; to)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*from != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            functype func = (functype)*from;</span><br><span class=\"line\">            func();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        from++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中functype我也不知道是什么类型，所以就遗留着吧。搞定了这个函数的含义，下面就好办了，就是不断地尝试进入函数体的内部，直到调用到了<code>SimpleClass</code>的构造函数位置。</p>\n<p>那我们调用到<code>eax</code>中函数的时候，就用F11调试进入函数内部（记得用<code>kbn</code>看下调用堆栈，以防调试错了地方，因为一共会调用两次<code>_initterm</code>函数，我们需要分析的是<code>__tmainCRTStartup</code>调用过来的<code>_initterm</code>函数）</p>\n<p>第一次调进来好像是调到了一个叫做<code>pre_cpp_init</code>的函数中了，这货居然还是HelloWorld2005中的函数，看看也无妨，可以更加了解一下运行的机制：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/HelloWorld2005PreCppInit.png\" title=\"pre_cpp_init函数\"></p>\n<p>国际惯例，前面两句保存堆栈，但是注意这里其实少了我们以前看到的那些<code>sub esp 120h</code>这样的语句，额，可能是没有声明局部变量？或者是被优化掉了？以后讨论。然后它将一个叫做<code>_RTC_Terminate</code>的函数进行压栈，这个函数我查了好久都没有找到是干嘛的，有熟悉的可以告诉我一下(<a href=\"mailto:cloudy064@gmail.com\" target=\"_blank\" rel=\"noopener\">cloudy064@gmail.com</a>)，或者等我加了评论模块再说，万分感谢。</p>\n<p>然后就是熟悉的两个个操作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call HelloWorld2005!atexit</span><br><span class=\"line\">add esp, 4</span><br></pre></td></tr></table></figure></p>\n<p>现在我们应该会知道之前压栈的<code>_RTC_Terminate</code>是一个<code>atexit</code>需要用到的参数，然后<code>pre_cpp_init</code>调用<code>atexit</code>函数，返回之后，利用<code>add esp, 4</code>清除临时变量，恢复堆栈。这里我就不进去<code>atexit</code>里面看了，我觉得会吐血，以后安排补丁文章来搞定这些一直没有分析的问题吧。</p>\n<p>继续看后面几句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [HelloWorld2005!_newmode]</span><br><span class=\"line\">mov dword ptr [HelloWorld2005!startinfo], eax</span><br><span class=\"line\">push offset HelloWorld2005!startinfo</span><br></pre></td></tr></table></figure></p>\n<p>依据以前的经验，这里的<code>HelloWorld2005!_newmode</code>和<code>HelloWorld2005!startinfo</code>应该是<code>HelloWorld2005</code>里面的全局变量，虽然我不知道它是在哪里初始化的，但是不妨碍我们继续分析。我们可以通过<code>dv</code>（dump value）指令来查看这两个变量的内容：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/PreCppInitDvResult.png\" title=\"用dv查看结果\"></p>\n<p>发现我们只能看到startinfo的类型信息，却得不到它的内容，这个时候应该介绍新指令:<code>dt</code>（dump type），这个指令可以在变量类型为符合类型（比如结构体）的时候发挥作用。利用<code>dt</code>指令查看到的结果如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/PreCppInitDtValueResult.png\" title=\"dt查看得到的结果\"></p>\n<p>恩，这下能够看到它的成员变量的值这些信息了。额，你还不放心，还想看它的结构体内部变量是怎么分布的？没问题，用<code>dt _startupinfo</code>来查看就行了，这里我就不贴出来结果了，大家自己试验吧。</p>\n<p>所以这里就只是初始化了全局变量<code>startinfo</code>，最后一句<code>push offset HelloWorld2005!startinfo</code>你就可以把它理解为将<code>startinfo</code>的地址入栈了。将一个变量或者地址进行入栈，在没有优化的情况下，十有八九就是准备调用函数了。</p>\n<p>接着看下面的语句中，有连续好几个压栈的操作，然后接一个函数调用，最后恢复堆栈：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx, dword ptr [HelloWorld2005!_dowildcard]</span><br><span class=\"line\">push ecx</span><br><span class=\"line\">push offset HelloWorld2005!envp</span><br><span class=\"line\">push offset HelloWorld2005!argv</span><br><span class=\"line\">push offset HelloWorld2005!argc</span><br><span class=\"line\">call dword ptr [HelloWorld2005!_imp____getmainargs]</span><br><span class=\"line\">add esp, 14h</span><br></pre></td></tr></table></figure></p>\n<p>当然这些也全部都是全局变量了，不过第一个是将<code>_dowildcard</code>这个变量压栈，下面三个是将<code>envp</code>,<code>argv</code>,<code>argc</code>的内存地址进行压栈，所以你可以把<code>_imp____getmainargs</code>函数看做是下面这个签名：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _imp____getmainargs(</span><br><span class=\"line\">    <span class=\"keyword\">void</span>* argc, </span><br><span class=\"line\">    <span class=\"keyword\">void</span>* argv, </span><br><span class=\"line\">    <span class=\"keyword\">void</span>* envp, </span><br><span class=\"line\">    <span class=\"keyword\">int</span> _dowildcard,</span><br><span class=\"line\">    _startupinfo* startinfo)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">//.......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>关于函数调用的参数顺序和入栈顺序以后会安排专题详细分析，这里就当参数是这个顺序吧。而这个函数从名字上来看就是用来初始化参数信息的，和我们的全局变量没有多大的关系，所以就不进去继续看了，直接跳过。</p>\n<p>往下再看几行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [HelloWorld2005!argret], eax</span><br><span class=\"line\">cmp dword ptr [HelloWorld2005!argret], 0</span><br><span class=\"line\">jge HelloWorld2005!pre_cpp_init+0x56</span><br></pre></td></tr></table></figure></p>\n<p>这里eax应该存放了刚刚调用<code>_imp____getmainargs</code>的返回值，之所以把它存放到另外一个全局变量里面，恩，可能是因为没有优化吧= =。这三句概括起来就是将返回值和0进行比较，如果返回值大于等于0（<code>jge</code>的意思就是jump if greater than or equal），那么就跳转到<code>pre_cpp_init+0x56</code>的位置；否则就继续执行。</p>\n<p>还剩下最后一段代码了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push 8</span><br><span class=\"line\">call HelloWorld2005!amsg_exit</span><br><span class=\"line\">add esp, 4</span><br></pre></td></tr></table></figure></p>\n<p>这段应该是强迫程序退出的一个函数吧，8是错误码。意思就是说，如果上面的返回值小于0，那么肯定就是程序出现了什么错误了，然后执行到这里就让程序已错误码8的结果退出。</p>\n<p>好了，我们整理一下这个<code>pre_cpp_init</code>函数，其实可以用C++代码表示成下面这个样子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pre_cpp_init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    atexit(&amp;_RTC_Terminate);</span><br><span class=\"line\">    startinfo.newmode = _newmode;</span><br><span class=\"line\">    argret = _imp____getmainargs(&amp;argc, &amp;argv, &amp;envp, _dowildcard, &amp;startinfo);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argret &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    amsg_exit(<span class=\"number\">8</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然可能和真实实现会有不一样，但是大致的流程应该不会错的。</p>\n<p>好吧，分析了半天我们还是没有找到调用<code>SimpleClass</code>构造函数的地方。不要急嘛，函数返回了继续看下去。</p>\n<p>第二次进入<code>call eax</code>，我们这个时候就看到了全局变量k的初始化了，代码如下所示：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/DynamicInitializerForK.png\" title=\"初始化全局变量K\"></p>\n<p>又是人肉分析代码的艰辛历程，前面一大坨就是我们以前熟悉的，先保存上一个堆栈以及寄存器的内容，然后分配一个<code>30h</code>大小局部变量堆栈空间给当前函数（我也不知道函数名叫啥），然后将这块内存初始化为<code>0xCCCCCCCC</code>，下面的这段代码才是真正执行构造函数的地方：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push <span class=\"number\">0</span>Ch</span><br><span class=\"line\">mov ecx, offset HelloWorld2005!k</span><br><span class=\"line\">call HelloWorld2005!SimpleClass::SimpleClass</span><br></pre></td></tr></table></figure></p>\n<p>这里其实可以看到在调用构造函数之前，编译器已经确定好全局变量<code>k</code>应该存放在什么位置了，而我们调用构造函数只是初始化<code>k</code>这块内存区域而已。这里讲12这个数进行压栈，然后将<code>k</code>的地址保存到<code>ecx</code>寄存器中，我猜ecx保存就一定是this指针！不然构造函数不知道初始化哪片内存。最后我们调用了构造函数。因为这里二进制代码已经写死了调用函数的地址，而不是通过函数名进行调用，所以不存在函数名有二义性的问题。</p>\n<p>我们进入到了构造函数里面，看到如下的代码：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/SimpleClassConstructorCode.png\" title=\"SimpleClass的构造函数\"></p>\n<p>前面里面有一个不同，那就是多了一句<code>push ecx</code>，要知道后面再执行初始化堆栈的时候，需要使用到<code>ecx</code>这个计数器的，而ecx之前保存了this指针的地址，所以说需要先将<code>ecx</code>的值压栈进行保存，这样才能保证this指针地址不会丢失。然后继续往下看，看到<code>pop ecx</code>处，这里就是执行一次出栈操作，恢复<code>ecx</code>中原有的this指针。</p>\n<p>接着函数执行了<code>mov dword ptr [ebp-8], ecx</code>这句话，要知道在没有开优化的情况下，<code>ebp-8</code>这个位置是第一个局部变量声明的位置，也就是说其实构造函数中隐藏了一个定义变量的操作<code>SimpleClass* this = ecx;</code>，所以现在大家知道this指针是怎么来的了吗？它保存在哪里也应该知道了吧。</p>\n<p>继续看，下面一句话是<code>mov eax, dword ptr [ebp-8]</code>，我要掀桌了（(╯‵□′)╯︵┻━┻），好好一个this指针到处传，就不能一步到位么。把桌子摆好，努力思考一下，我觉得将this指针放在局部变量的位置，可能是为了将this指针保存起来，能够随时获取，因为寄存器是经常变化的，一堆操作需要用到寄存器。而把this指针放到寄存器中，则是因为对于<code>dword ptr</code>这种类似于析址操作只支持寄存器的。哎，Intel的指令就是这么麻烦（我感到背后有一股杀气）。</p>\n<p>接下来就开始进行调用初始化器以及调用函数体了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [eax], offset HelloWorld2005!SimpleClass::`vftable&apos;</span><br></pre></td></tr></table></figure></p>\n<p>= =天哪，忘记了还有这货，这个看名字就知道是SimpleClass的虚函数表，因为我这里声明了一个虚函数，所以说这个类就会有一个虚函数表来承载虚函数的地址。而这个虚函数表就存放在this指针的基地址的位置。我们现在可以简单瞄一眼虚函数表，利用<code>dd eax</code>可以看到this指针指向内存的内容：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/SimpleClassThisPointToMemory.png\" title=\"this指针指向的内容\"></p>\n<p>第一个值就是虚表的地址了，至于虚拟地址里面存放了什么，我现在还不想研究，等真正讲到虚函数的时候再说吧。</p>\n<p>然后继续往下看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-8] ;取this指针</span><br><span class=\"line\">mov ecx, dword ptr [ebp+8] ;获取最后一个压栈的参数，这里只有一个就是12</span><br><span class=\"line\">mov dword ptr [eax+4], ecx ;给this指针偏移四个字节的地址进行赋值</span><br></pre></td></tr></table></figure></p>\n<p>前面两个都比较好理解吧，就是单纯的取值，对于最后一个的话，恩，看一看SimpleClass的内存分布大家应该就了解了，输入<code>dt SimpleClass</code>即可：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/DtSimpleClass.png\" title=\"SimpleClass的内存分布\"></p>\n<p>可以很容易看到，对于一个具体的<code>SimpleClass</code>实例，它的基地址存放了虚函数表指针，偏移4字节的地方存放了<code>a</code>变量的值，偏移8字节的地方存放了<code>b</code>变量的值。额最后一个就太奇怪了，它给我们的信息是它存放在一个固定的地址，并且它的类型是(null)，明明是<code>char*</code>好吧。所以它的内存结构用图来表示的话如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/SimpleClassMemoryMap.png\" title=\"SimpleClass的内存结构图\"></p>\n<p>最后那个静态变量不管它，讲到它的时候再说。</p>\n<p>所以上面的那句<code>mov dword ptr [eax+4], ecx</code>其实就是给成员变量<code>a</code>进行赋值，所以这三句其实就对应了代码中的初始化器<code>:a(m)</code>了。</p>\n<p>然后在往下看两行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dowrd ptr [ebp-8]</span><br><span class=\"line\">mov dword ptr [eax+8], 3</span><br></pre></td></tr></table></figure></p>\n<p>不用我说大家也明白了，这个就是给成员变量<code>b</code>进行赋值。</p>\n<p>那么这么一看，其实初始化器和在构造函数体中对变量进行初始化并没有什么区别啊。当然有！最明显的区别就是初始化的顺序，这个顺序后面会用多个例子来进行试验，这里先不说；另外一个区别就是初始化器调用的是构造函数，而函数体中的初始化调用的是赋值操作符，因为这里都是<code>int</code>，所以无法看出区别。</p>\n<p>好了分析完成构造函数了。等等，最后那个<code>ret</code>后面怎么多了个4，以前都是没有的啊。嗯嗯，这里的4只是恢复堆栈用的，这个具体会在函数调用约定里面详细讲解。这里只要知道<code>ret 4</code>其实就相当于下面两条指令就行了:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret</span><br><span class=\"line\">add esp, 4</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>画一个分隔线，只是因为前面讲的太多了，其实这里还有一个问题没有讲清楚，就是那个<code>dynamic initializer for &#39;k&#39;</code>的地址是谁传递过来的，这又是一个坑，还是得填啊。但是我现在不想填，好麻烦= =，留着以后想了解main函数之前做了什么的时候再来看这个坑吧，恩。（我中途发现了这样一个东西<a href=\"http://wiki.osdev.org/Visual_C%2B%2B_Runtime\" target=\"_blank\" rel=\"noopener\">http://wiki.osdev.org/Visual_C%2B%2B_Runtime</a>，打开有兴趣可以参考参考）</p>\n<p>然后不知不觉我们就来到了<code>main</code>函数调用的地方：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/ThePlaceWhereCallMain.png\" title=\"main函数调用的地放\"></p>\n<p>我们仍然可以看一下<code>main</code>函数它完整的函数签名是什么：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [HelloWorld2005!envp]</span><br><span class=\"line\">push eax</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [HelloWorld2005!argv]</span><br><span class=\"line\">push ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [HelloWorld2005!argc]</span><br><span class=\"line\">push edx</span><br><span class=\"line\"></span><br><span class=\"line\">call HelloWorld2005!main</span><br></pre></td></tr></table></figure></p>\n<p>可以看到它其实传给main函数三个参数，分别是<code>argc</code>,<code>argv</code>,<code>envp</code>，至于具体什么意思，自己百度一下啦。</p>\n<p>现在我们进入到<code>main</code>函数的主体，并定位到第一句代码执行的位置，如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/MainSimpleClassJ=233.png\" title=\"main函数执行的第一句代码\"></p>\n<p>准备数据没啥好说的，将<code>0E9h</code>(也就是233)进行压栈，然后将变量<code>j</code>的栈上地址，也就是this指针的值传递给<code>SimpleClass</code>的构造函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push 0E9h</span><br><span class=\"line\">lea ecx, [ebp-1Ch]</span><br><span class=\"line\">call HelloWorld2005!SimpleClass::SimpleClass</span><br></pre></td></tr></table></figure></p>\n<p>这里唯一的问题就是为什么<code>j</code>是保存在那个地址上，我们来算嘛。首先我们根据上面各种语句，可以得到当前函数局部堆栈的内存分布图如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/MainSimpleClassJ=233Stack.png\" title=\"此时的堆栈情况\"></p>\n<p>我把函数参数的区域标为黄色，分配给变量j的内存标为红色。好吧，这样看来没优化的时候，系统真的是有浪费4字节内存的习惯。</p>\n<p>然后代码就开始调用<code>SimpleClass</code>构造函数了，如此看来单参数构造函数的调用，下面两种调用方法所生成的汇编代码是相同的（此处只针对了系统内置类型，结构体的之后再验证）：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">SimpleClass <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">SimpleClass b = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure></p>\n<p>构造函数已经详细分析过了，所以就不进去继续看了。</p>\n<p>看下一句代码<code>SimpleClass k = ::k;</code>，这个从C++的层面来看的话，他应该调用我写的拷贝构造函数才对，那么我们来看对应的汇编代码吧：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push offset HelloWorld2005!k</span><br><span class=\"line\">lea ecx, [ebp-30h]</span><br><span class=\"line\">call HelloWorld2005!SimpleClass::SimpleClass</span><br></pre></td></tr></table></figure></p>\n<p>额，它好像没有对局部变量和全局变量进行直接的区分，因为，编译器TM就没有给局部变量取名字！！！局部变量是没有符号的。好吧，我的哪个局部变量和全局变量什么区别的问题就不是问题了。至于分配内存我也就不说了。这里主要就说明一下<code>SimpleClass</code>的拷贝构造函数好了：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/SimpleClassCopyConstructorCode.png\" title=\"拷贝构造函数\"></p>\n<p>我们直接跳到<code>004011b3</code>这一行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-8]</span><br><span class=\"line\">mov dword ptr [eax], offset HelloWorld2005!SimpleClass::`vftable&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-8] ; 拿到this指针</span><br><span class=\"line\">mov ecx, dword ptr [ebp+8] ; 拿到全局变量k的地址</span><br><span class=\"line\">mov edx, dword ptr [ecx+4] ; edx = k.a</span><br><span class=\"line\">mov dword ptr [eax+4], edx ; this.a = edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-8] ; 拿到this指针</span><br><span class=\"line\">mov ecx, dword ptr [ebp+8] ; 拿到全局变量k的地址</span><br><span class=\"line\">mov edx, dword ptr [ecx+8] ; edx = k.b</span><br><span class=\"line\">mov dword ptr [eax+8], edx ; this.b = edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-8]</span><br></pre></td></tr></table></figure></p>\n<p>= =好复杂的感觉，一句一句分析，此时<code>ebp-8</code>中保存的就是this指针的值。然后前面两句的意思就是初始化this指针的虚函数表，没有任何疑问。</p>\n<p>接下来的四句，因为在调用拷贝构造函数之前调用了一句<code>push offset HelloWorld2005!k</code>，所以现在上一个堆栈的顶部保存的其实就是全局变量<code>k</code>的地址。所以这里<code>mov ecx, dword ptr [ebp+8]</code>就是讲全局变量<code>k</code>的地址保存到<code>ecx</code>寄存器中。所以有了上面的注释之后基本上就不需要我讲解了。拷贝构造函数搞定！</p>\n<p>再往下看<code>Simple Class a(k)</code>的汇编代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea     eax, [ebp-30h]  ; 将局部变量k的地址保存到eax</span><br><span class=\"line\">push    eax             ; 将eax的值压栈</span><br><span class=\"line\">lea     ecx, [ebp-44h]  ; 分配局部变量内存，从ebp-44h开始的12个字节</span><br><span class=\"line\">call    HelloWorld2005!SimpleClass:SimpleClass  ;调用拷贝构造函数</span><br></pre></td></tr></table></figure></p>\n<p>不解释，依然和上面的构造过程一模一样。所以其实拷贝构造函数的调用下面两种方式也是完全相同的：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SimpleClass a = k;</span><br><span class=\"line\"><span class=\"function\">SimpleClass <span class=\"title\">b</span><span class=\"params\">(k)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>一个华丽的分割线之后，开始看函数的调用，我们这里主要是看各个函数之间的区别，对于函数主体，我们其实并不关注，看前面两个函数:<br><img src=\"/2016/04/21/windbg-windbg-chapter3/MainCompareTestAndTestConst.png\" title=\"比较const和非const函数\"></p>\n<p>他们几乎完全一样，通过ecx传递指针，然后调用对应的函数，const函数最后的const修饰符可以说是没有起到任何作用，要知道这个const是用来修饰this指针的，也就是说const成员函数中你不能对this指针指向的成员进行修改。但是就如同我上一章里面说的，const只是从语义上让你能够在编译期就能发现问题，要知道编译期找bug的代价比运行期找bug代价小很多的。</p>\n<p>这一次我们不去看它真正的实现，我们不如自己来写一个TestMemberFunc出来？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push ebp        ; 保存上一个堆栈的基地址</span><br><span class=\"line\">mov ebp, esp    ; 确定新的堆栈基地址</span><br><span class=\"line\">sub esp, 0C0h   ; 分配足够的堆栈，其实我觉得这里没有用到堆栈啊，可以不用这一步</span><br><span class=\"line\">push xxx        ; 忘记是啥</span><br><span class=\"line\">push xxx        ; 忘记是啥</span><br><span class=\"line\">push xxx        ; 忘记是啥</span><br><span class=\"line\">push ecx        ; 保存this指针</span><br><span class=\"line\">; 初始化这块堆栈区域，忘记什么命令了</span><br><span class=\"line\">pop ecx         ; 恢复this指针</span><br><span class=\"line\">mov dword ptr [ebp-8], ecx ; 将this指针保存到栈底</span><br><span class=\"line\">mov eax, dword ptr [ebp-8] ; 将this指针拷贝到eax中</span><br><span class=\"line\">mov ecx, dword ptr [eax+4] ; 拿到a的值</span><br><span class=\"line\">add ecx, dword ptr [eax+8] ; 加上b的值</span><br><span class=\"line\">mov dword ptr [eax+4], ecx ; 将得到的和保存到a的位置中</span><br><span class=\"line\">pop xxx</span><br><span class=\"line\">pop xxx</span><br><span class=\"line\">pop xxx </span><br><span class=\"line\">mov esp, ebp</span><br><span class=\"line\">pop ebp</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure></p>\n<p>我觉得差不多应该是这个样子，不管那么多了。这个只是一个我自己想做的一个练习而已，继续往下面执行。</p>\n<p>接着就是虚函数，汇编代码如下图所示:<br><img src=\"/2016/04/21/windbg-windbg-chapter3/MainCallTestVirtual.png\" title=\"调用虚函数\"></p>\n<p>好像我还是觉得没什么特别的地方，通过<code>push</code>传递参数，通过<code>ecx</code>传递this指针，进去函数实现的地方看也和普通函数的调用没有什么区别。好吧，可能要等到用到继承的时候才会出现区别吧。</p>\n<p>所以在这种没有继承的情况下，成员函数，const成员函数和虚函数之间完全是没有任何区别的。</p>\n<p>看完最后一个<code>int d = SimpleClass::TestStatic(12, 13)</code>就可以解放了，相信看了汇编代码的人会觉得，这个函数是最没有技术含量的了：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/MainCallTestStatic.png\" title=\"调用静态函数\"></p>\n<p>简单来说就和普通的全局函数是一模一样的，唯一的区别就是静态函数前面要加一个类名加一个域操作符。</p>\n<p>啊！终于都分析完了。“诶，好像还有一个静态成员变量你还没说吧？”，我。。。。。。你这个同学记性能不能放差一点，我现在好累了= =</p>\n<p>好的，之前我们用<code>dt</code>命令查看了<code>SimpleClass</code>的内存结构，我们再看一下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/DtSimpleClass.png\" title=\"SimpleClass的内存结构\"></p>\n<p>发现str的地址并不是一个偏移量，而是一个固定的地址<code>00406000</code>，记住这个是<code>str</code>变量保存的地址，而不是<code>&quot;joker&quot;</code>这个字符串的地址。如果要确定它指向字符串的地址，那么就输入<code>dd 0040600</code>：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/dd00406000.png\" title=\"str指向的内存内容\"></p>\n<p>拿到第一个值，这个值就是<code>&quot;joker&quot;</code>存放的地址了，继续输入<code>da 0040412c</code>（<code>da</code>的意思应该是dump ansi）：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/da0040412c.png\" title=\"查看str指向的字符串\"></p>\n<p>好吧，既然讲到静态变量了，那么我问大家一个问题，静态变量存放在程序的什么区段：</p>\n<ol>\n<li>text段</li>\n<li>rdata段</li>\n<li>data段</li>\n<li>rsrc段</li>\n</ol>\n<p>能搞明白么？好吧，为了寻找这个问题的答案，我们不妨打印出这个程序所有的头部信息吧。利用<code>dh! -s HelloWorld2005</code>（dh的意思是表示dump header,-s表示只展示区段信息）<br><img src=\"/2016/04/21/windbg-windbg-chapter3/DumpHelloWorldHeaders.png\" title=\"程序的头部区段信息\"></p>\n<p>但是这里所有的数据都是相对于HelloWorld2005.exe最开始的地方，<br><img src=\"/2016/04/21/windbg-windbg-chapter3/lmvmHelloWorld2005.png\" title=\"HelloWorld2005.exe在程序中的真实地址范围\"></p>\n<p>那这样的话我们就能确认到各个区段的实际内存范围：<br><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text段       <span class=\"number\">00401000</span>~<span class=\"number\">0040313C</span></span><br><span class=\"line\">rdata段      <span class=\"number\">00404000</span>~<span class=\"number\">0040515C</span></span><br><span class=\"line\">data段       <span class=\"number\">00406000</span>~<span class=\"number\">00406418</span></span><br><span class=\"line\">rsrc段       <span class=\"number\">00407000</span>~<span class=\"number\">004071B4</span></span><br></pre></td></tr></table></figure></p>\n<p>先来看<code>str</code>变量的地址，是<code>00406000</code>，它好像正好就是data段的起始地址，毫无疑问了那就，静态成员变量被存放在data段中。</p>\n<p>我们再来看看<code>&quot;joker&quot;</code>这个字符串，它的地址是<code>0040412C</code>，而这个地址落在了rdata段中。我们不妨把rdata段中的所有的字符串都列举出来，眼见为实。我们可以用<code>s -sa HelloWorld2005+4000 L115C</code>命令来搜索这个rdata内存区间里面所有的ANSI字符串，我这里输出的结果如下：<br><img src=\"/2016/04/21/windbg-windbg-chapter3/s-saHelloWorld2005+4000L115C.png\" title=\"rdata段中的所有ANSI字符串\"></p>\n<p>毫无悬念你可以找到<code>&quot;joker&quot;</code>这个字符串。</p>\n<p>好了这些就把所有的东西都讲完了，遗留下来的坑，下一个章节会填完。大家慢慢消化吧，拜拜！</p>\n<h2 id=\"回顾：\"><a href=\"#回顾：\" class=\"headerlink\" title=\"回顾：\"></a>回顾：</h2><h3 id=\"关于WinDBG\"><a href=\"#关于WinDBG\" class=\"headerlink\" title=\"关于WinDBG\"></a>关于WinDBG</h3><ol>\n<li><code>dv</code>命令用于查看局部变量，如果想查看全局变量记得前面加上<code>模块名!</code></li>\n<li><code>dt</code>命令用于查看结构体的分布情况，也可以以结构体来解析对应的内存</li>\n<li><code>!dh</code>命令可以用于查看模块的头部信息，具体参数请自行补充</li>\n<li><code>s</code>命令可以用于搜索内存，具体参数请自行补充</li>\n</ol>\n<h3 id=\"关于汇编\"><a href=\"#关于汇编\" class=\"headerlink\" title=\"关于汇编\"></a>关于汇编</h3><ol>\n<li><code>ret 4</code>指令在返回的同时，也会将栈顶指针加4（清空堆栈）</li>\n<li>在调用类函数的时候，包括构造函数，通过<code>ecx</code>寄存器传递this指针，并在函数内部，将this指针的值保存在<code>ebp-8</code>的位置</li>\n</ol>\n<h3 id=\"关于C\"><a href=\"#关于C\" class=\"headerlink\" title=\"关于C++\"></a>关于C++</h3><ol>\n<li>全局变量在是main函数之前初始化的</li>\n<li>全局变量的内存是在编译期就已经被决定了的</li>\n<li>类的虚函数表是在构造函数中进行初始化的</li>\n<li>虚函数表放在this指针指向的基地址位置</li>\n<li>const成员函数和非const成员函数在实现上并没有任何不同，只是便于编译器能够在编译期就把问题抛出来</li>\n<li>在没有继承的情况下，成员函数和虚函数并没有什么不同</li>\n<li>静态函数和普通函数也没有什么不同，只是静态函数调用的时候需要加上类名加上域作用符</li>\n<li>静态成员变量存放在<code>data</code>区段</li>\n<li>常量字符串存放在<code>rdata</code>区段</li>\n<li>main函数的完整签名是int main(int argc, char<strong> argv, char</strong> envp);</li>\n<li>函数入口并不存放在类的结构中</li>\n</ol>"},{"title":"WinDBG观世界（二）","date":"2016-04-20T05:19:11.000Z","_content":"\n## 导言\n前面一章主要讲述了C++函数的调用过程在汇编中的具体执行过程，如果还不熟悉的同学也没关系，后面仍然会不断重复函数的讲解。之所以没有对release版本的exe进行分析，是因为编译器优化后，很多未使用的变量和函数都会被丢弃掉，所以其实优化后的版本没有多少参考意义。对于release的分析将安排到程序稍微复杂一点时进行。\n\n本章的内容仍然很简单，主要引入了struct关键字，所以现在大家可以开始定义自己的结构体了。并且本章还会稍微分析一下指针、引用的区别，以及const在最终代码中的作用。好了，闲话少叙，看看今天的代码吧。\n<!--more-->\n## 慢慢地趋向结构化\n今天的代码内容如下：\n```cpp\ntypedef struct Simple\n{\n    int a;\n    int b;\n    char c;\n    short d;\n    unsigned int e;\n} Simple;\n\nvoid TestValue(Simple s)\n{\n\n}\n\nvoid TestReference(Simple& s)\n{\n\n}\n\nvoid TestPointer(Simple* s)\n{\n\n}\n\nvoid TestConstReference(const Simple& s)\n{\n\n}\n\nSimple TestReturn()\n{\n    Simple s;\n    s.a = 10;\n    s.b = 20;\n    s.c = 30;\n    s.d = 40;\n    s.e = 50;\n\n    return s;\n}\n\nint main(int argc, char** argv)\n{\n    Simple s = TestReturn();\n    TestValue(s);\n    TestReference(s);\n    TestPointer(&s);\n    TestConstReference(s);\n\n    Simple e = {0};\n\n    return 0;\n}\n```\n\n这次的主人公是结构体，所以函数的实现基本上都是空。大家在继续阅读的同时，最好能够带着下面几个问题：\n1. Simple结构体的内存分布\n2. 指针和引用的区别\n3. const引用和非const引用有什么区别\n4. 返回值存放在局部堆栈的什么位置，能不能用ebp将这个位置表示出来\n5. 返回值是怎么传递给调用的地方的\n6. Simple e = {0}这句代码做了什么事情\n\n如果你上面的问题的答案都能够如数家珍，那么这篇博客不适合你，你可以不用往下面读了。没有了解的同学跟着我一起来看看windows最终是怎么执行我们写的这段代码的吧。\n\n依旧是打开WinDBG，然后加载HelloWorld2005.exe，然后输入`bp HelloWorld2005!main`，让它能够在main函数的时候断下来，输入g运行。按下`alt+7`打开汇编代码，并将`Source Mode`勾选框去掉。做好这一切之后，就可以开始一步一步调试代码了。\n\nF10单步调试，当`main`函数保存完所有寄存器的值之后，然后可以看到第一句话`TestReturn`是从下图开始执行的：\n{% asset_img begin.png 主代码开始执行 %}\n\n还记得`ebp`是什么吗？当前函数堆栈的基地址，`ebp~esp`的范围就组成了当前函数的局部变量的存放地址范围（包括过程中可能出现的`push`操作所占用的栈内存）。下面要执行的`lea eax, [ebp-104h]`就是把`ebp-104h`的值赋值给`eax`，（这里注意取内存中的值和取表达式的值是不一样的，`mov eax, qword ptr [ebp-104h]`就是取`ebp-104h`指向地址的内存内容，而`lea eax, [ebp-104h]`则是把`ebp-104`的结果赋值给`eax`）现在并不知道这句话有什么卵用。然后它又把`eax`压栈了，好吧，这个具体什么作用先遗留着，也许以后会用到。\n\n然后终于开始调用TestReturn函数了，我们用F11进入到函数的内部查看一下，这里我就把堆栈的初始化代码给跳过了，如下：\n{% asset_img TestReturnAssembly.png TestReturn函数体的内容 %}\n\n好了现在开始就是要接触结构体的相关内容了。在开始这个之前，我想说明的是，WinDBG给我们提供了一个查看结构体内存分布的命令dt（应该是dump type的缩写吧），输入`dt HelloWorld2005!Simple`，可以看到Simple这个结构体在内存中的相对分布情况，如下图所示：\n{% asset_img dtHelloWorld2005Simple.png Simple结构体的分布 %}\n\n不如再用一个图来表示一下Simple结构体成员变量的分布情况吧：\n{% asset_img SimpleStructMemory.png Simple结构体的分布图 %}\n\n一目了然，在确定了Simple结构体实例的基地址之后（假设为`p`吧），`a`变量就存放在`p+0x000`的位置，`b`变量就存放在`p+0x004`的位置，以此类推。然后 你就会发现`c`和`d`这两个变量共享了同一个DWORD大小的空间，这就是我们以前曾经学过的内存对齐。了解了这些是不是更加清楚了呢，那么我提一个小问题，当成员变量只有一个`char`的时候会发生内存对齐么？当一个`short`和两个`char`作为成员变量的时候，会发生怎么样的对齐？修改一下变量声明的顺序又会出现什么情况？留着自己去发现吧。\n\n言归正传，我们下面看到的几句话是：\n```asm\nmov dword ptr [ebp-14h], 0Ah ; s.a = 10;\nmov dword ptr [ebp-10h], 14h ; s.b = 20;\nmov byte ptr [ebp-0Ch], 1Eh  ; s.c = 30;\nmov word ptr [ebp-0Ah], 28h  ; s.d = 40;\nmov dword ptr [ebp-8], 32h   ; s.e = 50;\n```\n\n这里的分号表示注释，我这里在每一句汇编的后面都加上了它所对应的C++代码。诶，第一句的`Simple s;`去哪里了？难道是没有执行？当然不是了。再回到标识符的概念上来，永远记住标识符只是代表了一块内存，它并不占用内存，你可以把标识符就理解为一块内存的名字。而这里s代表的起始就是从`ebp-14h`到`ebp-4`范围的这块内存，根据上面得出的`Simple`的内存结构，其实不难得出`ebp-14h`就是`Simple`实例`s`的基地址，也就是a存放的位置，我们可以用`dd ebp-14h L4`（L4用来声明查看多少个DWORD长度）来查看一下这一块的内存，如下图：\n{% asset_img ddebp-14hL4.png s结构体的内容 %}\n\n可以看出从左向右依次是a到e的值，额，貌似有点不对，对于c和d需要重点关注一下。第三个DWORD的内容是`0028cc1e`，首先30的16进制是1eh，40的16进制是28h，我们对应到内存中的内容时，可以发现`0028cc1e`的前两个字节（高字节）保存的是d的值；第三个字节的内容是`cc`，是windows的无效数据；第四个字节保存的是c的值。恩，好像有点明白了，windows采用的是大端模式来保存内存数据的。如果还不明白的话，我们不如用`db ebp-14h L10`来以字节为单位查看内存的内容（db的意思是dump byte，dw表示dump word，dd表示dump dword）:\n{% asset_img dbebp-14hL10.png s结构体中字节内容 %}\n\n好，现在是不是发现所有的字节都颠倒了？就拿a变量来说，它标识的是前四个字节的内容，但是我们在上图中看到的这四个字节依次是`0a 00 00 00`，也就是说大端模式下，最低位的字节会放在最高的地址上，所以阅读这个内存的真正顺序是从右往左读，读取四个字节拼接起来。你之所以用dd看到的是正确的顺序，是因为winDBG给你优化了。那么我们继续观察s实例中第三个DWORD的内存内容，现在应该知道怎么读取了吧，成员变量c相对于结构体的偏移地址是0x008，从开头向后数8个字节（当然你如果熟悉命令的话，也可以输入`dd ebp-14h+8 L4`），然后c是一个char，所以只需要读取一个字节，那么它的内容就是`1e`；同样的方式你可以读取一下d的内存内容。这里再拓展一下，不仅读取内存是按照大端的方式来读取，写入内存也是同样的，这个之后再看汇编的时候大家注意一下。\n\n解决了结构体的内存分布问题，我们再看一下成员变量`e`，它和`a`的区别就是多了一个`unsigned`修饰符，但是汇编代码中没有体现出这个特性。编译器出错了？呵呵，这个问题等以后将数值的表示的时候再来慢慢研究（推荐可以去看CSAPP这本书）。\n\n恩，我重新提一下局部变量s表示的内存范围是`ebp-14h`到`ebp-4`，在之后会用到。继续人肉执行代码：\n```asm\nmov eax, dword ptr [ebp+8]\n\nmov ecx, dword ptr [ebp-14h]\nmov dword ptr [eax], ecx\n\nmov edx, dword ptr [ebp-10h]\nmov dword ptr [eax+4], edx\n\nmov ecx, dword ptr [ebp-0Ch]\nmov dword ptr [eax+8], ecx\n\nmov edx, dword ptr [ebp-8]\nmov dword ptr [eax+0Ch], edx\n```\n\n第一句代码我现在也没有看懂是干嘛的，但是我知道ebp+8这个地址其实已经到了main函数的局部内存地址空间了，可能是和返回值有关我觉得。往下走，`move ecx, dowrd ptr [ebp-14h]`这里是把变量`a`放到`ecx`中我知道，貌似开始挪数据了。接着的`mov dword ptr [eax], ecx`，就把`ecx`的内容，也就是变量`a`的值拷贝到了eax指向的内存中了。下面的三组语句貌似和这两句相同，都是在拷贝变量的值。但是有5个变量，为什么只拷贝了四次内存呢？我觉得应该不用我解释吧。\n\n下面的一句`mov eax, dowrd ptr [ebp+8]`，又一次把`ebp+8`指向的内存的内容拷贝到了eax中，哎，没有优化的代码就是一堆傻逼操作。但是`ebp+8`保存的究竟是什么呢？额，我忘了保存这些东西了，所以再跟着我`Ctrl+Shift+F5`重新执行一次程序吧，回到main函数调用的地方：\n{% asset_img BeforeCallTestReturn.png 调用TestReturn之前 %}\n\n我们画一个图吧，以免忘记了当前堆栈的样子：\n{% asset_img BeforeCallTestReturnStack.png 调用TestReturn之前的堆栈 %}\n\n我特意标红了eax中保存的地址对应的地址空间，后面会用到这个地址，现在先忽略它。\n\n好了，然后我们执行`TestReturn`这个函数，堆栈内容如下：\n{% asset_img AfterCallTestReturn.png 调用TestReturn之后 %}\n\n在执行完前面三句代码之后，所形成的内存堆栈的图如下：\n{% asset_img AfterCallTestReturnStack.png 调用TestReturn之后的堆栈 %}\n\n这样你应该就能清楚地看到`ebp+8`保存的内容就是上一个堆栈中的eax的值，也就是0019fe24，也就是我标红的堆栈空间。但是至于为什么没有从上一个堆栈的头或者尾开始使用，我也暂时不知道，我暂时认为它是乱选的一个空闲内存。\n\n这样的话，经过刚刚的赋值拷贝，结果就是将变量s的内存原封不动拷贝到了`0019fe24~0019fe24+14h`地址空间中，所以你也可以这样理解，`main`函数传递了一个隐形的指针给`TestReturn`函数，而这个指针指向的内存就用于保存返回值。这个问题解决了我们就可以继续往下面执行了。\n\n下面的几句代码如下：\n```asm\npush edx\nmov ecx, ebp\npush eax\nlea edx, [HelloWorld2005!TestReturn+0x74]\ncall HelloWorld2005!_RTC_CheckStackVars\n```\n\n从函数名能够看出这个其实是检查堆栈的，至于内部具体实现，本次不做任何分析，以后单独立一篇文章来搞定它。只是注意这里之所以要`push eax`，应该是_RTC_CheckStackVars这个函数会用到`eax`这个寄存器来保存返回值，所以说将它放到堆栈上保存起来，以供以后恢复。\n\n继续看下面的代码：\n```asm\npop eax\npop edx\npop edi\npop esi\npop ebx\nmov esp, ebp\npop ebp\nret\n```\n\n这里第一句就是恢复刚刚保存的`eax`的值，至于你想说“它傻么，为什么不先调用_RTC_CheckStackVars，再执行`mov eax, dowrd ptr [ebp+8]`”，额~~~~，好吧它确实很傻。之后的`pop edx`也是同样的作用。然后后面的三句是用来恢复上一个堆栈中的寄存器信息，与函数开始处的`push`对应。然后的两句则是用来恢复上一个堆栈的地址空间的，最后一句`ret`标识返回。\n\n直到这里我们知道了eax中保存着一个指针，它指向了`0019fe24`，之后的14h个字节的地址内容都是返回值的内容，那么我们就继续来看看返回到`main`函数之后又做了哪些事情吧：\n{% asset_img AfterTestReturnReturn.png TestReturn返回之后 %}\n\n首先我们再回顾一下它的堆栈空间的内容：\n{% asset_img BeforeCallTestReturnStack.png 此时main函数中堆栈分布 %}\n\n然后执行`add esp, 4`，这句话等价于将栈顶元素出栈，只不过栈顶元素没有变量来保存，而只是单纯的丢弃掉。此时栈顶元素就是eax的值，也就是返回值的地址。\n\n看接下来执行的几句代码：\n```asm\nmov ecx, dword ptr [eax]\nmov dword ptr [ebp-11Ch], ecx\n\nmov edx, dword ptr [eax+4]\nmov dword ptr [ebp-118h], edx\n\nmov ecx, dword ptr [eax+8]\nmov dword ptr [ebp-114h], ecx\n\nmov edx, dword ptr [eax+0Ch]\nmov dword ptr [ebp-110h], edx\n```\n\n是不是似曾相识呢？和刚刚返回值的拷贝一样对不对，只是这一次是把`0019fe24`处的内存地址拷贝到`ebp-11Ch`。好了往下看还有一样的代码：\n```asm\nmov eax, dword ptr [ebp-11Ch]\nmov dword ptr [ebp-14h], eax\n\nmov ecx, dword ptr [ebp-118h]\nmov dword ptr [ebp-10h], ecx\n\nmov edx, dword ptr [ebp-114h]\nmov dword ptr [ebp-0Ch], edx\n\nmov eax, dword ptr [ebp-110h]\nmov dword ptr [ebp-8], eax\n```\n\n这里又发生了一次内存的拷贝，将`ebp-11Ch`的内容拷贝到了`ebp-14h`的地方。所以想想吧，在完全没有开优化的情况下，返回一个结构体居然要拷贝三次内存，确实很浪费内存和时间啊。当然我现在也不知道优化之后会怎么样，可能会变好吧，以后再研究release。\n\n那经过这样一番折腾，返回值终于到了我们熟悉的位置`ebp-14h~ebp-8`这个区间。好吧，它还是给你空出来4个字节，我还没弄清楚这空出来的4个字节究竟能用来干嘛。到现在为止，`TestReturn`函数的调用已经讲完了，大家现在可以慢慢消化一下再继续。\n\n---\n\n跨过华丽的分割线，我们继续看下面的`TestValue`函数（现在s的值保存在`ebp-14h~ebp-8`的区间中）。从准备参数到调用`TestValue`，汇编代码如下：\n{% asset_img CallTestValue.png 调用TestValue %}\n\n首先它执行`sub esp, 10h`，应该是给`TestValue`传入的参数预留空间，我猜的。然后又是一坨类似的拷贝代码：\n```asm\nmov eax, esp\n\nmov ecx, dword ptr [ebp-14h]\nmov dowrd ptr [eax], ecx\n\nmov edx, dword ptr [ebp-10h]\nmov dword ptr [eax+4], edx\n\nmov ecx, dowrd ptr [ebp-0Ch]\nmov dword ptr [eax+8], ecx\n\nmov edx, dword ptr [ebp-8]\nmov dword ptr [eax+0Ch], edx\n```\n\n我不想详细说了，第一句`eax`保存了`esp`的值，`esp`指向了当前的栈顶。而这段代码就是把`s`的内容拷贝到刚刚预留的堆栈空间中，也就是`esp~esp+10h`这块内存中。所以其实你可以理解为现在堆栈的顶部16个字节保存着s的内容。然后我们就开始调用`TestValue`函数了，记得这里有一个把`TestValue`返回继续执行的地址进行压栈的隐式操作。然而`TestValue`函数的实现我并没有写任何东西，所以说可以直接过了。\n\n所以这里我想让大家知道的是，函数参数的地址是通过堆栈进行传递的，而这个堆栈的内存其实是由上一个函数的局部堆栈提供的，保存在上一个函数局部堆栈的栈顶位置。所以说在函数中使用这些内存的时候，是通过`esp+8`这样的偏移的形式来进行引用的。具体细节大家可以自己写代码进行研究啦，我就不赘述了。\n\n继续往下面执行`TestReference`函数，它执行的代码逻辑如下：\n{% asset_img CallTestReference.png 调用TestReference %}\n\n哦哦对，还有一个没有讲，在`TestValue`返回之后，又执行了这样一句代码：`add esp, 10h`，这个其实就是清空按值传递时，堆栈上产生的临时对象的（虽然没有真正清空）。\n\n接着执行`lea eax, [ebp-14h]`，应该还记得`ebp-14h`的位置上保存着什么么？s变量在堆栈上的基地址。把它赋值给`eax`寄存器后，利用`push eax`进行压栈，然后接着就调用了`TestReference`函数。而在函数中你要使用这个栈上变量的方式，和上面相同，也是同样引用`esp+8`指向的值（这里说明下`esp`指向的是上一个函数的堆栈基地址，`esp+4`指向的是该函数返回后继续执行的地址，`esp+8`开始才是上一个函数堆栈的顶部），比如如果这里我需要在函数中执行一个`s.a=10`的语句的话，那么汇编代码可能是如下所示的：\n```asm\nlea eax, [ebp+8]            ;得到引用的变量的指针\nmov ecx, 0ah;               ;将10这个值放到ecx寄存器中\nmov dword ptr [eax], ecx    ;将10这个值真正放到目标地址\n```\n\n当然这些都是我自己写的，只是为大家做一个演示，如何读取和写入引用变量的内容。如果你要验证的话最好以实际生成的代码为准。\n\n接着往下看`TestPointer`函数的调用，诶，居然和`TestReference`生成的代码一模一样：\n{% asset_img CallTestPointer.png 调用TestPointer %}\n\n当然一开始恢复堆栈的那句代码不算啦。所以这个函数我们就不分析了，直接过。\n\n往下再瞄几行，发现调用`TestConstReference`的代码好像也是一模一样：\n{% asset_img CallTestConstReference.png 调用TestConstReference %}\n\n好吧，现在应该能够清楚下面几个问题了：\n1. 编译器如何实现引用的？ 答案是指针，至少在VS2005上是的。\n2. 指针和引用有什么区别？ 好像也没什么区别\n3. const引用和引用有什么区别？ 好像也是一样的\n\n那么问题来了，既然指针、引用、const引用都是同一个实现，那么为什么C++还要分那么多东西呢？有想过没有？自己想1分钟，再往下看。\n\n---\n\n好吧，我来说下我的理解，其实指针和引用还是有区别的啊，指针有空指针，引用却没有空引用，这是指针和引用的本质区别。使用引用的一个好处就是，能够从语法的层面杜绝你出现空指针的情况，减少因为空指针导致的崩溃。而使用const引用呢，则是从语义的层面，在编译期就能够判断出你非法的赋值操作，比如说你传了一个const引用给函数，那么你的本意肯定是不希望这个变量被改变，但是你在函数里面对这个const引用赋值了，那么编译器在进行语义分析的时候就能够帮你纠正出这个错误，至于减少bug的话，不同场景不同表现啦。因为有一堆人在遇到这种语义错误的时候，选择的是去掉const，而不是继续调整代码的结构。所以，对于const的使用，见仁见智吧。\n\n最后一个`Simple e = {0}`算是一个额外的扩展研究吧，我们可以看下他的代码：\n{% asset_img InitSimple.png 对结构体进行初始化 %}\n\n我们可以看到下面这四句代码是初始化成员变量的内容的：\n```asm\nmov dword ptr [ebp-2Ch], 0      ;a\nmov dword ptr [ebp-28h], eax    ;b\nmov dword ptr [ebp-24h], eax    ;c和d\nmov dword ptr [ebp-20h], eax    ;e\n```\n\n但是为什么第一个变量的初始化方式不同，我也不知道，我也想掀桌啊妈蛋，不过反正结果都一样，VS这样做可能是傻逼了吧。可以知道他其实是以DWORD（4个字节）为单位进行初始化的，而不是一个变量一个变量进行初始化的，其实相当于做了一个`memset`的过程。\n\n你还不知道`eax`是啥？看这句代码`xor eax, eax`，`xor`就是亦或，任何值和自己亦或得到的结果都是0，所以这句代码就已经将eax的值覆盖成0了。至于它和`mov eax, 0`有什么区别，嘿嘿，我们不妨看下面两个语句的二进制代码，都是我从真实的代码里面摘抄的，分号之前的是汇编代码对应的二进制代码，分号后面的是汇编代码：\n```asm\nbacccccccc      ;mov     edx,0CCCCCCCCh\n33c0            ;xor     eax,eax\n```\n\n能看出区别来了么，对，保存`mov`语句比保存`xor`语句需要更多的存储空间，所以用xor生成代码更加简短。这里也算是一种优化吧。\n\n那么此时我们不妨看一下e在内存中的内容，利用`dd ebp-2Ch L4`即可：\n{% asset_img ddebp-2ChL4.png e在内存中的内容 %}\n\n好吧全都是0，没啥好看的。\n\n那么到这里讲解就全都结束了，至于main函数后面还有的那部分，可以完全参考我上一章将的内容，只做了两件事情，一个就是检查堆栈，另外一个就是恢复上一个函数的堆栈和寄存器。由于该代码过于简单，release版本基本上会被优化得不剩什么代码，所以照旧不讲解release版本的汇编代码。\n\n那么下次再见吧，拜拜！\n\n## 回顾：\n\n### 关于WinDBG\n无\n\n\n### 关于汇编\n1. ebp指向了上一个函数堆栈的基地址\n2. ebp+4指向了函数返回时，继续执行的地址\n3. ebp+8是上一个函数局部堆栈的栈顶，一般函数参数都保存在这个地方\n4. 调用函数时，会发生一个隐式的压栈操作，即把`call`指令的下一个指令的地址进行压栈，（其实这个地址的值就是`eip`，在函数ret时，同样也会执行一个`pop eip`的操作）\n5. `mov eax, 0`需要5个字节记录，`xor eax, eax`只需要两个字节\n6. 区分取寄存器的值（`lea eax, [ebp+8]`）和取寄存器指向地址的内容（`mov eax, dword ptr [ebp+8]`）\n\n### 关于C++\n1. 结构体初始化器所做的操作其实和`memset`类似，不会按照变量为单位进行初始化，而是按照DWORD为单位进行初始化\n2. 指针、引用在VS2005上的实现并没有什么区别，唯一的区别就是指针可空，引用不可空\n3. 引用和const引用在实现上也没有任何区别，只是方便了编译器在语义分析时及时报错","source":"_posts/windbg/windbg-chapter2.md","raw":"---\ntitle: WinDBG观世界（二）\ndate: 2016-04-20 13:19:11\ncategories: windbg\ntags: [windbg,disassembly,c++]\n---\n\n## 导言\n前面一章主要讲述了C++函数的调用过程在汇编中的具体执行过程，如果还不熟悉的同学也没关系，后面仍然会不断重复函数的讲解。之所以没有对release版本的exe进行分析，是因为编译器优化后，很多未使用的变量和函数都会被丢弃掉，所以其实优化后的版本没有多少参考意义。对于release的分析将安排到程序稍微复杂一点时进行。\n\n本章的内容仍然很简单，主要引入了struct关键字，所以现在大家可以开始定义自己的结构体了。并且本章还会稍微分析一下指针、引用的区别，以及const在最终代码中的作用。好了，闲话少叙，看看今天的代码吧。\n<!--more-->\n## 慢慢地趋向结构化\n今天的代码内容如下：\n```cpp\ntypedef struct Simple\n{\n    int a;\n    int b;\n    char c;\n    short d;\n    unsigned int e;\n} Simple;\n\nvoid TestValue(Simple s)\n{\n\n}\n\nvoid TestReference(Simple& s)\n{\n\n}\n\nvoid TestPointer(Simple* s)\n{\n\n}\n\nvoid TestConstReference(const Simple& s)\n{\n\n}\n\nSimple TestReturn()\n{\n    Simple s;\n    s.a = 10;\n    s.b = 20;\n    s.c = 30;\n    s.d = 40;\n    s.e = 50;\n\n    return s;\n}\n\nint main(int argc, char** argv)\n{\n    Simple s = TestReturn();\n    TestValue(s);\n    TestReference(s);\n    TestPointer(&s);\n    TestConstReference(s);\n\n    Simple e = {0};\n\n    return 0;\n}\n```\n\n这次的主人公是结构体，所以函数的实现基本上都是空。大家在继续阅读的同时，最好能够带着下面几个问题：\n1. Simple结构体的内存分布\n2. 指针和引用的区别\n3. const引用和非const引用有什么区别\n4. 返回值存放在局部堆栈的什么位置，能不能用ebp将这个位置表示出来\n5. 返回值是怎么传递给调用的地方的\n6. Simple e = {0}这句代码做了什么事情\n\n如果你上面的问题的答案都能够如数家珍，那么这篇博客不适合你，你可以不用往下面读了。没有了解的同学跟着我一起来看看windows最终是怎么执行我们写的这段代码的吧。\n\n依旧是打开WinDBG，然后加载HelloWorld2005.exe，然后输入`bp HelloWorld2005!main`，让它能够在main函数的时候断下来，输入g运行。按下`alt+7`打开汇编代码，并将`Source Mode`勾选框去掉。做好这一切之后，就可以开始一步一步调试代码了。\n\nF10单步调试，当`main`函数保存完所有寄存器的值之后，然后可以看到第一句话`TestReturn`是从下图开始执行的：\n{% asset_img begin.png 主代码开始执行 %}\n\n还记得`ebp`是什么吗？当前函数堆栈的基地址，`ebp~esp`的范围就组成了当前函数的局部变量的存放地址范围（包括过程中可能出现的`push`操作所占用的栈内存）。下面要执行的`lea eax, [ebp-104h]`就是把`ebp-104h`的值赋值给`eax`，（这里注意取内存中的值和取表达式的值是不一样的，`mov eax, qword ptr [ebp-104h]`就是取`ebp-104h`指向地址的内存内容，而`lea eax, [ebp-104h]`则是把`ebp-104`的结果赋值给`eax`）现在并不知道这句话有什么卵用。然后它又把`eax`压栈了，好吧，这个具体什么作用先遗留着，也许以后会用到。\n\n然后终于开始调用TestReturn函数了，我们用F11进入到函数的内部查看一下，这里我就把堆栈的初始化代码给跳过了，如下：\n{% asset_img TestReturnAssembly.png TestReturn函数体的内容 %}\n\n好了现在开始就是要接触结构体的相关内容了。在开始这个之前，我想说明的是，WinDBG给我们提供了一个查看结构体内存分布的命令dt（应该是dump type的缩写吧），输入`dt HelloWorld2005!Simple`，可以看到Simple这个结构体在内存中的相对分布情况，如下图所示：\n{% asset_img dtHelloWorld2005Simple.png Simple结构体的分布 %}\n\n不如再用一个图来表示一下Simple结构体成员变量的分布情况吧：\n{% asset_img SimpleStructMemory.png Simple结构体的分布图 %}\n\n一目了然，在确定了Simple结构体实例的基地址之后（假设为`p`吧），`a`变量就存放在`p+0x000`的位置，`b`变量就存放在`p+0x004`的位置，以此类推。然后 你就会发现`c`和`d`这两个变量共享了同一个DWORD大小的空间，这就是我们以前曾经学过的内存对齐。了解了这些是不是更加清楚了呢，那么我提一个小问题，当成员变量只有一个`char`的时候会发生内存对齐么？当一个`short`和两个`char`作为成员变量的时候，会发生怎么样的对齐？修改一下变量声明的顺序又会出现什么情况？留着自己去发现吧。\n\n言归正传，我们下面看到的几句话是：\n```asm\nmov dword ptr [ebp-14h], 0Ah ; s.a = 10;\nmov dword ptr [ebp-10h], 14h ; s.b = 20;\nmov byte ptr [ebp-0Ch], 1Eh  ; s.c = 30;\nmov word ptr [ebp-0Ah], 28h  ; s.d = 40;\nmov dword ptr [ebp-8], 32h   ; s.e = 50;\n```\n\n这里的分号表示注释，我这里在每一句汇编的后面都加上了它所对应的C++代码。诶，第一句的`Simple s;`去哪里了？难道是没有执行？当然不是了。再回到标识符的概念上来，永远记住标识符只是代表了一块内存，它并不占用内存，你可以把标识符就理解为一块内存的名字。而这里s代表的起始就是从`ebp-14h`到`ebp-4`范围的这块内存，根据上面得出的`Simple`的内存结构，其实不难得出`ebp-14h`就是`Simple`实例`s`的基地址，也就是a存放的位置，我们可以用`dd ebp-14h L4`（L4用来声明查看多少个DWORD长度）来查看一下这一块的内存，如下图：\n{% asset_img ddebp-14hL4.png s结构体的内容 %}\n\n可以看出从左向右依次是a到e的值，额，貌似有点不对，对于c和d需要重点关注一下。第三个DWORD的内容是`0028cc1e`，首先30的16进制是1eh，40的16进制是28h，我们对应到内存中的内容时，可以发现`0028cc1e`的前两个字节（高字节）保存的是d的值；第三个字节的内容是`cc`，是windows的无效数据；第四个字节保存的是c的值。恩，好像有点明白了，windows采用的是大端模式来保存内存数据的。如果还不明白的话，我们不如用`db ebp-14h L10`来以字节为单位查看内存的内容（db的意思是dump byte，dw表示dump word，dd表示dump dword）:\n{% asset_img dbebp-14hL10.png s结构体中字节内容 %}\n\n好，现在是不是发现所有的字节都颠倒了？就拿a变量来说，它标识的是前四个字节的内容，但是我们在上图中看到的这四个字节依次是`0a 00 00 00`，也就是说大端模式下，最低位的字节会放在最高的地址上，所以阅读这个内存的真正顺序是从右往左读，读取四个字节拼接起来。你之所以用dd看到的是正确的顺序，是因为winDBG给你优化了。那么我们继续观察s实例中第三个DWORD的内存内容，现在应该知道怎么读取了吧，成员变量c相对于结构体的偏移地址是0x008，从开头向后数8个字节（当然你如果熟悉命令的话，也可以输入`dd ebp-14h+8 L4`），然后c是一个char，所以只需要读取一个字节，那么它的内容就是`1e`；同样的方式你可以读取一下d的内存内容。这里再拓展一下，不仅读取内存是按照大端的方式来读取，写入内存也是同样的，这个之后再看汇编的时候大家注意一下。\n\n解决了结构体的内存分布问题，我们再看一下成员变量`e`，它和`a`的区别就是多了一个`unsigned`修饰符，但是汇编代码中没有体现出这个特性。编译器出错了？呵呵，这个问题等以后将数值的表示的时候再来慢慢研究（推荐可以去看CSAPP这本书）。\n\n恩，我重新提一下局部变量s表示的内存范围是`ebp-14h`到`ebp-4`，在之后会用到。继续人肉执行代码：\n```asm\nmov eax, dword ptr [ebp+8]\n\nmov ecx, dword ptr [ebp-14h]\nmov dword ptr [eax], ecx\n\nmov edx, dword ptr [ebp-10h]\nmov dword ptr [eax+4], edx\n\nmov ecx, dword ptr [ebp-0Ch]\nmov dword ptr [eax+8], ecx\n\nmov edx, dword ptr [ebp-8]\nmov dword ptr [eax+0Ch], edx\n```\n\n第一句代码我现在也没有看懂是干嘛的，但是我知道ebp+8这个地址其实已经到了main函数的局部内存地址空间了，可能是和返回值有关我觉得。往下走，`move ecx, dowrd ptr [ebp-14h]`这里是把变量`a`放到`ecx`中我知道，貌似开始挪数据了。接着的`mov dword ptr [eax], ecx`，就把`ecx`的内容，也就是变量`a`的值拷贝到了eax指向的内存中了。下面的三组语句貌似和这两句相同，都是在拷贝变量的值。但是有5个变量，为什么只拷贝了四次内存呢？我觉得应该不用我解释吧。\n\n下面的一句`mov eax, dowrd ptr [ebp+8]`，又一次把`ebp+8`指向的内存的内容拷贝到了eax中，哎，没有优化的代码就是一堆傻逼操作。但是`ebp+8`保存的究竟是什么呢？额，我忘了保存这些东西了，所以再跟着我`Ctrl+Shift+F5`重新执行一次程序吧，回到main函数调用的地方：\n{% asset_img BeforeCallTestReturn.png 调用TestReturn之前 %}\n\n我们画一个图吧，以免忘记了当前堆栈的样子：\n{% asset_img BeforeCallTestReturnStack.png 调用TestReturn之前的堆栈 %}\n\n我特意标红了eax中保存的地址对应的地址空间，后面会用到这个地址，现在先忽略它。\n\n好了，然后我们执行`TestReturn`这个函数，堆栈内容如下：\n{% asset_img AfterCallTestReturn.png 调用TestReturn之后 %}\n\n在执行完前面三句代码之后，所形成的内存堆栈的图如下：\n{% asset_img AfterCallTestReturnStack.png 调用TestReturn之后的堆栈 %}\n\n这样你应该就能清楚地看到`ebp+8`保存的内容就是上一个堆栈中的eax的值，也就是0019fe24，也就是我标红的堆栈空间。但是至于为什么没有从上一个堆栈的头或者尾开始使用，我也暂时不知道，我暂时认为它是乱选的一个空闲内存。\n\n这样的话，经过刚刚的赋值拷贝，结果就是将变量s的内存原封不动拷贝到了`0019fe24~0019fe24+14h`地址空间中，所以你也可以这样理解，`main`函数传递了一个隐形的指针给`TestReturn`函数，而这个指针指向的内存就用于保存返回值。这个问题解决了我们就可以继续往下面执行了。\n\n下面的几句代码如下：\n```asm\npush edx\nmov ecx, ebp\npush eax\nlea edx, [HelloWorld2005!TestReturn+0x74]\ncall HelloWorld2005!_RTC_CheckStackVars\n```\n\n从函数名能够看出这个其实是检查堆栈的，至于内部具体实现，本次不做任何分析，以后单独立一篇文章来搞定它。只是注意这里之所以要`push eax`，应该是_RTC_CheckStackVars这个函数会用到`eax`这个寄存器来保存返回值，所以说将它放到堆栈上保存起来，以供以后恢复。\n\n继续看下面的代码：\n```asm\npop eax\npop edx\npop edi\npop esi\npop ebx\nmov esp, ebp\npop ebp\nret\n```\n\n这里第一句就是恢复刚刚保存的`eax`的值，至于你想说“它傻么，为什么不先调用_RTC_CheckStackVars，再执行`mov eax, dowrd ptr [ebp+8]`”，额~~~~，好吧它确实很傻。之后的`pop edx`也是同样的作用。然后后面的三句是用来恢复上一个堆栈中的寄存器信息，与函数开始处的`push`对应。然后的两句则是用来恢复上一个堆栈的地址空间的，最后一句`ret`标识返回。\n\n直到这里我们知道了eax中保存着一个指针，它指向了`0019fe24`，之后的14h个字节的地址内容都是返回值的内容，那么我们就继续来看看返回到`main`函数之后又做了哪些事情吧：\n{% asset_img AfterTestReturnReturn.png TestReturn返回之后 %}\n\n首先我们再回顾一下它的堆栈空间的内容：\n{% asset_img BeforeCallTestReturnStack.png 此时main函数中堆栈分布 %}\n\n然后执行`add esp, 4`，这句话等价于将栈顶元素出栈，只不过栈顶元素没有变量来保存，而只是单纯的丢弃掉。此时栈顶元素就是eax的值，也就是返回值的地址。\n\n看接下来执行的几句代码：\n```asm\nmov ecx, dword ptr [eax]\nmov dword ptr [ebp-11Ch], ecx\n\nmov edx, dword ptr [eax+4]\nmov dword ptr [ebp-118h], edx\n\nmov ecx, dword ptr [eax+8]\nmov dword ptr [ebp-114h], ecx\n\nmov edx, dword ptr [eax+0Ch]\nmov dword ptr [ebp-110h], edx\n```\n\n是不是似曾相识呢？和刚刚返回值的拷贝一样对不对，只是这一次是把`0019fe24`处的内存地址拷贝到`ebp-11Ch`。好了往下看还有一样的代码：\n```asm\nmov eax, dword ptr [ebp-11Ch]\nmov dword ptr [ebp-14h], eax\n\nmov ecx, dword ptr [ebp-118h]\nmov dword ptr [ebp-10h], ecx\n\nmov edx, dword ptr [ebp-114h]\nmov dword ptr [ebp-0Ch], edx\n\nmov eax, dword ptr [ebp-110h]\nmov dword ptr [ebp-8], eax\n```\n\n这里又发生了一次内存的拷贝，将`ebp-11Ch`的内容拷贝到了`ebp-14h`的地方。所以想想吧，在完全没有开优化的情况下，返回一个结构体居然要拷贝三次内存，确实很浪费内存和时间啊。当然我现在也不知道优化之后会怎么样，可能会变好吧，以后再研究release。\n\n那经过这样一番折腾，返回值终于到了我们熟悉的位置`ebp-14h~ebp-8`这个区间。好吧，它还是给你空出来4个字节，我还没弄清楚这空出来的4个字节究竟能用来干嘛。到现在为止，`TestReturn`函数的调用已经讲完了，大家现在可以慢慢消化一下再继续。\n\n---\n\n跨过华丽的分割线，我们继续看下面的`TestValue`函数（现在s的值保存在`ebp-14h~ebp-8`的区间中）。从准备参数到调用`TestValue`，汇编代码如下：\n{% asset_img CallTestValue.png 调用TestValue %}\n\n首先它执行`sub esp, 10h`，应该是给`TestValue`传入的参数预留空间，我猜的。然后又是一坨类似的拷贝代码：\n```asm\nmov eax, esp\n\nmov ecx, dword ptr [ebp-14h]\nmov dowrd ptr [eax], ecx\n\nmov edx, dword ptr [ebp-10h]\nmov dword ptr [eax+4], edx\n\nmov ecx, dowrd ptr [ebp-0Ch]\nmov dword ptr [eax+8], ecx\n\nmov edx, dword ptr [ebp-8]\nmov dword ptr [eax+0Ch], edx\n```\n\n我不想详细说了，第一句`eax`保存了`esp`的值，`esp`指向了当前的栈顶。而这段代码就是把`s`的内容拷贝到刚刚预留的堆栈空间中，也就是`esp~esp+10h`这块内存中。所以其实你可以理解为现在堆栈的顶部16个字节保存着s的内容。然后我们就开始调用`TestValue`函数了，记得这里有一个把`TestValue`返回继续执行的地址进行压栈的隐式操作。然而`TestValue`函数的实现我并没有写任何东西，所以说可以直接过了。\n\n所以这里我想让大家知道的是，函数参数的地址是通过堆栈进行传递的，而这个堆栈的内存其实是由上一个函数的局部堆栈提供的，保存在上一个函数局部堆栈的栈顶位置。所以说在函数中使用这些内存的时候，是通过`esp+8`这样的偏移的形式来进行引用的。具体细节大家可以自己写代码进行研究啦，我就不赘述了。\n\n继续往下面执行`TestReference`函数，它执行的代码逻辑如下：\n{% asset_img CallTestReference.png 调用TestReference %}\n\n哦哦对，还有一个没有讲，在`TestValue`返回之后，又执行了这样一句代码：`add esp, 10h`，这个其实就是清空按值传递时，堆栈上产生的临时对象的（虽然没有真正清空）。\n\n接着执行`lea eax, [ebp-14h]`，应该还记得`ebp-14h`的位置上保存着什么么？s变量在堆栈上的基地址。把它赋值给`eax`寄存器后，利用`push eax`进行压栈，然后接着就调用了`TestReference`函数。而在函数中你要使用这个栈上变量的方式，和上面相同，也是同样引用`esp+8`指向的值（这里说明下`esp`指向的是上一个函数的堆栈基地址，`esp+4`指向的是该函数返回后继续执行的地址，`esp+8`开始才是上一个函数堆栈的顶部），比如如果这里我需要在函数中执行一个`s.a=10`的语句的话，那么汇编代码可能是如下所示的：\n```asm\nlea eax, [ebp+8]            ;得到引用的变量的指针\nmov ecx, 0ah;               ;将10这个值放到ecx寄存器中\nmov dword ptr [eax], ecx    ;将10这个值真正放到目标地址\n```\n\n当然这些都是我自己写的，只是为大家做一个演示，如何读取和写入引用变量的内容。如果你要验证的话最好以实际生成的代码为准。\n\n接着往下看`TestPointer`函数的调用，诶，居然和`TestReference`生成的代码一模一样：\n{% asset_img CallTestPointer.png 调用TestPointer %}\n\n当然一开始恢复堆栈的那句代码不算啦。所以这个函数我们就不分析了，直接过。\n\n往下再瞄几行，发现调用`TestConstReference`的代码好像也是一模一样：\n{% asset_img CallTestConstReference.png 调用TestConstReference %}\n\n好吧，现在应该能够清楚下面几个问题了：\n1. 编译器如何实现引用的？ 答案是指针，至少在VS2005上是的。\n2. 指针和引用有什么区别？ 好像也没什么区别\n3. const引用和引用有什么区别？ 好像也是一样的\n\n那么问题来了，既然指针、引用、const引用都是同一个实现，那么为什么C++还要分那么多东西呢？有想过没有？自己想1分钟，再往下看。\n\n---\n\n好吧，我来说下我的理解，其实指针和引用还是有区别的啊，指针有空指针，引用却没有空引用，这是指针和引用的本质区别。使用引用的一个好处就是，能够从语法的层面杜绝你出现空指针的情况，减少因为空指针导致的崩溃。而使用const引用呢，则是从语义的层面，在编译期就能够判断出你非法的赋值操作，比如说你传了一个const引用给函数，那么你的本意肯定是不希望这个变量被改变，但是你在函数里面对这个const引用赋值了，那么编译器在进行语义分析的时候就能够帮你纠正出这个错误，至于减少bug的话，不同场景不同表现啦。因为有一堆人在遇到这种语义错误的时候，选择的是去掉const，而不是继续调整代码的结构。所以，对于const的使用，见仁见智吧。\n\n最后一个`Simple e = {0}`算是一个额外的扩展研究吧，我们可以看下他的代码：\n{% asset_img InitSimple.png 对结构体进行初始化 %}\n\n我们可以看到下面这四句代码是初始化成员变量的内容的：\n```asm\nmov dword ptr [ebp-2Ch], 0      ;a\nmov dword ptr [ebp-28h], eax    ;b\nmov dword ptr [ebp-24h], eax    ;c和d\nmov dword ptr [ebp-20h], eax    ;e\n```\n\n但是为什么第一个变量的初始化方式不同，我也不知道，我也想掀桌啊妈蛋，不过反正结果都一样，VS这样做可能是傻逼了吧。可以知道他其实是以DWORD（4个字节）为单位进行初始化的，而不是一个变量一个变量进行初始化的，其实相当于做了一个`memset`的过程。\n\n你还不知道`eax`是啥？看这句代码`xor eax, eax`，`xor`就是亦或，任何值和自己亦或得到的结果都是0，所以这句代码就已经将eax的值覆盖成0了。至于它和`mov eax, 0`有什么区别，嘿嘿，我们不妨看下面两个语句的二进制代码，都是我从真实的代码里面摘抄的，分号之前的是汇编代码对应的二进制代码，分号后面的是汇编代码：\n```asm\nbacccccccc      ;mov     edx,0CCCCCCCCh\n33c0            ;xor     eax,eax\n```\n\n能看出区别来了么，对，保存`mov`语句比保存`xor`语句需要更多的存储空间，所以用xor生成代码更加简短。这里也算是一种优化吧。\n\n那么此时我们不妨看一下e在内存中的内容，利用`dd ebp-2Ch L4`即可：\n{% asset_img ddebp-2ChL4.png e在内存中的内容 %}\n\n好吧全都是0，没啥好看的。\n\n那么到这里讲解就全都结束了，至于main函数后面还有的那部分，可以完全参考我上一章将的内容，只做了两件事情，一个就是检查堆栈，另外一个就是恢复上一个函数的堆栈和寄存器。由于该代码过于简单，release版本基本上会被优化得不剩什么代码，所以照旧不讲解release版本的汇编代码。\n\n那么下次再见吧，拜拜！\n\n## 回顾：\n\n### 关于WinDBG\n无\n\n\n### 关于汇编\n1. ebp指向了上一个函数堆栈的基地址\n2. ebp+4指向了函数返回时，继续执行的地址\n3. ebp+8是上一个函数局部堆栈的栈顶，一般函数参数都保存在这个地方\n4. 调用函数时，会发生一个隐式的压栈操作，即把`call`指令的下一个指令的地址进行压栈，（其实这个地址的值就是`eip`，在函数ret时，同样也会执行一个`pop eip`的操作）\n5. `mov eax, 0`需要5个字节记录，`xor eax, eax`只需要两个字节\n6. 区分取寄存器的值（`lea eax, [ebp+8]`）和取寄存器指向地址的内容（`mov eax, dword ptr [ebp+8]`）\n\n### 关于C++\n1. 结构体初始化器所做的操作其实和`memset`类似，不会按照变量为单位进行初始化，而是按照DWORD为单位进行初始化\n2. 指针、引用在VS2005上的实现并没有什么区别，唯一的区别就是指针可空，引用不可空\n3. 引用和const引用在实现上也没有任何区别，只是方便了编译器在语义分析时及时报错","slug":"windbg-windbg-chapter2","published":1,"updated":"2018-06-25T11:14:49.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjivnhtnh000c2gus6uvwuw1m","content":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>前面一章主要讲述了C++函数的调用过程在汇编中的具体执行过程，如果还不熟悉的同学也没关系，后面仍然会不断重复函数的讲解。之所以没有对release版本的exe进行分析，是因为编译器优化后，很多未使用的变量和函数都会被丢弃掉，所以其实优化后的版本没有多少参考意义。对于release的分析将安排到程序稍微复杂一点时进行。</p>\n<p>本章的内容仍然很简单，主要引入了struct关键字，所以现在大家可以开始定义自己的结构体了。并且本章还会稍微分析一下指针、引用的区别，以及const在最终代码中的作用。好了，闲话少叙，看看今天的代码吧。<br><a id=\"more\"></a></p>\n<h2 id=\"慢慢地趋向结构化\"><a href=\"#慢慢地趋向结构化\" class=\"headerlink\" title=\"慢慢地趋向结构化\"></a>慢慢地趋向结构化</h2><p>今天的代码内容如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Simple</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> d;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> e;</span><br><span class=\"line\">&#125; Simple;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestValue</span><span class=\"params\">(Simple s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestReference</span><span class=\"params\">(Simple&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestPointer</span><span class=\"params\">(Simple* s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestConstReference</span><span class=\"params\">(<span class=\"keyword\">const</span> Simple&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Simple <span class=\"title\">TestReturn</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Simple s;</span><br><span class=\"line\">    s.a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    s.b = <span class=\"number\">20</span>;</span><br><span class=\"line\">    s.c = <span class=\"number\">30</span>;</span><br><span class=\"line\">    s.d = <span class=\"number\">40</span>;</span><br><span class=\"line\">    s.e = <span class=\"number\">50</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Simple s = TestReturn();</span><br><span class=\"line\">    TestValue(s);</span><br><span class=\"line\">    TestReference(s);</span><br><span class=\"line\">    TestPointer(&amp;s);</span><br><span class=\"line\">    TestConstReference(s);</span><br><span class=\"line\"></span><br><span class=\"line\">    Simple e = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这次的主人公是结构体，所以函数的实现基本上都是空。大家在继续阅读的同时，最好能够带着下面几个问题：</p>\n<ol>\n<li>Simple结构体的内存分布</li>\n<li>指针和引用的区别</li>\n<li>const引用和非const引用有什么区别</li>\n<li>返回值存放在局部堆栈的什么位置，能不能用ebp将这个位置表示出来</li>\n<li>返回值是怎么传递给调用的地方的</li>\n<li>Simple e = {0}这句代码做了什么事情</li>\n</ol>\n<p>如果你上面的问题的答案都能够如数家珍，那么这篇博客不适合你，你可以不用往下面读了。没有了解的同学跟着我一起来看看windows最终是怎么执行我们写的这段代码的吧。</p>\n<p>依旧是打开WinDBG，然后加载HelloWorld2005.exe，然后输入<code>bp HelloWorld2005!main</code>，让它能够在main函数的时候断下来，输入g运行。按下<code>alt+7</code>打开汇编代码，并将<code>Source Mode</code>勾选框去掉。做好这一切之后，就可以开始一步一步调试代码了。</p>\n<p>F10单步调试，当<code>main</code>函数保存完所有寄存器的值之后，然后可以看到第一句话<code>TestReturn</code>是从下图开始执行的：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/begin.png\" title=\"主代码开始执行\"></p>\n<p>还记得<code>ebp</code>是什么吗？当前函数堆栈的基地址，<code>ebp~esp</code>的范围就组成了当前函数的局部变量的存放地址范围（包括过程中可能出现的<code>push</code>操作所占用的栈内存）。下面要执行的<code>lea eax, [ebp-104h]</code>就是把<code>ebp-104h</code>的值赋值给<code>eax</code>，（这里注意取内存中的值和取表达式的值是不一样的，<code>mov eax, qword ptr [ebp-104h]</code>就是取<code>ebp-104h</code>指向地址的内存内容，而<code>lea eax, [ebp-104h]</code>则是把<code>ebp-104</code>的结果赋值给<code>eax</code>）现在并不知道这句话有什么卵用。然后它又把<code>eax</code>压栈了，好吧，这个具体什么作用先遗留着，也许以后会用到。</p>\n<p>然后终于开始调用TestReturn函数了，我们用F11进入到函数的内部查看一下，这里我就把堆栈的初始化代码给跳过了，如下：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/TestReturnAssembly.png\" title=\"TestReturn函数体的内容\"></p>\n<p>好了现在开始就是要接触结构体的相关内容了。在开始这个之前，我想说明的是，WinDBG给我们提供了一个查看结构体内存分布的命令dt（应该是dump type的缩写吧），输入<code>dt HelloWorld2005!Simple</code>，可以看到Simple这个结构体在内存中的相对分布情况，如下图所示：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/dtHelloWorld2005Simple.png\" title=\"Simple结构体的分布\"></p>\n<p>不如再用一个图来表示一下Simple结构体成员变量的分布情况吧：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/SimpleStructMemory.png\" title=\"Simple结构体的分布图\"></p>\n<p>一目了然，在确定了Simple结构体实例的基地址之后（假设为<code>p</code>吧），<code>a</code>变量就存放在<code>p+0x000</code>的位置，<code>b</code>变量就存放在<code>p+0x004</code>的位置，以此类推。然后 你就会发现<code>c</code>和<code>d</code>这两个变量共享了同一个DWORD大小的空间，这就是我们以前曾经学过的内存对齐。了解了这些是不是更加清楚了呢，那么我提一个小问题，当成员变量只有一个<code>char</code>的时候会发生内存对齐么？当一个<code>short</code>和两个<code>char</code>作为成员变量的时候，会发生怎么样的对齐？修改一下变量声明的顺序又会出现什么情况？留着自己去发现吧。</p>\n<p>言归正传，我们下面看到的几句话是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-14h], 0Ah ; s.a = 10;</span><br><span class=\"line\">mov dword ptr [ebp-10h], 14h ; s.b = 20;</span><br><span class=\"line\">mov byte ptr [ebp-0Ch], 1Eh  ; s.c = 30;</span><br><span class=\"line\">mov word ptr [ebp-0Ah], 28h  ; s.d = 40;</span><br><span class=\"line\">mov dword ptr [ebp-8], 32h   ; s.e = 50;</span><br></pre></td></tr></table></figure></p>\n<p>这里的分号表示注释，我这里在每一句汇编的后面都加上了它所对应的C++代码。诶，第一句的<code>Simple s;</code>去哪里了？难道是没有执行？当然不是了。再回到标识符的概念上来，永远记住标识符只是代表了一块内存，它并不占用内存，你可以把标识符就理解为一块内存的名字。而这里s代表的起始就是从<code>ebp-14h</code>到<code>ebp-4</code>范围的这块内存，根据上面得出的<code>Simple</code>的内存结构，其实不难得出<code>ebp-14h</code>就是<code>Simple</code>实例<code>s</code>的基地址，也就是a存放的位置，我们可以用<code>dd ebp-14h L4</code>（L4用来声明查看多少个DWORD长度）来查看一下这一块的内存，如下图：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/ddebp-14hL4.png\" title=\"s结构体的内容\"></p>\n<p>可以看出从左向右依次是a到e的值，额，貌似有点不对，对于c和d需要重点关注一下。第三个DWORD的内容是<code>0028cc1e</code>，首先30的16进制是1eh，40的16进制是28h，我们对应到内存中的内容时，可以发现<code>0028cc1e</code>的前两个字节（高字节）保存的是d的值；第三个字节的内容是<code>cc</code>，是windows的无效数据；第四个字节保存的是c的值。恩，好像有点明白了，windows采用的是大端模式来保存内存数据的。如果还不明白的话，我们不如用<code>db ebp-14h L10</code>来以字节为单位查看内存的内容（db的意思是dump byte，dw表示dump word，dd表示dump dword）:<br></p>\n<p>好，现在是不是发现所有的字节都颠倒了？就拿a变量来说，它标识的是前四个字节的内容，但是我们在上图中看到的这四个字节依次是<code>0a 00 00 00</code>，也就是说大端模式下，最低位的字节会放在最高的地址上，所以阅读这个内存的真正顺序是从右往左读，读取四个字节拼接起来。你之所以用dd看到的是正确的顺序，是因为winDBG给你优化了。那么我们继续观察s实例中第三个DWORD的内存内容，现在应该知道怎么读取了吧，成员变量c相对于结构体的偏移地址是0x008，从开头向后数8个字节（当然你如果熟悉命令的话，也可以输入<code>dd ebp-14h+8 L4</code>），然后c是一个char，所以只需要读取一个字节，那么它的内容就是<code>1e</code>；同样的方式你可以读取一下d的内存内容。这里再拓展一下，不仅读取内存是按照大端的方式来读取，写入内存也是同样的，这个之后再看汇编的时候大家注意一下。</p>\n<p>解决了结构体的内存分布问题，我们再看一下成员变量<code>e</code>，它和<code>a</code>的区别就是多了一个<code>unsigned</code>修饰符，但是汇编代码中没有体现出这个特性。编译器出错了？呵呵，这个问题等以后将数值的表示的时候再来慢慢研究（推荐可以去看CSAPP这本书）。</p>\n<p>恩，我重新提一下局部变量s表示的内存范围是<code>ebp-14h</code>到<code>ebp-4</code>，在之后会用到。继续人肉执行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp+8]</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [ebp-14h]</span><br><span class=\"line\">mov dword ptr [eax], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-10h]</span><br><span class=\"line\">mov dword ptr [eax+4], edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [ebp-0Ch]</span><br><span class=\"line\">mov dword ptr [eax+8], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-8]</span><br><span class=\"line\">mov dword ptr [eax+0Ch], edx</span><br></pre></td></tr></table></figure></p>\n<p>第一句代码我现在也没有看懂是干嘛的，但是我知道ebp+8这个地址其实已经到了main函数的局部内存地址空间了，可能是和返回值有关我觉得。往下走，<code>move ecx, dowrd ptr [ebp-14h]</code>这里是把变量<code>a</code>放到<code>ecx</code>中我知道，貌似开始挪数据了。接着的<code>mov dword ptr [eax], ecx</code>，就把<code>ecx</code>的内容，也就是变量<code>a</code>的值拷贝到了eax指向的内存中了。下面的三组语句貌似和这两句相同，都是在拷贝变量的值。但是有5个变量，为什么只拷贝了四次内存呢？我觉得应该不用我解释吧。</p>\n<p>下面的一句<code>mov eax, dowrd ptr [ebp+8]</code>，又一次把<code>ebp+8</code>指向的内存的内容拷贝到了eax中，哎，没有优化的代码就是一堆傻逼操作。但是<code>ebp+8</code>保存的究竟是什么呢？额，我忘了保存这些东西了，所以再跟着我<code>Ctrl+Shift+F5</code>重新执行一次程序吧，回到main函数调用的地方：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/BeforeCallTestReturn.png\" title=\"调用TestReturn之前\"></p>\n<p>我们画一个图吧，以免忘记了当前堆栈的样子：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/BeforeCallTestReturnStack.png\" title=\"调用TestReturn之前的堆栈\"></p>\n<p>我特意标红了eax中保存的地址对应的地址空间，后面会用到这个地址，现在先忽略它。</p>\n<p>好了，然后我们执行<code>TestReturn</code>这个函数，堆栈内容如下：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/AfterCallTestReturn.png\" title=\"调用TestReturn之后\"></p>\n<p>在执行完前面三句代码之后，所形成的内存堆栈的图如下：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/AfterCallTestReturnStack.png\" title=\"调用TestReturn之后的堆栈\"></p>\n<p>这样你应该就能清楚地看到<code>ebp+8</code>保存的内容就是上一个堆栈中的eax的值，也就是0019fe24，也就是我标红的堆栈空间。但是至于为什么没有从上一个堆栈的头或者尾开始使用，我也暂时不知道，我暂时认为它是乱选的一个空闲内存。</p>\n<p>这样的话，经过刚刚的赋值拷贝，结果就是将变量s的内存原封不动拷贝到了<code>0019fe24~0019fe24+14h</code>地址空间中，所以你也可以这样理解，<code>main</code>函数传递了一个隐形的指针给<code>TestReturn</code>函数，而这个指针指向的内存就用于保存返回值。这个问题解决了我们就可以继续往下面执行了。</p>\n<p>下面的几句代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push edx</span><br><span class=\"line\">mov ecx, ebp</span><br><span class=\"line\">push eax</span><br><span class=\"line\">lea edx, [HelloWorld2005!TestReturn+0x74]</span><br><span class=\"line\">call HelloWorld2005!_RTC_CheckStackVars</span><br></pre></td></tr></table></figure></p>\n<p>从函数名能够看出这个其实是检查堆栈的，至于内部具体实现，本次不做任何分析，以后单独立一篇文章来搞定它。只是注意这里之所以要<code>push eax</code>，应该是_RTC_CheckStackVars这个函数会用到<code>eax</code>这个寄存器来保存返回值，所以说将它放到堆栈上保存起来，以供以后恢复。</p>\n<p>继续看下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pop eax</span><br><span class=\"line\">pop edx</span><br><span class=\"line\">pop edi</span><br><span class=\"line\">pop esi</span><br><span class=\"line\">pop ebx</span><br><span class=\"line\">mov esp, ebp</span><br><span class=\"line\">pop ebp</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure></p>\n<p>这里第一句就是恢复刚刚保存的<code>eax</code>的值，至于你想说“它傻么，为什么不先调用_RTC_CheckStackVars，再执行<code>mov eax, dowrd ptr [ebp+8]</code>”，额~~~~，好吧它确实很傻。之后的<code>pop edx</code>也是同样的作用。然后后面的三句是用来恢复上一个堆栈中的寄存器信息，与函数开始处的<code>push</code>对应。然后的两句则是用来恢复上一个堆栈的地址空间的，最后一句<code>ret</code>标识返回。</p>\n<p>直到这里我们知道了eax中保存着一个指针，它指向了<code>0019fe24</code>，之后的14h个字节的地址内容都是返回值的内容，那么我们就继续来看看返回到<code>main</code>函数之后又做了哪些事情吧：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/AfterTestReturnReturn.png\" title=\"TestReturn返回之后\"></p>\n<p>首先我们再回顾一下它的堆栈空间的内容：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/BeforeCallTestReturnStack.png\" title=\"此时main函数中堆栈分布\"></p>\n<p>然后执行<code>add esp, 4</code>，这句话等价于将栈顶元素出栈，只不过栈顶元素没有变量来保存，而只是单纯的丢弃掉。此时栈顶元素就是eax的值，也就是返回值的地址。</p>\n<p>看接下来执行的几句代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx, dword ptr [eax]</span><br><span class=\"line\">mov dword ptr [ebp-11Ch], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [eax+4]</span><br><span class=\"line\">mov dword ptr [ebp-118h], edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [eax+8]</span><br><span class=\"line\">mov dword ptr [ebp-114h], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [eax+0Ch]</span><br><span class=\"line\">mov dword ptr [ebp-110h], edx</span><br></pre></td></tr></table></figure></p>\n<p>是不是似曾相识呢？和刚刚返回值的拷贝一样对不对，只是这一次是把<code>0019fe24</code>处的内存地址拷贝到<code>ebp-11Ch</code>。好了往下看还有一样的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-11Ch]</span><br><span class=\"line\">mov dword ptr [ebp-14h], eax</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [ebp-118h]</span><br><span class=\"line\">mov dword ptr [ebp-10h], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-114h]</span><br><span class=\"line\">mov dword ptr [ebp-0Ch], edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-110h]</span><br><span class=\"line\">mov dword ptr [ebp-8], eax</span><br></pre></td></tr></table></figure></p>\n<p>这里又发生了一次内存的拷贝，将<code>ebp-11Ch</code>的内容拷贝到了<code>ebp-14h</code>的地方。所以想想吧，在完全没有开优化的情况下，返回一个结构体居然要拷贝三次内存，确实很浪费内存和时间啊。当然我现在也不知道优化之后会怎么样，可能会变好吧，以后再研究release。</p>\n<p>那经过这样一番折腾，返回值终于到了我们熟悉的位置<code>ebp-14h~ebp-8</code>这个区间。好吧，它还是给你空出来4个字节，我还没弄清楚这空出来的4个字节究竟能用来干嘛。到现在为止，<code>TestReturn</code>函数的调用已经讲完了，大家现在可以慢慢消化一下再继续。</p>\n<hr>\n<p>跨过华丽的分割线，我们继续看下面的<code>TestValue</code>函数（现在s的值保存在<code>ebp-14h~ebp-8</code>的区间中）。从准备参数到调用<code>TestValue</code>，汇编代码如下：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/CallTestValue.png\" title=\"调用TestValue\"></p>\n<p>首先它执行<code>sub esp, 10h</code>，应该是给<code>TestValue</code>传入的参数预留空间，我猜的。然后又是一坨类似的拷贝代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, esp</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [ebp-14h]</span><br><span class=\"line\">mov dowrd ptr [eax], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-10h]</span><br><span class=\"line\">mov dword ptr [eax+4], edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dowrd ptr [ebp-0Ch]</span><br><span class=\"line\">mov dword ptr [eax+8], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-8]</span><br><span class=\"line\">mov dword ptr [eax+0Ch], edx</span><br></pre></td></tr></table></figure></p>\n<p>我不想详细说了，第一句<code>eax</code>保存了<code>esp</code>的值，<code>esp</code>指向了当前的栈顶。而这段代码就是把<code>s</code>的内容拷贝到刚刚预留的堆栈空间中，也就是<code>esp~esp+10h</code>这块内存中。所以其实你可以理解为现在堆栈的顶部16个字节保存着s的内容。然后我们就开始调用<code>TestValue</code>函数了，记得这里有一个把<code>TestValue</code>返回继续执行的地址进行压栈的隐式操作。然而<code>TestValue</code>函数的实现我并没有写任何东西，所以说可以直接过了。</p>\n<p>所以这里我想让大家知道的是，函数参数的地址是通过堆栈进行传递的，而这个堆栈的内存其实是由上一个函数的局部堆栈提供的，保存在上一个函数局部堆栈的栈顶位置。所以说在函数中使用这些内存的时候，是通过<code>esp+8</code>这样的偏移的形式来进行引用的。具体细节大家可以自己写代码进行研究啦，我就不赘述了。</p>\n<p>继续往下面执行<code>TestReference</code>函数，它执行的代码逻辑如下：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/CallTestReference.png\" title=\"调用TestReference\"></p>\n<p>哦哦对，还有一个没有讲，在<code>TestValue</code>返回之后，又执行了这样一句代码：<code>add esp, 10h</code>，这个其实就是清空按值传递时，堆栈上产生的临时对象的（虽然没有真正清空）。</p>\n<p>接着执行<code>lea eax, [ebp-14h]</code>，应该还记得<code>ebp-14h</code>的位置上保存着什么么？s变量在堆栈上的基地址。把它赋值给<code>eax</code>寄存器后，利用<code>push eax</code>进行压栈，然后接着就调用了<code>TestReference</code>函数。而在函数中你要使用这个栈上变量的方式，和上面相同，也是同样引用<code>esp+8</code>指向的值（这里说明下<code>esp</code>指向的是上一个函数的堆栈基地址，<code>esp+4</code>指向的是该函数返回后继续执行的地址，<code>esp+8</code>开始才是上一个函数堆栈的顶部），比如如果这里我需要在函数中执行一个<code>s.a=10</code>的语句的话，那么汇编代码可能是如下所示的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea eax, [ebp+8]            ;得到引用的变量的指针</span><br><span class=\"line\">mov ecx, 0ah;               ;将10这个值放到ecx寄存器中</span><br><span class=\"line\">mov dword ptr [eax], ecx    ;将10这个值真正放到目标地址</span><br></pre></td></tr></table></figure></p>\n<p>当然这些都是我自己写的，只是为大家做一个演示，如何读取和写入引用变量的内容。如果你要验证的话最好以实际生成的代码为准。</p>\n<p>接着往下看<code>TestPointer</code>函数的调用，诶，居然和<code>TestReference</code>生成的代码一模一样：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/CallTestPointer.png\" title=\"调用TestPointer\"></p>\n<p>当然一开始恢复堆栈的那句代码不算啦。所以这个函数我们就不分析了，直接过。</p>\n<p>往下再瞄几行，发现调用<code>TestConstReference</code>的代码好像也是一模一样：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/CallTestConstReference.png\" title=\"调用TestConstReference\"></p>\n<p>好吧，现在应该能够清楚下面几个问题了：</p>\n<ol>\n<li>编译器如何实现引用的？ 答案是指针，至少在VS2005上是的。</li>\n<li>指针和引用有什么区别？ 好像也没什么区别</li>\n<li>const引用和引用有什么区别？ 好像也是一样的</li>\n</ol>\n<p>那么问题来了，既然指针、引用、const引用都是同一个实现，那么为什么C++还要分那么多东西呢？有想过没有？自己想1分钟，再往下看。</p>\n<hr>\n<p>好吧，我来说下我的理解，其实指针和引用还是有区别的啊，指针有空指针，引用却没有空引用，这是指针和引用的本质区别。使用引用的一个好处就是，能够从语法的层面杜绝你出现空指针的情况，减少因为空指针导致的崩溃。而使用const引用呢，则是从语义的层面，在编译期就能够判断出你非法的赋值操作，比如说你传了一个const引用给函数，那么你的本意肯定是不希望这个变量被改变，但是你在函数里面对这个const引用赋值了，那么编译器在进行语义分析的时候就能够帮你纠正出这个错误，至于减少bug的话，不同场景不同表现啦。因为有一堆人在遇到这种语义错误的时候，选择的是去掉const，而不是继续调整代码的结构。所以，对于const的使用，见仁见智吧。</p>\n<p>最后一个<code>Simple e = {0}</code>算是一个额外的扩展研究吧，我们可以看下他的代码：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/InitSimple.png\" title=\"对结构体进行初始化\"></p>\n<p>我们可以看到下面这四句代码是初始化成员变量的内容的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-2Ch], 0      ;a</span><br><span class=\"line\">mov dword ptr [ebp-28h], eax    ;b</span><br><span class=\"line\">mov dword ptr [ebp-24h], eax    ;c和d</span><br><span class=\"line\">mov dword ptr [ebp-20h], eax    ;e</span><br></pre></td></tr></table></figure></p>\n<p>但是为什么第一个变量的初始化方式不同，我也不知道，我也想掀桌啊妈蛋，不过反正结果都一样，VS这样做可能是傻逼了吧。可以知道他其实是以DWORD（4个字节）为单位进行初始化的，而不是一个变量一个变量进行初始化的，其实相当于做了一个<code>memset</code>的过程。</p>\n<p>你还不知道<code>eax</code>是啥？看这句代码<code>xor eax, eax</code>，<code>xor</code>就是亦或，任何值和自己亦或得到的结果都是0，所以这句代码就已经将eax的值覆盖成0了。至于它和<code>mov eax, 0</code>有什么区别，嘿嘿，我们不妨看下面两个语句的二进制代码，都是我从真实的代码里面摘抄的，分号之前的是汇编代码对应的二进制代码，分号后面的是汇编代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bacccccccc      ;mov     edx,0CCCCCCCCh</span><br><span class=\"line\">33c0            ;xor     eax,eax</span><br></pre></td></tr></table></figure></p>\n<p>能看出区别来了么，对，保存<code>mov</code>语句比保存<code>xor</code>语句需要更多的存储空间，所以用xor生成代码更加简短。这里也算是一种优化吧。</p>\n<p>那么此时我们不妨看一下e在内存中的内容，利用<code>dd ebp-2Ch L4</code>即可：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/ddebp-2ChL4.png\" title=\"e在内存中的内容\"></p>\n<p>好吧全都是0，没啥好看的。</p>\n<p>那么到这里讲解就全都结束了，至于main函数后面还有的那部分，可以完全参考我上一章将的内容，只做了两件事情，一个就是检查堆栈，另外一个就是恢复上一个函数的堆栈和寄存器。由于该代码过于简单，release版本基本上会被优化得不剩什么代码，所以照旧不讲解release版本的汇编代码。</p>\n<p>那么下次再见吧，拜拜！</p>\n<h2 id=\"回顾：\"><a href=\"#回顾：\" class=\"headerlink\" title=\"回顾：\"></a>回顾：</h2><h3 id=\"关于WinDBG\"><a href=\"#关于WinDBG\" class=\"headerlink\" title=\"关于WinDBG\"></a>关于WinDBG</h3><p>无</p>\n<h3 id=\"关于汇编\"><a href=\"#关于汇编\" class=\"headerlink\" title=\"关于汇编\"></a>关于汇编</h3><ol>\n<li>ebp指向了上一个函数堆栈的基地址</li>\n<li>ebp+4指向了函数返回时，继续执行的地址</li>\n<li>ebp+8是上一个函数局部堆栈的栈顶，一般函数参数都保存在这个地方</li>\n<li>调用函数时，会发生一个隐式的压栈操作，即把<code>call</code>指令的下一个指令的地址进行压栈，（其实这个地址的值就是<code>eip</code>，在函数ret时，同样也会执行一个<code>pop eip</code>的操作）</li>\n<li><code>mov eax, 0</code>需要5个字节记录，<code>xor eax, eax</code>只需要两个字节</li>\n<li>区分取寄存器的值（<code>lea eax, [ebp+8]</code>）和取寄存器指向地址的内容（<code>mov eax, dword ptr [ebp+8]</code>）</li>\n</ol>\n<h3 id=\"关于C\"><a href=\"#关于C\" class=\"headerlink\" title=\"关于C++\"></a>关于C++</h3><ol>\n<li>结构体初始化器所做的操作其实和<code>memset</code>类似，不会按照变量为单位进行初始化，而是按照DWORD为单位进行初始化</li>\n<li>指针、引用在VS2005上的实现并没有什么区别，唯一的区别就是指针可空，引用不可空</li>\n<li>引用和const引用在实现上也没有任何区别，只是方便了编译器在语义分析时及时报错</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>前面一章主要讲述了C++函数的调用过程在汇编中的具体执行过程，如果还不熟悉的同学也没关系，后面仍然会不断重复函数的讲解。之所以没有对release版本的exe进行分析，是因为编译器优化后，很多未使用的变量和函数都会被丢弃掉，所以其实优化后的版本没有多少参考意义。对于release的分析将安排到程序稍微复杂一点时进行。</p>\n<p>本章的内容仍然很简单，主要引入了struct关键字，所以现在大家可以开始定义自己的结构体了。并且本章还会稍微分析一下指针、引用的区别，以及const在最终代码中的作用。好了，闲话少叙，看看今天的代码吧。<br>","more":"</p>\n<h2 id=\"慢慢地趋向结构化\"><a href=\"#慢慢地趋向结构化\" class=\"headerlink\" title=\"慢慢地趋向结构化\"></a>慢慢地趋向结构化</h2><p>今天的代码内容如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Simple</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> d;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> e;</span><br><span class=\"line\">&#125; Simple;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestValue</span><span class=\"params\">(Simple s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestReference</span><span class=\"params\">(Simple&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestPointer</span><span class=\"params\">(Simple* s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestConstReference</span><span class=\"params\">(<span class=\"keyword\">const</span> Simple&amp; s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Simple <span class=\"title\">TestReturn</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Simple s;</span><br><span class=\"line\">    s.a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    s.b = <span class=\"number\">20</span>;</span><br><span class=\"line\">    s.c = <span class=\"number\">30</span>;</span><br><span class=\"line\">    s.d = <span class=\"number\">40</span>;</span><br><span class=\"line\">    s.e = <span class=\"number\">50</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Simple s = TestReturn();</span><br><span class=\"line\">    TestValue(s);</span><br><span class=\"line\">    TestReference(s);</span><br><span class=\"line\">    TestPointer(&amp;s);</span><br><span class=\"line\">    TestConstReference(s);</span><br><span class=\"line\"></span><br><span class=\"line\">    Simple e = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这次的主人公是结构体，所以函数的实现基本上都是空。大家在继续阅读的同时，最好能够带着下面几个问题：</p>\n<ol>\n<li>Simple结构体的内存分布</li>\n<li>指针和引用的区别</li>\n<li>const引用和非const引用有什么区别</li>\n<li>返回值存放在局部堆栈的什么位置，能不能用ebp将这个位置表示出来</li>\n<li>返回值是怎么传递给调用的地方的</li>\n<li>Simple e = {0}这句代码做了什么事情</li>\n</ol>\n<p>如果你上面的问题的答案都能够如数家珍，那么这篇博客不适合你，你可以不用往下面读了。没有了解的同学跟着我一起来看看windows最终是怎么执行我们写的这段代码的吧。</p>\n<p>依旧是打开WinDBG，然后加载HelloWorld2005.exe，然后输入<code>bp HelloWorld2005!main</code>，让它能够在main函数的时候断下来，输入g运行。按下<code>alt+7</code>打开汇编代码，并将<code>Source Mode</code>勾选框去掉。做好这一切之后，就可以开始一步一步调试代码了。</p>\n<p>F10单步调试，当<code>main</code>函数保存完所有寄存器的值之后，然后可以看到第一句话<code>TestReturn</code>是从下图开始执行的：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/begin.png\" title=\"主代码开始执行\"></p>\n<p>还记得<code>ebp</code>是什么吗？当前函数堆栈的基地址，<code>ebp~esp</code>的范围就组成了当前函数的局部变量的存放地址范围（包括过程中可能出现的<code>push</code>操作所占用的栈内存）。下面要执行的<code>lea eax, [ebp-104h]</code>就是把<code>ebp-104h</code>的值赋值给<code>eax</code>，（这里注意取内存中的值和取表达式的值是不一样的，<code>mov eax, qword ptr [ebp-104h]</code>就是取<code>ebp-104h</code>指向地址的内存内容，而<code>lea eax, [ebp-104h]</code>则是把<code>ebp-104</code>的结果赋值给<code>eax</code>）现在并不知道这句话有什么卵用。然后它又把<code>eax</code>压栈了，好吧，这个具体什么作用先遗留着，也许以后会用到。</p>\n<p>然后终于开始调用TestReturn函数了，我们用F11进入到函数的内部查看一下，这里我就把堆栈的初始化代码给跳过了，如下：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/TestReturnAssembly.png\" title=\"TestReturn函数体的内容\"></p>\n<p>好了现在开始就是要接触结构体的相关内容了。在开始这个之前，我想说明的是，WinDBG给我们提供了一个查看结构体内存分布的命令dt（应该是dump type的缩写吧），输入<code>dt HelloWorld2005!Simple</code>，可以看到Simple这个结构体在内存中的相对分布情况，如下图所示：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/dtHelloWorld2005Simple.png\" title=\"Simple结构体的分布\"></p>\n<p>不如再用一个图来表示一下Simple结构体成员变量的分布情况吧：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/SimpleStructMemory.png\" title=\"Simple结构体的分布图\"></p>\n<p>一目了然，在确定了Simple结构体实例的基地址之后（假设为<code>p</code>吧），<code>a</code>变量就存放在<code>p+0x000</code>的位置，<code>b</code>变量就存放在<code>p+0x004</code>的位置，以此类推。然后 你就会发现<code>c</code>和<code>d</code>这两个变量共享了同一个DWORD大小的空间，这就是我们以前曾经学过的内存对齐。了解了这些是不是更加清楚了呢，那么我提一个小问题，当成员变量只有一个<code>char</code>的时候会发生内存对齐么？当一个<code>short</code>和两个<code>char</code>作为成员变量的时候，会发生怎么样的对齐？修改一下变量声明的顺序又会出现什么情况？留着自己去发现吧。</p>\n<p>言归正传，我们下面看到的几句话是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-14h], 0Ah ; s.a = 10;</span><br><span class=\"line\">mov dword ptr [ebp-10h], 14h ; s.b = 20;</span><br><span class=\"line\">mov byte ptr [ebp-0Ch], 1Eh  ; s.c = 30;</span><br><span class=\"line\">mov word ptr [ebp-0Ah], 28h  ; s.d = 40;</span><br><span class=\"line\">mov dword ptr [ebp-8], 32h   ; s.e = 50;</span><br></pre></td></tr></table></figure></p>\n<p>这里的分号表示注释，我这里在每一句汇编的后面都加上了它所对应的C++代码。诶，第一句的<code>Simple s;</code>去哪里了？难道是没有执行？当然不是了。再回到标识符的概念上来，永远记住标识符只是代表了一块内存，它并不占用内存，你可以把标识符就理解为一块内存的名字。而这里s代表的起始就是从<code>ebp-14h</code>到<code>ebp-4</code>范围的这块内存，根据上面得出的<code>Simple</code>的内存结构，其实不难得出<code>ebp-14h</code>就是<code>Simple</code>实例<code>s</code>的基地址，也就是a存放的位置，我们可以用<code>dd ebp-14h L4</code>（L4用来声明查看多少个DWORD长度）来查看一下这一块的内存，如下图：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/ddebp-14hL4.png\" title=\"s结构体的内容\"></p>\n<p>可以看出从左向右依次是a到e的值，额，貌似有点不对，对于c和d需要重点关注一下。第三个DWORD的内容是<code>0028cc1e</code>，首先30的16进制是1eh，40的16进制是28h，我们对应到内存中的内容时，可以发现<code>0028cc1e</code>的前两个字节（高字节）保存的是d的值；第三个字节的内容是<code>cc</code>，是windows的无效数据；第四个字节保存的是c的值。恩，好像有点明白了，windows采用的是大端模式来保存内存数据的。如果还不明白的话，我们不如用<code>db ebp-14h L10</code>来以字节为单位查看内存的内容（db的意思是dump byte，dw表示dump word，dd表示dump dword）:<br></p>\n<p>好，现在是不是发现所有的字节都颠倒了？就拿a变量来说，它标识的是前四个字节的内容，但是我们在上图中看到的这四个字节依次是<code>0a 00 00 00</code>，也就是说大端模式下，最低位的字节会放在最高的地址上，所以阅读这个内存的真正顺序是从右往左读，读取四个字节拼接起来。你之所以用dd看到的是正确的顺序，是因为winDBG给你优化了。那么我们继续观察s实例中第三个DWORD的内存内容，现在应该知道怎么读取了吧，成员变量c相对于结构体的偏移地址是0x008，从开头向后数8个字节（当然你如果熟悉命令的话，也可以输入<code>dd ebp-14h+8 L4</code>），然后c是一个char，所以只需要读取一个字节，那么它的内容就是<code>1e</code>；同样的方式你可以读取一下d的内存内容。这里再拓展一下，不仅读取内存是按照大端的方式来读取，写入内存也是同样的，这个之后再看汇编的时候大家注意一下。</p>\n<p>解决了结构体的内存分布问题，我们再看一下成员变量<code>e</code>，它和<code>a</code>的区别就是多了一个<code>unsigned</code>修饰符，但是汇编代码中没有体现出这个特性。编译器出错了？呵呵，这个问题等以后将数值的表示的时候再来慢慢研究（推荐可以去看CSAPP这本书）。</p>\n<p>恩，我重新提一下局部变量s表示的内存范围是<code>ebp-14h</code>到<code>ebp-4</code>，在之后会用到。继续人肉执行代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp+8]</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [ebp-14h]</span><br><span class=\"line\">mov dword ptr [eax], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-10h]</span><br><span class=\"line\">mov dword ptr [eax+4], edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [ebp-0Ch]</span><br><span class=\"line\">mov dword ptr [eax+8], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-8]</span><br><span class=\"line\">mov dword ptr [eax+0Ch], edx</span><br></pre></td></tr></table></figure></p>\n<p>第一句代码我现在也没有看懂是干嘛的，但是我知道ebp+8这个地址其实已经到了main函数的局部内存地址空间了，可能是和返回值有关我觉得。往下走，<code>move ecx, dowrd ptr [ebp-14h]</code>这里是把变量<code>a</code>放到<code>ecx</code>中我知道，貌似开始挪数据了。接着的<code>mov dword ptr [eax], ecx</code>，就把<code>ecx</code>的内容，也就是变量<code>a</code>的值拷贝到了eax指向的内存中了。下面的三组语句貌似和这两句相同，都是在拷贝变量的值。但是有5个变量，为什么只拷贝了四次内存呢？我觉得应该不用我解释吧。</p>\n<p>下面的一句<code>mov eax, dowrd ptr [ebp+8]</code>，又一次把<code>ebp+8</code>指向的内存的内容拷贝到了eax中，哎，没有优化的代码就是一堆傻逼操作。但是<code>ebp+8</code>保存的究竟是什么呢？额，我忘了保存这些东西了，所以再跟着我<code>Ctrl+Shift+F5</code>重新执行一次程序吧，回到main函数调用的地方：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/BeforeCallTestReturn.png\" title=\"调用TestReturn之前\"></p>\n<p>我们画一个图吧，以免忘记了当前堆栈的样子：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/BeforeCallTestReturnStack.png\" title=\"调用TestReturn之前的堆栈\"></p>\n<p>我特意标红了eax中保存的地址对应的地址空间，后面会用到这个地址，现在先忽略它。</p>\n<p>好了，然后我们执行<code>TestReturn</code>这个函数，堆栈内容如下：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/AfterCallTestReturn.png\" title=\"调用TestReturn之后\"></p>\n<p>在执行完前面三句代码之后，所形成的内存堆栈的图如下：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/AfterCallTestReturnStack.png\" title=\"调用TestReturn之后的堆栈\"></p>\n<p>这样你应该就能清楚地看到<code>ebp+8</code>保存的内容就是上一个堆栈中的eax的值，也就是0019fe24，也就是我标红的堆栈空间。但是至于为什么没有从上一个堆栈的头或者尾开始使用，我也暂时不知道，我暂时认为它是乱选的一个空闲内存。</p>\n<p>这样的话，经过刚刚的赋值拷贝，结果就是将变量s的内存原封不动拷贝到了<code>0019fe24~0019fe24+14h</code>地址空间中，所以你也可以这样理解，<code>main</code>函数传递了一个隐形的指针给<code>TestReturn</code>函数，而这个指针指向的内存就用于保存返回值。这个问题解决了我们就可以继续往下面执行了。</p>\n<p>下面的几句代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push edx</span><br><span class=\"line\">mov ecx, ebp</span><br><span class=\"line\">push eax</span><br><span class=\"line\">lea edx, [HelloWorld2005!TestReturn+0x74]</span><br><span class=\"line\">call HelloWorld2005!_RTC_CheckStackVars</span><br></pre></td></tr></table></figure></p>\n<p>从函数名能够看出这个其实是检查堆栈的，至于内部具体实现，本次不做任何分析，以后单独立一篇文章来搞定它。只是注意这里之所以要<code>push eax</code>，应该是_RTC_CheckStackVars这个函数会用到<code>eax</code>这个寄存器来保存返回值，所以说将它放到堆栈上保存起来，以供以后恢复。</p>\n<p>继续看下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pop eax</span><br><span class=\"line\">pop edx</span><br><span class=\"line\">pop edi</span><br><span class=\"line\">pop esi</span><br><span class=\"line\">pop ebx</span><br><span class=\"line\">mov esp, ebp</span><br><span class=\"line\">pop ebp</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure></p>\n<p>这里第一句就是恢复刚刚保存的<code>eax</code>的值，至于你想说“它傻么，为什么不先调用_RTC_CheckStackVars，再执行<code>mov eax, dowrd ptr [ebp+8]</code>”，额~~~~，好吧它确实很傻。之后的<code>pop edx</code>也是同样的作用。然后后面的三句是用来恢复上一个堆栈中的寄存器信息，与函数开始处的<code>push</code>对应。然后的两句则是用来恢复上一个堆栈的地址空间的，最后一句<code>ret</code>标识返回。</p>\n<p>直到这里我们知道了eax中保存着一个指针，它指向了<code>0019fe24</code>，之后的14h个字节的地址内容都是返回值的内容，那么我们就继续来看看返回到<code>main</code>函数之后又做了哪些事情吧：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/AfterTestReturnReturn.png\" title=\"TestReturn返回之后\"></p>\n<p>首先我们再回顾一下它的堆栈空间的内容：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/BeforeCallTestReturnStack.png\" title=\"此时main函数中堆栈分布\"></p>\n<p>然后执行<code>add esp, 4</code>，这句话等价于将栈顶元素出栈，只不过栈顶元素没有变量来保存，而只是单纯的丢弃掉。此时栈顶元素就是eax的值，也就是返回值的地址。</p>\n<p>看接下来执行的几句代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx, dword ptr [eax]</span><br><span class=\"line\">mov dword ptr [ebp-11Ch], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [eax+4]</span><br><span class=\"line\">mov dword ptr [ebp-118h], edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [eax+8]</span><br><span class=\"line\">mov dword ptr [ebp-114h], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [eax+0Ch]</span><br><span class=\"line\">mov dword ptr [ebp-110h], edx</span><br></pre></td></tr></table></figure></p>\n<p>是不是似曾相识呢？和刚刚返回值的拷贝一样对不对，只是这一次是把<code>0019fe24</code>处的内存地址拷贝到<code>ebp-11Ch</code>。好了往下看还有一样的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-11Ch]</span><br><span class=\"line\">mov dword ptr [ebp-14h], eax</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [ebp-118h]</span><br><span class=\"line\">mov dword ptr [ebp-10h], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-114h]</span><br><span class=\"line\">mov dword ptr [ebp-0Ch], edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-110h]</span><br><span class=\"line\">mov dword ptr [ebp-8], eax</span><br></pre></td></tr></table></figure></p>\n<p>这里又发生了一次内存的拷贝，将<code>ebp-11Ch</code>的内容拷贝到了<code>ebp-14h</code>的地方。所以想想吧，在完全没有开优化的情况下，返回一个结构体居然要拷贝三次内存，确实很浪费内存和时间啊。当然我现在也不知道优化之后会怎么样，可能会变好吧，以后再研究release。</p>\n<p>那经过这样一番折腾，返回值终于到了我们熟悉的位置<code>ebp-14h~ebp-8</code>这个区间。好吧，它还是给你空出来4个字节，我还没弄清楚这空出来的4个字节究竟能用来干嘛。到现在为止，<code>TestReturn</code>函数的调用已经讲完了，大家现在可以慢慢消化一下再继续。</p>\n<hr>\n<p>跨过华丽的分割线，我们继续看下面的<code>TestValue</code>函数（现在s的值保存在<code>ebp-14h~ebp-8</code>的区间中）。从准备参数到调用<code>TestValue</code>，汇编代码如下：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/CallTestValue.png\" title=\"调用TestValue\"></p>\n<p>首先它执行<code>sub esp, 10h</code>，应该是给<code>TestValue</code>传入的参数预留空间，我猜的。然后又是一坨类似的拷贝代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, esp</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [ebp-14h]</span><br><span class=\"line\">mov dowrd ptr [eax], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-10h]</span><br><span class=\"line\">mov dword ptr [eax+4], edx</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dowrd ptr [ebp-0Ch]</span><br><span class=\"line\">mov dword ptr [eax+8], ecx</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-8]</span><br><span class=\"line\">mov dword ptr [eax+0Ch], edx</span><br></pre></td></tr></table></figure></p>\n<p>我不想详细说了，第一句<code>eax</code>保存了<code>esp</code>的值，<code>esp</code>指向了当前的栈顶。而这段代码就是把<code>s</code>的内容拷贝到刚刚预留的堆栈空间中，也就是<code>esp~esp+10h</code>这块内存中。所以其实你可以理解为现在堆栈的顶部16个字节保存着s的内容。然后我们就开始调用<code>TestValue</code>函数了，记得这里有一个把<code>TestValue</code>返回继续执行的地址进行压栈的隐式操作。然而<code>TestValue</code>函数的实现我并没有写任何东西，所以说可以直接过了。</p>\n<p>所以这里我想让大家知道的是，函数参数的地址是通过堆栈进行传递的，而这个堆栈的内存其实是由上一个函数的局部堆栈提供的，保存在上一个函数局部堆栈的栈顶位置。所以说在函数中使用这些内存的时候，是通过<code>esp+8</code>这样的偏移的形式来进行引用的。具体细节大家可以自己写代码进行研究啦，我就不赘述了。</p>\n<p>继续往下面执行<code>TestReference</code>函数，它执行的代码逻辑如下：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/CallTestReference.png\" title=\"调用TestReference\"></p>\n<p>哦哦对，还有一个没有讲，在<code>TestValue</code>返回之后，又执行了这样一句代码：<code>add esp, 10h</code>，这个其实就是清空按值传递时，堆栈上产生的临时对象的（虽然没有真正清空）。</p>\n<p>接着执行<code>lea eax, [ebp-14h]</code>，应该还记得<code>ebp-14h</code>的位置上保存着什么么？s变量在堆栈上的基地址。把它赋值给<code>eax</code>寄存器后，利用<code>push eax</code>进行压栈，然后接着就调用了<code>TestReference</code>函数。而在函数中你要使用这个栈上变量的方式，和上面相同，也是同样引用<code>esp+8</code>指向的值（这里说明下<code>esp</code>指向的是上一个函数的堆栈基地址，<code>esp+4</code>指向的是该函数返回后继续执行的地址，<code>esp+8</code>开始才是上一个函数堆栈的顶部），比如如果这里我需要在函数中执行一个<code>s.a=10</code>的语句的话，那么汇编代码可能是如下所示的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea eax, [ebp+8]            ;得到引用的变量的指针</span><br><span class=\"line\">mov ecx, 0ah;               ;将10这个值放到ecx寄存器中</span><br><span class=\"line\">mov dword ptr [eax], ecx    ;将10这个值真正放到目标地址</span><br></pre></td></tr></table></figure></p>\n<p>当然这些都是我自己写的，只是为大家做一个演示，如何读取和写入引用变量的内容。如果你要验证的话最好以实际生成的代码为准。</p>\n<p>接着往下看<code>TestPointer</code>函数的调用，诶，居然和<code>TestReference</code>生成的代码一模一样：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/CallTestPointer.png\" title=\"调用TestPointer\"></p>\n<p>当然一开始恢复堆栈的那句代码不算啦。所以这个函数我们就不分析了，直接过。</p>\n<p>往下再瞄几行，发现调用<code>TestConstReference</code>的代码好像也是一模一样：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/CallTestConstReference.png\" title=\"调用TestConstReference\"></p>\n<p>好吧，现在应该能够清楚下面几个问题了：</p>\n<ol>\n<li>编译器如何实现引用的？ 答案是指针，至少在VS2005上是的。</li>\n<li>指针和引用有什么区别？ 好像也没什么区别</li>\n<li>const引用和引用有什么区别？ 好像也是一样的</li>\n</ol>\n<p>那么问题来了，既然指针、引用、const引用都是同一个实现，那么为什么C++还要分那么多东西呢？有想过没有？自己想1分钟，再往下看。</p>\n<hr>\n<p>好吧，我来说下我的理解，其实指针和引用还是有区别的啊，指针有空指针，引用却没有空引用，这是指针和引用的本质区别。使用引用的一个好处就是，能够从语法的层面杜绝你出现空指针的情况，减少因为空指针导致的崩溃。而使用const引用呢，则是从语义的层面，在编译期就能够判断出你非法的赋值操作，比如说你传了一个const引用给函数，那么你的本意肯定是不希望这个变量被改变，但是你在函数里面对这个const引用赋值了，那么编译器在进行语义分析的时候就能够帮你纠正出这个错误，至于减少bug的话，不同场景不同表现啦。因为有一堆人在遇到这种语义错误的时候，选择的是去掉const，而不是继续调整代码的结构。所以，对于const的使用，见仁见智吧。</p>\n<p>最后一个<code>Simple e = {0}</code>算是一个额外的扩展研究吧，我们可以看下他的代码：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/InitSimple.png\" title=\"对结构体进行初始化\"></p>\n<p>我们可以看到下面这四句代码是初始化成员变量的内容的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-2Ch], 0      ;a</span><br><span class=\"line\">mov dword ptr [ebp-28h], eax    ;b</span><br><span class=\"line\">mov dword ptr [ebp-24h], eax    ;c和d</span><br><span class=\"line\">mov dword ptr [ebp-20h], eax    ;e</span><br></pre></td></tr></table></figure></p>\n<p>但是为什么第一个变量的初始化方式不同，我也不知道，我也想掀桌啊妈蛋，不过反正结果都一样，VS这样做可能是傻逼了吧。可以知道他其实是以DWORD（4个字节）为单位进行初始化的，而不是一个变量一个变量进行初始化的，其实相当于做了一个<code>memset</code>的过程。</p>\n<p>你还不知道<code>eax</code>是啥？看这句代码<code>xor eax, eax</code>，<code>xor</code>就是亦或，任何值和自己亦或得到的结果都是0，所以这句代码就已经将eax的值覆盖成0了。至于它和<code>mov eax, 0</code>有什么区别，嘿嘿，我们不妨看下面两个语句的二进制代码，都是我从真实的代码里面摘抄的，分号之前的是汇编代码对应的二进制代码，分号后面的是汇编代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bacccccccc      ;mov     edx,0CCCCCCCCh</span><br><span class=\"line\">33c0            ;xor     eax,eax</span><br></pre></td></tr></table></figure></p>\n<p>能看出区别来了么，对，保存<code>mov</code>语句比保存<code>xor</code>语句需要更多的存储空间，所以用xor生成代码更加简短。这里也算是一种优化吧。</p>\n<p>那么此时我们不妨看一下e在内存中的内容，利用<code>dd ebp-2Ch L4</code>即可：<br><img src=\"/2016/04/20/windbg-windbg-chapter2/ddebp-2ChL4.png\" title=\"e在内存中的内容\"></p>\n<p>好吧全都是0，没啥好看的。</p>\n<p>那么到这里讲解就全都结束了，至于main函数后面还有的那部分，可以完全参考我上一章将的内容，只做了两件事情，一个就是检查堆栈，另外一个就是恢复上一个函数的堆栈和寄存器。由于该代码过于简单，release版本基本上会被优化得不剩什么代码，所以照旧不讲解release版本的汇编代码。</p>\n<p>那么下次再见吧，拜拜！</p>\n<h2 id=\"回顾：\"><a href=\"#回顾：\" class=\"headerlink\" title=\"回顾：\"></a>回顾：</h2><h3 id=\"关于WinDBG\"><a href=\"#关于WinDBG\" class=\"headerlink\" title=\"关于WinDBG\"></a>关于WinDBG</h3><p>无</p>\n<h3 id=\"关于汇编\"><a href=\"#关于汇编\" class=\"headerlink\" title=\"关于汇编\"></a>关于汇编</h3><ol>\n<li>ebp指向了上一个函数堆栈的基地址</li>\n<li>ebp+4指向了函数返回时，继续执行的地址</li>\n<li>ebp+8是上一个函数局部堆栈的栈顶，一般函数参数都保存在这个地方</li>\n<li>调用函数时，会发生一个隐式的压栈操作，即把<code>call</code>指令的下一个指令的地址进行压栈，（其实这个地址的值就是<code>eip</code>，在函数ret时，同样也会执行一个<code>pop eip</code>的操作）</li>\n<li><code>mov eax, 0</code>需要5个字节记录，<code>xor eax, eax</code>只需要两个字节</li>\n<li>区分取寄存器的值（<code>lea eax, [ebp+8]</code>）和取寄存器指向地址的内容（<code>mov eax, dword ptr [ebp+8]</code>）</li>\n</ol>\n<h3 id=\"关于C\"><a href=\"#关于C\" class=\"headerlink\" title=\"关于C++\"></a>关于C++</h3><ol>\n<li>结构体初始化器所做的操作其实和<code>memset</code>类似，不会按照变量为单位进行初始化，而是按照DWORD为单位进行初始化</li>\n<li>指针、引用在VS2005上的实现并没有什么区别，唯一的区别就是指针可空，引用不可空</li>\n<li>引用和const引用在实现上也没有任何区别，只是方便了编译器在语义分析时及时报错</li>\n</ol>"},{"title":"WinDBG观世界（四）","date":"2016-04-26T04:22:37.000Z","_content":"\n## 内容概要\n前面一章在探究类的时候，遗留了很多问题，比如参数的构造顺序，虚函数的调用实现等等，那么这一章的就是来填这些坑的。当然这一章不会把这些坑都填完，因为类里面需要讲的东西实在是太多了。那么我先把这一章里面需要既觉得几个问题都罗列出来吧：\n1. 如果我在构造函数中调用虚函数，会执行到正确的（或者说我们所希望的）虚函数么\n2. 构造函数成员初始化的顺序\n3. 在子类中，父类的数据被放在什么地方\n4. 普通成员覆盖和虚函数重写有什么区别\n5. 虚函数重写之后，子类的虚函数表会发生什么变化\n6. 发生继承时，子类是会完全复制父类的虚函数表，还是只会将自己类中的虚函数写入表中\n7. 通过函数指针进行调用和直接调用成员函数有什么区别\n8. 父类能够通过成员函数指针来调用子类的普通成员函数和虚函数么\n9. 子类能够通过成员函数指针来调用父类的普通成员函数和虚函数么\n<!--more-->\n## 执行哪个函数？运行的时候才知道啊！\n本章进行分析的代码内容如下：\n```cpp\nclass TestBase\n{\npublic:\n    TestBase()\n        : e(12)\n        , c(3)\n        , a(12)\n        , b(1)\n        , f('l')\n    {\n        d = 19;\n\n        VirtualFunc1();\n    }\n\n    ~TestBase()\n    {\n        a = 12;\n    }\n\npublic:\n    virtual void VirtualFunc1()\n    {\n        a += 12;\n    }\n\n    virtual void VirtualFunc2()\n    {\n        b += 22;\n    }\n\npublic:\n    void NormalFunc1()\n    {\n        c += 14;\n    }\n\nprotected:\n    int a;\n    int b;\n    char c;\n    char d;\n    short e;\n\nprivate:\n    char f;\n};\n\nclass TestDerive \n    : public TestBase\n{\npublic:\n    TestDerive(int a)\n        : TestBase()\n        , f(a)\n    {\n        VirtualFunc1();\n    }\n\n    ~TestDerive()\n    {\n        b = 12;\n    }\n\npublic:\n    virtual void VirtualFunc1()\n    {\n        a += 99;\n    }\n\npublic:\n    void NormalFunc1()\n    {\n        c += 54;\n    }\n\nprivate:\n    int f;\n};\n\nint main(int argc, char** argv)\n{\n    typedef void (TestBase::*BaseNormalFuncType)();\n    BaseNormalFuncType baseNormalFuncPointer = &TestBase::NormalFunc1;\n\n    typedef void (TestDerive::*DeriveNormalFuncType)();\n    DeriveNormalFuncType deriveNormalFuncPointer = &TestDerive::NormalFunc1;\n\n    typedef void (TestBase::*BaseVirtualFunc1Type)();\n    BaseVirtualFunc1Type baseVirtualFunc1Pointer = &TestBase::VirtualFunc1;\n\n    typedef void (TestBase::*BaseVirtualFunc2Type)();\n    BaseVirtualFunc2Type baseVirtualFunc2Pointer = &TestBase::VirtualFunc2;\n\n    typedef void (TestDerive::*DeriveVirtualFunc1Type)();\n    DeriveVirtualFunc1Type deriveVirtualFunc1Pointer = &TestDerive::VirtualFunc1;\n\n    typedef void (TestDerive::*DeriveVirtualFunc2Type)();\n    DeriveVirtualFunc2Type deriveVirtualFunc2Pointer = &TestDerive::VirtualFunc2;\n\n    TestBase base1;\n    base1.NormalFunc1();\n    base1.VirtualFunc1();\n    base1.VirtualFunc2();\n\n    TestDerive derive1(77);\n    derive1.NormalFunc1();\n    derive1.VirtualFunc1();\n    derive1.VirtualFunc2();\n\n\n    (base1.*baseNormalFuncPointer)();\n    (derive1.*deriveNormalFuncPointer)();\n    (derive1.*baseNormalFuncPointer)();\n    \n    (base1.*baseVirtualFunc1Pointer)();\n    (base1.*baseVirtualFunc2Pointer)();\n    \n    (derive1.*baseVirtualFunc1Pointer)();\n    (derive1.*baseVirtualFunc2Pointer)();\n\n    (derive1.*deriveVirtualFunc1Pointer)();\n    (derive1.*deriveVirtualFunc2Pointer)();\n}\n```\n\n代码确实越来越长了，但是其实分析的内容不是特别多，那么就照旧，打开windbg一步一步来分析代码吧。\n\n跳过初始化的部分，我们来到第一句代码，诶，为什么`typedef void (TestBase::*BaseNormalFuncType)()`没有执行啊喂，第一句代码直接运行赋值操作了？\n{% asset_img AssignMemberFuncPointer.png 第一句代码 %}\n\n恩，其实我也不知道，而且我google也没有找到答案，咱忽略这个问题好不好？\n\n那么看下面六个函数指针的赋值吧，前面两个没话说，和普通的函数地址一样，因为经过上一章的研究，其实`this`指针并不是类内部或者函数内部的，而是函数调用时外部通过`ecx`寄存器传递给函数的一个隐式参数。（当然如果你想知道函数的地址是怎么得到的，可以等我开一个讲编译器的新坑）那么这里我们主要需要看的是最后四个虚函数的指针的赋值。可以看到它的代码如下：\n```asm\nmov dword ptr [ebp-2Ch], offset HelloWorld2005!TestBase::`vcall'{0}'\nmov dword ptr [ebp-38h], offset HelloWorld2005!TestBase::`vcall'{4}'\nmov dword ptr [ebp-44h], offset HelloWorld2005!TestBase::`vcall'{0}'\nmov dword ptr [ebp-50h], offset HelloWorld2005!TestBase::`vcall'{4}'\n```\n\n不对啊喂，我后面两个明明是取的`TestDerive`中的虚函数，为什么在汇编代码中还是给我`TestBase`中虚函数的地址啊？好吧，我暂时也无法给你解答，把所有的疑问全部都放一放，然后继续研究吧。\n\n然后我们开始定义第一个类变量：\n{% asset_img FirstClassVariable.png 定义TestBase变量 %}\n\n我们进入到构造函数内部看下吧（这里`this`指针的值为`0019febc）：\n{% asset_img TestBaseConstructor.png TestBase的构造函数 %}\n\n还记得下面构造函数会做哪些事情吗？\n1. 将`this`指针放到`ebp-8`的位置\n2. 将`ebp-8`位置的值放到`eax`中\n3. 如果有虚函数，下面就会把虚函数表的地址放到`this`指针指向的第一个地址\n\n这一章里面主要研究虚函数表，之所以叫虚函数表，我想应该就是一张表里面有很多的`entry`，然后每个`entry`指向了一个对应的虚函数地址吧，好吧这都是我意淫出来的。所以，我们首先用`x`指令来查看`TestBase`中所有虚函数的地址是多少：\n{% asset_img TestBaseVirtualFunctionsAddress.png TestBase中的虚函数 %}\n\n然后我们用`dd eax`来查看`this`指针指向的内存：\n{% asset_img TestBaseLookupThis.png this指针指向的内存 %}\n\n第一个4字节的值`00404130`就是虚函数表的地址，我们再用`dd 00404130`查看这个地址下是不是存放了上面两个虚函数的地址：\n{% asset_img TestBaseContentOfVirtualTable.png TestBase虚函数表的内容 %}\n\n这不是演习，果然后面一个一个存放着虚函数的指针，暂且认为它们是按照声明的顺序来存放的吧，毕竟其实这个顺序如果你不是想`hack`的话，对于我们来说没什么意义。所以从汇编的层面来看的话，虚函数表其实没啥神奇的。\n\n好吧，那么我们继续往下面看，需要注意的是，我这里把成员变量声明的顺序和类初始化器的顺序安排成不一致，那么现在我们需要一边看一边关注是在为哪个变量赋值。或者。。。。。我们不妨用`dt`看下`TestBase`的内存结构吧：\n{% asset_img dtTestBase.png TestBase的内存结构 %}\n\n额，内存结构里面的内存对齐我觉得可以自己分析，我这里就不多说了。然后就是对照着目标地址和内存结构进行对应了：\n{% asset_img TestBaseInitSequence.png TestBase成员变量初始化顺序 %}\n\n诶，好像和我在初始化器里面摆放的顺序不一样，完全就是和成员变量声明的顺序是一致的，当然除了最后一个在函数体中进行的一次赋值。这样的话概要中的第二个问题就已经解决了。\n\n接着下面调用了一个虚函数`VirtualFunc1`，进去看了下好像和我们以前调用的普通函数没有什么区别，那我们就直接跳过吧：\n{% asset_img TestBaseVirtualFunc2Function.png VirtualFunc1的汇编实现 %}\n\n然后我们跳过函数的调用，等下一起看，直接来看下`TestDerive`对象的定义，进去它的构造函数看下汇编实现（此时`this`指针的值是`0019fe9c`）：\n{% asset_img TestDeriveConstructor.png TestDerive的构造函数 %}\n\n在看调用父类构造函数之前，我们继续用`dt`来看下`TestDerive`的内存结构：\n{% asset_img dtTestDerive.png TestDerive的内存结构 %}\n\n可以看出，`TestDerive`是把父类的内存结构拷贝过来（而不是在开始的位置放一个`TestBase`），然后在最后加上一个`TestDerive`中定义的变量`f`，而虚函数表指针也只有一个。根据之前的经验，类会先初始化虚函数表，在进行成员变量的初始化，然而在往下看的过程中，可以看到：\n```asm\nmov dword ptr [ebp-14h], ecx\nmov ecx, dword ptr [ebp-14h]\ncall HelloWorld2005!TestBase::TestBase\n```\n\n尼玛，为什么这里`this`指针就存放在了`ebp-14h`这个位置上，之前都是放在`ebp-8`的位置的。哎，我觉得我又要画一个此时堆栈的内存图了：\n{% asset_img TestDeriveCtorBeforeBaseCtorStackMemory.png 此时堆栈的内存图 %}\n\n= =，为什么这个构造函数里面又多了这么多东西？说好的只需要初始化堆栈区域呢？至于为什么会多出这么多东西，我暂时也不知道，所以无法给大家解答。那这样的话，加上第一个局部变量都会空出4个字节出来的尿性，这里`this`指针确实应该放在`ebp-14h`的位置。\n\n接着它就开始调用父类构造函数`TestBase`了。这么一来，虚函数表就肯定是在父类中进行赋值了，所以这样的话，父类中调用的`VirtualFunc1`肯定也就是`TestBase`中的`VirtualFunc1`了。这个我就不跟进去看了，那么现在的问题就是，我在子类中重写了虚函数`VirtualFunc1`，那么这个虚函数的地址是怎么写入到虚函数表的呢？继续往下看就知道了。\n\n下面一句`mov dword ptr [ebp-4], 0`这个我还是没有明白是啥意思，忽略它。主要是下面这两句：\n```asm\nmov eax, dword ptr [ebp-14h]\nmov dword ptr [eax], offset HelloWorld2005!TestDerive::`vftable'\n```\n\n看到这里的动作就是修改`this`指向的基地址的值，也就是虚表的地址，我们前面拿到的虚函数表的地址是`00404130`，那我们这里看下它的地址是多少：\n{% asset_img TestDeriveAfterAssignVftable.png 虚函数表的地址 %}\n\n可看到这个地址变成了`0040413c`。那么查看这个地址下的内容：\n{% asset_img TestDeriveVtableContent.png 虚函数表中的内容 %}\n\n我们可以来看下是不是正好就是我们虚函数的地址，利用`x`指令即可：\n{% asset_img TestDeriveVirtualFunctionAddress.png 虚函数地址 %}\n\n居然没有输出`VirtualFunc2`的地址，只能猜测`x`指令只能输出类中实际实现的函数的地址。但是这里我们仍然可以看到`VirtualFunc1`的地址明显变成了`00401460`，正好就是虚函数表中第一个地址。而虚函数表中第二个地址也正好就是父类中`VirtualFunc2`的地址。所以其实有几个点我们就弄清楚了：\n1. 在构造时会先调用父类的构造函数，并且将父类的虚函数表地址传递给`this`指针，所以在父类构造函数中仍然可以调用虚函数，但是调用的只是父类中实现的版本\n2. 在父类构造函数返回后，会将子类中的虚函数表地址传递给`this`指针，也就是会覆盖掉父类的虚函数表地址。所以在此之后，构造函数中调用的虚函数就是子类中的版本了。\n\n接着往下看到两句\n```asm\nmov eax, dword ptr [ebp-14h]    ;获取this指针\nmov ecx, dword ptr [ebp+8]      ;拿到传递给构造函数的参数\nmov dword ptr [eax+14h], ecx    ;执行f的初始化\n```\n\n加上注释之后也就不需要我解释了，大家都明白的。\n\n再往下看，疑惑的地方就来了：\n```asm\nmov eax, dword ptr [ebp-14h]                    ;拿到this指针\ncall HelloWorld2005!TestDerive::VirtualFunc1    ;调用VirtualFunc1\n```\n\n说好的运行时多态呢？为什么好像在编译期直接就给我确定了调用的地址了？老师教的不是说先查找虚函数表，然后再找到对应的虚函数地址么？好像和我以前知道的有一点偏差。但是我现在也不知道为什么，我暂时理解为编译的优化吧。这里留一个疑问，以后看看能不能解决。\n\n这时我们回到`main`函数中继续看那几个函数调用，貌似看起来也都是直接在编译期就决定了函数跳转到哪里了，和普通的函数完全没有区别。是不是被那些将虚函数的书坑了啊？我现在有一点怀疑了。当然不排除怀疑这是微软的特立独行。\n\n算了，我们继续看下面通过成员函数指针进行的调用，首先是三个普通成员函数，它对应的汇编代码是：\n```asm\nlea ecx, [ebp-6Ch]\ncall dword ptr [ebp-14h]\n\nlea ecx, [ebp-8Ch]\ncall dword ptr [ebp-20h]\n\nlea ecx, [ebp-8Ch]\ncall dword ptr [ebp-14h]\n```\n\n可以看到其实对成员函数指针的调用和平时成员函数的调用没有什么区别，只是把`call`的函数名变成了一个地址，`this`指针仍然存放在`ecx`寄存器中。而且我们可以通过`x`指令来查看两个普通函数的地址：\n{% asset_img NormalFunc1Addresses.png NormalFunc1的地址 %}\n\n好像在这一块儿并没有任何歧义，因为知道地址对应的函数之后，都很好理解该跳转到哪里，所以我就不多说什么了。接下来\n\n接着看虚函数，因为之前在前面虚函数地址进行赋值时，看到`TestBase`的虚函数地址和`TestDerive`的虚函数地址居然完全一样，这和我们刚刚用`x`命令看到的不同。好啊吧，闲话少说，首先看第一组，用`base1`调用`baseVirtualFunc1Pointer`和`baseVirtualFunc2Pointer`，对应的汇编代码是：\n```asm\nlea ecx, [ebp-6Ch]\ncall dword ptr [ebp-2Ch]\n\nlea ecx, [ebp-6Ch]\ncall dword ptr [ebp-38h]\n```\n\n在执行`call`语句时用`F11`进入函数内部查看，发现这次调用到的函数不一样了，如下：\n{% asset_img TestBaseVcall0.png 调用虚函数后的结果 %}\n\n但是细看的话，其实很简(sha)单(bi)！！！！！因为它就只做了两个操作：\n1. 获取到this指针指向的第一个值（四字节），而这个值正好就是虚函数表的地址\n2. 然后直接对虚函数表指向的第一个函数地址进行一次跳转(`jmp`)\n\n额。。。。好像这样做确实能够实现调用到正确的虚函数哦。恩，果然是源码之下，了无秘密。只怪我之前怎么没想到呢= =\n\n那其实下面的那些虚函数的调用也就不需要我分析了吧，只是调用`TestVirtualFunc2`的时候，跳转函数里面在虚表的基础上，加了四个字节的偏移。把这里的虚函数调用也理解为做了一个函数的跳转，这个函数跳转中所做的事情就是获取到正确的虚函数地址，而这个虚函数地址的获取依赖于构造对象时，赋值给`this`指针的虚表地址。\n\n那么今天的分析就到这里了，大家好好消化一下吧，如果对本系列有什么改进的建议，欢迎找我提出来(cloudy064@gmail.com)\n\n","source":"_posts/windbg/windbg-chapter4.md","raw":"---\ntitle: WinDBG观世界（四）\ndate: 2016-04-26 12:22:37\ncategories: windbg\ntags: [windbg,disassembly,c++]\n---\n\n## 内容概要\n前面一章在探究类的时候，遗留了很多问题，比如参数的构造顺序，虚函数的调用实现等等，那么这一章的就是来填这些坑的。当然这一章不会把这些坑都填完，因为类里面需要讲的东西实在是太多了。那么我先把这一章里面需要既觉得几个问题都罗列出来吧：\n1. 如果我在构造函数中调用虚函数，会执行到正确的（或者说我们所希望的）虚函数么\n2. 构造函数成员初始化的顺序\n3. 在子类中，父类的数据被放在什么地方\n4. 普通成员覆盖和虚函数重写有什么区别\n5. 虚函数重写之后，子类的虚函数表会发生什么变化\n6. 发生继承时，子类是会完全复制父类的虚函数表，还是只会将自己类中的虚函数写入表中\n7. 通过函数指针进行调用和直接调用成员函数有什么区别\n8. 父类能够通过成员函数指针来调用子类的普通成员函数和虚函数么\n9. 子类能够通过成员函数指针来调用父类的普通成员函数和虚函数么\n<!--more-->\n## 执行哪个函数？运行的时候才知道啊！\n本章进行分析的代码内容如下：\n```cpp\nclass TestBase\n{\npublic:\n    TestBase()\n        : e(12)\n        , c(3)\n        , a(12)\n        , b(1)\n        , f('l')\n    {\n        d = 19;\n\n        VirtualFunc1();\n    }\n\n    ~TestBase()\n    {\n        a = 12;\n    }\n\npublic:\n    virtual void VirtualFunc1()\n    {\n        a += 12;\n    }\n\n    virtual void VirtualFunc2()\n    {\n        b += 22;\n    }\n\npublic:\n    void NormalFunc1()\n    {\n        c += 14;\n    }\n\nprotected:\n    int a;\n    int b;\n    char c;\n    char d;\n    short e;\n\nprivate:\n    char f;\n};\n\nclass TestDerive \n    : public TestBase\n{\npublic:\n    TestDerive(int a)\n        : TestBase()\n        , f(a)\n    {\n        VirtualFunc1();\n    }\n\n    ~TestDerive()\n    {\n        b = 12;\n    }\n\npublic:\n    virtual void VirtualFunc1()\n    {\n        a += 99;\n    }\n\npublic:\n    void NormalFunc1()\n    {\n        c += 54;\n    }\n\nprivate:\n    int f;\n};\n\nint main(int argc, char** argv)\n{\n    typedef void (TestBase::*BaseNormalFuncType)();\n    BaseNormalFuncType baseNormalFuncPointer = &TestBase::NormalFunc1;\n\n    typedef void (TestDerive::*DeriveNormalFuncType)();\n    DeriveNormalFuncType deriveNormalFuncPointer = &TestDerive::NormalFunc1;\n\n    typedef void (TestBase::*BaseVirtualFunc1Type)();\n    BaseVirtualFunc1Type baseVirtualFunc1Pointer = &TestBase::VirtualFunc1;\n\n    typedef void (TestBase::*BaseVirtualFunc2Type)();\n    BaseVirtualFunc2Type baseVirtualFunc2Pointer = &TestBase::VirtualFunc2;\n\n    typedef void (TestDerive::*DeriveVirtualFunc1Type)();\n    DeriveVirtualFunc1Type deriveVirtualFunc1Pointer = &TestDerive::VirtualFunc1;\n\n    typedef void (TestDerive::*DeriveVirtualFunc2Type)();\n    DeriveVirtualFunc2Type deriveVirtualFunc2Pointer = &TestDerive::VirtualFunc2;\n\n    TestBase base1;\n    base1.NormalFunc1();\n    base1.VirtualFunc1();\n    base1.VirtualFunc2();\n\n    TestDerive derive1(77);\n    derive1.NormalFunc1();\n    derive1.VirtualFunc1();\n    derive1.VirtualFunc2();\n\n\n    (base1.*baseNormalFuncPointer)();\n    (derive1.*deriveNormalFuncPointer)();\n    (derive1.*baseNormalFuncPointer)();\n    \n    (base1.*baseVirtualFunc1Pointer)();\n    (base1.*baseVirtualFunc2Pointer)();\n    \n    (derive1.*baseVirtualFunc1Pointer)();\n    (derive1.*baseVirtualFunc2Pointer)();\n\n    (derive1.*deriveVirtualFunc1Pointer)();\n    (derive1.*deriveVirtualFunc2Pointer)();\n}\n```\n\n代码确实越来越长了，但是其实分析的内容不是特别多，那么就照旧，打开windbg一步一步来分析代码吧。\n\n跳过初始化的部分，我们来到第一句代码，诶，为什么`typedef void (TestBase::*BaseNormalFuncType)()`没有执行啊喂，第一句代码直接运行赋值操作了？\n{% asset_img AssignMemberFuncPointer.png 第一句代码 %}\n\n恩，其实我也不知道，而且我google也没有找到答案，咱忽略这个问题好不好？\n\n那么看下面六个函数指针的赋值吧，前面两个没话说，和普通的函数地址一样，因为经过上一章的研究，其实`this`指针并不是类内部或者函数内部的，而是函数调用时外部通过`ecx`寄存器传递给函数的一个隐式参数。（当然如果你想知道函数的地址是怎么得到的，可以等我开一个讲编译器的新坑）那么这里我们主要需要看的是最后四个虚函数的指针的赋值。可以看到它的代码如下：\n```asm\nmov dword ptr [ebp-2Ch], offset HelloWorld2005!TestBase::`vcall'{0}'\nmov dword ptr [ebp-38h], offset HelloWorld2005!TestBase::`vcall'{4}'\nmov dword ptr [ebp-44h], offset HelloWorld2005!TestBase::`vcall'{0}'\nmov dword ptr [ebp-50h], offset HelloWorld2005!TestBase::`vcall'{4}'\n```\n\n不对啊喂，我后面两个明明是取的`TestDerive`中的虚函数，为什么在汇编代码中还是给我`TestBase`中虚函数的地址啊？好吧，我暂时也无法给你解答，把所有的疑问全部都放一放，然后继续研究吧。\n\n然后我们开始定义第一个类变量：\n{% asset_img FirstClassVariable.png 定义TestBase变量 %}\n\n我们进入到构造函数内部看下吧（这里`this`指针的值为`0019febc）：\n{% asset_img TestBaseConstructor.png TestBase的构造函数 %}\n\n还记得下面构造函数会做哪些事情吗？\n1. 将`this`指针放到`ebp-8`的位置\n2. 将`ebp-8`位置的值放到`eax`中\n3. 如果有虚函数，下面就会把虚函数表的地址放到`this`指针指向的第一个地址\n\n这一章里面主要研究虚函数表，之所以叫虚函数表，我想应该就是一张表里面有很多的`entry`，然后每个`entry`指向了一个对应的虚函数地址吧，好吧这都是我意淫出来的。所以，我们首先用`x`指令来查看`TestBase`中所有虚函数的地址是多少：\n{% asset_img TestBaseVirtualFunctionsAddress.png TestBase中的虚函数 %}\n\n然后我们用`dd eax`来查看`this`指针指向的内存：\n{% asset_img TestBaseLookupThis.png this指针指向的内存 %}\n\n第一个4字节的值`00404130`就是虚函数表的地址，我们再用`dd 00404130`查看这个地址下是不是存放了上面两个虚函数的地址：\n{% asset_img TestBaseContentOfVirtualTable.png TestBase虚函数表的内容 %}\n\n这不是演习，果然后面一个一个存放着虚函数的指针，暂且认为它们是按照声明的顺序来存放的吧，毕竟其实这个顺序如果你不是想`hack`的话，对于我们来说没什么意义。所以从汇编的层面来看的话，虚函数表其实没啥神奇的。\n\n好吧，那么我们继续往下面看，需要注意的是，我这里把成员变量声明的顺序和类初始化器的顺序安排成不一致，那么现在我们需要一边看一边关注是在为哪个变量赋值。或者。。。。。我们不妨用`dt`看下`TestBase`的内存结构吧：\n{% asset_img dtTestBase.png TestBase的内存结构 %}\n\n额，内存结构里面的内存对齐我觉得可以自己分析，我这里就不多说了。然后就是对照着目标地址和内存结构进行对应了：\n{% asset_img TestBaseInitSequence.png TestBase成员变量初始化顺序 %}\n\n诶，好像和我在初始化器里面摆放的顺序不一样，完全就是和成员变量声明的顺序是一致的，当然除了最后一个在函数体中进行的一次赋值。这样的话概要中的第二个问题就已经解决了。\n\n接着下面调用了一个虚函数`VirtualFunc1`，进去看了下好像和我们以前调用的普通函数没有什么区别，那我们就直接跳过吧：\n{% asset_img TestBaseVirtualFunc2Function.png VirtualFunc1的汇编实现 %}\n\n然后我们跳过函数的调用，等下一起看，直接来看下`TestDerive`对象的定义，进去它的构造函数看下汇编实现（此时`this`指针的值是`0019fe9c`）：\n{% asset_img TestDeriveConstructor.png TestDerive的构造函数 %}\n\n在看调用父类构造函数之前，我们继续用`dt`来看下`TestDerive`的内存结构：\n{% asset_img dtTestDerive.png TestDerive的内存结构 %}\n\n可以看出，`TestDerive`是把父类的内存结构拷贝过来（而不是在开始的位置放一个`TestBase`），然后在最后加上一个`TestDerive`中定义的变量`f`，而虚函数表指针也只有一个。根据之前的经验，类会先初始化虚函数表，在进行成员变量的初始化，然而在往下看的过程中，可以看到：\n```asm\nmov dword ptr [ebp-14h], ecx\nmov ecx, dword ptr [ebp-14h]\ncall HelloWorld2005!TestBase::TestBase\n```\n\n尼玛，为什么这里`this`指针就存放在了`ebp-14h`这个位置上，之前都是放在`ebp-8`的位置的。哎，我觉得我又要画一个此时堆栈的内存图了：\n{% asset_img TestDeriveCtorBeforeBaseCtorStackMemory.png 此时堆栈的内存图 %}\n\n= =，为什么这个构造函数里面又多了这么多东西？说好的只需要初始化堆栈区域呢？至于为什么会多出这么多东西，我暂时也不知道，所以无法给大家解答。那这样的话，加上第一个局部变量都会空出4个字节出来的尿性，这里`this`指针确实应该放在`ebp-14h`的位置。\n\n接着它就开始调用父类构造函数`TestBase`了。这么一来，虚函数表就肯定是在父类中进行赋值了，所以这样的话，父类中调用的`VirtualFunc1`肯定也就是`TestBase`中的`VirtualFunc1`了。这个我就不跟进去看了，那么现在的问题就是，我在子类中重写了虚函数`VirtualFunc1`，那么这个虚函数的地址是怎么写入到虚函数表的呢？继续往下看就知道了。\n\n下面一句`mov dword ptr [ebp-4], 0`这个我还是没有明白是啥意思，忽略它。主要是下面这两句：\n```asm\nmov eax, dword ptr [ebp-14h]\nmov dword ptr [eax], offset HelloWorld2005!TestDerive::`vftable'\n```\n\n看到这里的动作就是修改`this`指向的基地址的值，也就是虚表的地址，我们前面拿到的虚函数表的地址是`00404130`，那我们这里看下它的地址是多少：\n{% asset_img TestDeriveAfterAssignVftable.png 虚函数表的地址 %}\n\n可看到这个地址变成了`0040413c`。那么查看这个地址下的内容：\n{% asset_img TestDeriveVtableContent.png 虚函数表中的内容 %}\n\n我们可以来看下是不是正好就是我们虚函数的地址，利用`x`指令即可：\n{% asset_img TestDeriveVirtualFunctionAddress.png 虚函数地址 %}\n\n居然没有输出`VirtualFunc2`的地址，只能猜测`x`指令只能输出类中实际实现的函数的地址。但是这里我们仍然可以看到`VirtualFunc1`的地址明显变成了`00401460`，正好就是虚函数表中第一个地址。而虚函数表中第二个地址也正好就是父类中`VirtualFunc2`的地址。所以其实有几个点我们就弄清楚了：\n1. 在构造时会先调用父类的构造函数，并且将父类的虚函数表地址传递给`this`指针，所以在父类构造函数中仍然可以调用虚函数，但是调用的只是父类中实现的版本\n2. 在父类构造函数返回后，会将子类中的虚函数表地址传递给`this`指针，也就是会覆盖掉父类的虚函数表地址。所以在此之后，构造函数中调用的虚函数就是子类中的版本了。\n\n接着往下看到两句\n```asm\nmov eax, dword ptr [ebp-14h]    ;获取this指针\nmov ecx, dword ptr [ebp+8]      ;拿到传递给构造函数的参数\nmov dword ptr [eax+14h], ecx    ;执行f的初始化\n```\n\n加上注释之后也就不需要我解释了，大家都明白的。\n\n再往下看，疑惑的地方就来了：\n```asm\nmov eax, dword ptr [ebp-14h]                    ;拿到this指针\ncall HelloWorld2005!TestDerive::VirtualFunc1    ;调用VirtualFunc1\n```\n\n说好的运行时多态呢？为什么好像在编译期直接就给我确定了调用的地址了？老师教的不是说先查找虚函数表，然后再找到对应的虚函数地址么？好像和我以前知道的有一点偏差。但是我现在也不知道为什么，我暂时理解为编译的优化吧。这里留一个疑问，以后看看能不能解决。\n\n这时我们回到`main`函数中继续看那几个函数调用，貌似看起来也都是直接在编译期就决定了函数跳转到哪里了，和普通的函数完全没有区别。是不是被那些将虚函数的书坑了啊？我现在有一点怀疑了。当然不排除怀疑这是微软的特立独行。\n\n算了，我们继续看下面通过成员函数指针进行的调用，首先是三个普通成员函数，它对应的汇编代码是：\n```asm\nlea ecx, [ebp-6Ch]\ncall dword ptr [ebp-14h]\n\nlea ecx, [ebp-8Ch]\ncall dword ptr [ebp-20h]\n\nlea ecx, [ebp-8Ch]\ncall dword ptr [ebp-14h]\n```\n\n可以看到其实对成员函数指针的调用和平时成员函数的调用没有什么区别，只是把`call`的函数名变成了一个地址，`this`指针仍然存放在`ecx`寄存器中。而且我们可以通过`x`指令来查看两个普通函数的地址：\n{% asset_img NormalFunc1Addresses.png NormalFunc1的地址 %}\n\n好像在这一块儿并没有任何歧义，因为知道地址对应的函数之后，都很好理解该跳转到哪里，所以我就不多说什么了。接下来\n\n接着看虚函数，因为之前在前面虚函数地址进行赋值时，看到`TestBase`的虚函数地址和`TestDerive`的虚函数地址居然完全一样，这和我们刚刚用`x`命令看到的不同。好啊吧，闲话少说，首先看第一组，用`base1`调用`baseVirtualFunc1Pointer`和`baseVirtualFunc2Pointer`，对应的汇编代码是：\n```asm\nlea ecx, [ebp-6Ch]\ncall dword ptr [ebp-2Ch]\n\nlea ecx, [ebp-6Ch]\ncall dword ptr [ebp-38h]\n```\n\n在执行`call`语句时用`F11`进入函数内部查看，发现这次调用到的函数不一样了，如下：\n{% asset_img TestBaseVcall0.png 调用虚函数后的结果 %}\n\n但是细看的话，其实很简(sha)单(bi)！！！！！因为它就只做了两个操作：\n1. 获取到this指针指向的第一个值（四字节），而这个值正好就是虚函数表的地址\n2. 然后直接对虚函数表指向的第一个函数地址进行一次跳转(`jmp`)\n\n额。。。。好像这样做确实能够实现调用到正确的虚函数哦。恩，果然是源码之下，了无秘密。只怪我之前怎么没想到呢= =\n\n那其实下面的那些虚函数的调用也就不需要我分析了吧，只是调用`TestVirtualFunc2`的时候，跳转函数里面在虚表的基础上，加了四个字节的偏移。把这里的虚函数调用也理解为做了一个函数的跳转，这个函数跳转中所做的事情就是获取到正确的虚函数地址，而这个虚函数地址的获取依赖于构造对象时，赋值给`this`指针的虚表地址。\n\n那么今天的分析就到这里了，大家好好消化一下吧，如果对本系列有什么改进的建议，欢迎找我提出来(cloudy064@gmail.com)\n\n","slug":"windbg-windbg-chapter4","published":1,"updated":"2018-06-25T11:14:49.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjivnhtp8001p2gusswucmssz","content":"<h2 id=\"内容概要\"><a href=\"#内容概要\" class=\"headerlink\" title=\"内容概要\"></a>内容概要</h2><p>前面一章在探究类的时候，遗留了很多问题，比如参数的构造顺序，虚函数的调用实现等等，那么这一章的就是来填这些坑的。当然这一章不会把这些坑都填完，因为类里面需要讲的东西实在是太多了。那么我先把这一章里面需要既觉得几个问题都罗列出来吧：</p>\n<ol>\n<li>如果我在构造函数中调用虚函数，会执行到正确的（或者说我们所希望的）虚函数么</li>\n<li>构造函数成员初始化的顺序</li>\n<li>在子类中，父类的数据被放在什么地方</li>\n<li>普通成员覆盖和虚函数重写有什么区别</li>\n<li>虚函数重写之后，子类的虚函数表会发生什么变化</li>\n<li>发生继承时，子类是会完全复制父类的虚函数表，还是只会将自己类中的虚函数写入表中</li>\n<li>通过函数指针进行调用和直接调用成员函数有什么区别</li>\n<li>父类能够通过成员函数指针来调用子类的普通成员函数和虚函数么</li>\n<li>子类能够通过成员函数指针来调用父类的普通成员函数和虚函数么<a id=\"more\"></a>\n<h2 id=\"执行哪个函数？运行的时候才知道啊！\"><a href=\"#执行哪个函数？运行的时候才知道啊！\" class=\"headerlink\" title=\"执行哪个函数？运行的时候才知道啊！\"></a>执行哪个函数？运行的时候才知道啊！</h2>本章进行分析的代码内容如下：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestBase()</span><br><span class=\"line\">        : e(<span class=\"number\">12</span>)</span><br><span class=\"line\">        , c(<span class=\"number\">3</span>)</span><br><span class=\"line\">        , a(<span class=\"number\">12</span>)</span><br><span class=\"line\">        , b(<span class=\"number\">1</span>)</span><br><span class=\"line\">        , f(<span class=\"string\">'l'</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        d = <span class=\"number\">19</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        VirtualFunc1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~TestBase()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a = <span class=\"number\">12</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">VirtualFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        a += <span class=\"number\">12</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">VirtualFunc2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        b += <span class=\"number\">22</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NormalFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        c += <span class=\"number\">14</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> e;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> f;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDerive</span> </span></span><br><span class=\"line\"><span class=\"class\">    :</span> <span class=\"keyword\">public</span> TestBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestDerive(<span class=\"keyword\">int</span> a)</span><br><span class=\"line\">        : TestBase()</span><br><span class=\"line\">        , f(a)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        VirtualFunc1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~TestDerive()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        b = <span class=\"number\">12</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">VirtualFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        a += <span class=\"number\">99</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NormalFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        c += <span class=\"number\">54</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestBase::*BaseNormalFuncType)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    BaseNormalFuncType baseNormalFuncPointer = &amp;TestBase::NormalFunc1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestDerive::*DeriveNormalFuncType)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    DeriveNormalFuncType deriveNormalFuncPointer = &amp;TestDerive::NormalFunc1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestBase::*BaseVirtualFunc1Type)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    BaseVirtualFunc1Type baseVirtualFunc1Pointer = &amp;TestBase::VirtualFunc1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestBase::*BaseVirtualFunc2Type)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    BaseVirtualFunc2Type baseVirtualFunc2Pointer = &amp;TestBase::VirtualFunc2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestDerive::*DeriveVirtualFunc1Type)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    DeriveVirtualFunc1Type deriveVirtualFunc1Pointer = &amp;TestDerive::VirtualFunc1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestDerive::*DeriveVirtualFunc2Type)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    DeriveVirtualFunc2Type deriveVirtualFunc2Pointer = &amp;TestDerive::VirtualFunc2;</span><br><span class=\"line\"></span><br><span class=\"line\">    TestBase base1;</span><br><span class=\"line\">    base1.NormalFunc1();</span><br><span class=\"line\">    base1.VirtualFunc1();</span><br><span class=\"line\">    base1.VirtualFunc2();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TestDerive <span class=\"title\">derive1</span><span class=\"params\">(<span class=\"number\">77</span>)</span></span>;</span><br><span class=\"line\">    derive1.NormalFunc1();</span><br><span class=\"line\">    derive1.VirtualFunc1();</span><br><span class=\"line\">    derive1.VirtualFunc2();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    (base1.*baseNormalFuncPointer)();</span><br><span class=\"line\">    (derive1.*deriveNormalFuncPointer)();</span><br><span class=\"line\">    (derive1.*baseNormalFuncPointer)();</span><br><span class=\"line\">    </span><br><span class=\"line\">    (base1.*baseVirtualFunc1Pointer)();</span><br><span class=\"line\">    (base1.*baseVirtualFunc2Pointer)();</span><br><span class=\"line\">    </span><br><span class=\"line\">    (derive1.*baseVirtualFunc1Pointer)();</span><br><span class=\"line\">    (derive1.*baseVirtualFunc2Pointer)();</span><br><span class=\"line\"></span><br><span class=\"line\">    (derive1.*deriveVirtualFunc1Pointer)();</span><br><span class=\"line\">    (derive1.*deriveVirtualFunc2Pointer)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>代码确实越来越长了，但是其实分析的内容不是特别多，那么就照旧，打开windbg一步一步来分析代码吧。</p>\n<p>跳过初始化的部分，我们来到第一句代码，诶，为什么<code>typedef void (TestBase::*BaseNormalFuncType)()</code>没有执行啊喂，第一句代码直接运行赋值操作了？<br><img src=\"/2016/04/26/windbg-windbg-chapter4/AssignMemberFuncPointer.png\" title=\"第一句代码\"></p>\n<p>恩，其实我也不知道，而且我google也没有找到答案，咱忽略这个问题好不好？</p>\n<p>那么看下面六个函数指针的赋值吧，前面两个没话说，和普通的函数地址一样，因为经过上一章的研究，其实<code>this</code>指针并不是类内部或者函数内部的，而是函数调用时外部通过<code>ecx</code>寄存器传递给函数的一个隐式参数。（当然如果你想知道函数的地址是怎么得到的，可以等我开一个讲编译器的新坑）那么这里我们主要需要看的是最后四个虚函数的指针的赋值。可以看到它的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-2Ch], offset HelloWorld2005!TestBase::`vcall&apos;&#123;0&#125;&apos;</span><br><span class=\"line\">mov dword ptr [ebp-38h], offset HelloWorld2005!TestBase::`vcall&apos;&#123;4&#125;&apos;</span><br><span class=\"line\">mov dword ptr [ebp-44h], offset HelloWorld2005!TestBase::`vcall&apos;&#123;0&#125;&apos;</span><br><span class=\"line\">mov dword ptr [ebp-50h], offset HelloWorld2005!TestBase::`vcall&apos;&#123;4&#125;&apos;</span><br></pre></td></tr></table></figure></p>\n<p>不对啊喂，我后面两个明明是取的<code>TestDerive</code>中的虚函数，为什么在汇编代码中还是给我<code>TestBase</code>中虚函数的地址啊？好吧，我暂时也无法给你解答，把所有的疑问全部都放一放，然后继续研究吧。</p>\n<p>然后我们开始定义第一个类变量：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/FirstClassVariable.png\" title=\"定义TestBase变量\"></p>\n<p>我们进入到构造函数内部看下吧（这里<code>this</code>指针的值为`0019febc）：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseConstructor.png\" title=\"TestBase的构造函数\"></p>\n<p>还记得下面构造函数会做哪些事情吗？</p>\n<ol>\n<li>将<code>this</code>指针放到<code>ebp-8</code>的位置</li>\n<li>将<code>ebp-8</code>位置的值放到<code>eax</code>中</li>\n<li>如果有虚函数，下面就会把虚函数表的地址放到<code>this</code>指针指向的第一个地址</li>\n</ol>\n<p>这一章里面主要研究虚函数表，之所以叫虚函数表，我想应该就是一张表里面有很多的<code>entry</code>，然后每个<code>entry</code>指向了一个对应的虚函数地址吧，好吧这都是我意淫出来的。所以，我们首先用<code>x</code>指令来查看<code>TestBase</code>中所有虚函数的地址是多少：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseVirtualFunctionsAddress.png\" title=\"TestBase中的虚函数\"></p>\n<p>然后我们用<code>dd eax</code>来查看<code>this</code>指针指向的内存：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseLookupThis.png\" title=\"this指针指向的内存\"></p>\n<p>第一个4字节的值<code>00404130</code>就是虚函数表的地址，我们再用<code>dd 00404130</code>查看这个地址下是不是存放了上面两个虚函数的地址：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseContentOfVirtualTable.png\" title=\"TestBase虚函数表的内容\"></p>\n<p>这不是演习，果然后面一个一个存放着虚函数的指针，暂且认为它们是按照声明的顺序来存放的吧，毕竟其实这个顺序如果你不是想<code>hack</code>的话，对于我们来说没什么意义。所以从汇编的层面来看的话，虚函数表其实没啥神奇的。</p>\n<p>好吧，那么我们继续往下面看，需要注意的是，我这里把成员变量声明的顺序和类初始化器的顺序安排成不一致，那么现在我们需要一边看一边关注是在为哪个变量赋值。或者。。。。。我们不妨用<code>dt</code>看下<code>TestBase</code>的内存结构吧：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/dtTestBase.png\" title=\"TestBase的内存结构\"></p>\n<p>额，内存结构里面的内存对齐我觉得可以自己分析，我这里就不多说了。然后就是对照着目标地址和内存结构进行对应了：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseInitSequence.png\" title=\"TestBase成员变量初始化顺序\"></p>\n<p>诶，好像和我在初始化器里面摆放的顺序不一样，完全就是和成员变量声明的顺序是一致的，当然除了最后一个在函数体中进行的一次赋值。这样的话概要中的第二个问题就已经解决了。</p>\n<p>接着下面调用了一个虚函数<code>VirtualFunc1</code>，进去看了下好像和我们以前调用的普通函数没有什么区别，那我们就直接跳过吧：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseVirtualFunc2Function.png\" title=\"VirtualFunc1的汇编实现\"></p>\n<p>然后我们跳过函数的调用，等下一起看，直接来看下<code>TestDerive</code>对象的定义，进去它的构造函数看下汇编实现（此时<code>this</code>指针的值是<code>0019fe9c</code>）：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestDeriveConstructor.png\" title=\"TestDerive的构造函数\"></p>\n<p>在看调用父类构造函数之前，我们继续用<code>dt</code>来看下<code>TestDerive</code>的内存结构：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/dtTestDerive.png\" title=\"TestDerive的内存结构\"></p>\n<p>可以看出，<code>TestDerive</code>是把父类的内存结构拷贝过来（而不是在开始的位置放一个<code>TestBase</code>），然后在最后加上一个<code>TestDerive</code>中定义的变量<code>f</code>，而虚函数表指针也只有一个。根据之前的经验，类会先初始化虚函数表，在进行成员变量的初始化，然而在往下看的过程中，可以看到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-14h], ecx</span><br><span class=\"line\">mov ecx, dword ptr [ebp-14h]</span><br><span class=\"line\">call HelloWorld2005!TestBase::TestBase</span><br></pre></td></tr></table></figure></p>\n<p>尼玛，为什么这里<code>this</code>指针就存放在了<code>ebp-14h</code>这个位置上，之前都是放在<code>ebp-8</code>的位置的。哎，我觉得我又要画一个此时堆栈的内存图了：<br></p>\n<p>= =，为什么这个构造函数里面又多了这么多东西？说好的只需要初始化堆栈区域呢？至于为什么会多出这么多东西，我暂时也不知道，所以无法给大家解答。那这样的话，加上第一个局部变量都会空出4个字节出来的尿性，这里<code>this</code>指针确实应该放在<code>ebp-14h</code>的位置。</p>\n<p>接着它就开始调用父类构造函数<code>TestBase</code>了。这么一来，虚函数表就肯定是在父类中进行赋值了，所以这样的话，父类中调用的<code>VirtualFunc1</code>肯定也就是<code>TestBase</code>中的<code>VirtualFunc1</code>了。这个我就不跟进去看了，那么现在的问题就是，我在子类中重写了虚函数<code>VirtualFunc1</code>，那么这个虚函数的地址是怎么写入到虚函数表的呢？继续往下看就知道了。</p>\n<p>下面一句<code>mov dword ptr [ebp-4], 0</code>这个我还是没有明白是啥意思，忽略它。主要是下面这两句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-14h]</span><br><span class=\"line\">mov dword ptr [eax], offset HelloWorld2005!TestDerive::`vftable&apos;</span><br></pre></td></tr></table></figure></p>\n<p>看到这里的动作就是修改<code>this</code>指向的基地址的值，也就是虚表的地址，我们前面拿到的虚函数表的地址是<code>00404130</code>，那我们这里看下它的地址是多少：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestDeriveAfterAssignVftable.png\" title=\"虚函数表的地址\"></p>\n<p>可看到这个地址变成了<code>0040413c</code>。那么查看这个地址下的内容：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestDeriveVtableContent.png\" title=\"虚函数表中的内容\"></p>\n<p>我们可以来看下是不是正好就是我们虚函数的地址，利用<code>x</code>指令即可：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestDeriveVirtualFunctionAddress.png\" title=\"虚函数地址\"></p>\n<p>居然没有输出<code>VirtualFunc2</code>的地址，只能猜测<code>x</code>指令只能输出类中实际实现的函数的地址。但是这里我们仍然可以看到<code>VirtualFunc1</code>的地址明显变成了<code>00401460</code>，正好就是虚函数表中第一个地址。而虚函数表中第二个地址也正好就是父类中<code>VirtualFunc2</code>的地址。所以其实有几个点我们就弄清楚了：</p>\n<ol>\n<li>在构造时会先调用父类的构造函数，并且将父类的虚函数表地址传递给<code>this</code>指针，所以在父类构造函数中仍然可以调用虚函数，但是调用的只是父类中实现的版本</li>\n<li>在父类构造函数返回后，会将子类中的虚函数表地址传递给<code>this</code>指针，也就是会覆盖掉父类的虚函数表地址。所以在此之后，构造函数中调用的虚函数就是子类中的版本了。</li>\n</ol>\n<p>接着往下看到两句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-14h]    ;获取this指针</span><br><span class=\"line\">mov ecx, dword ptr [ebp+8]      ;拿到传递给构造函数的参数</span><br><span class=\"line\">mov dword ptr [eax+14h], ecx    ;执行f的初始化</span><br></pre></td></tr></table></figure></p>\n<p>加上注释之后也就不需要我解释了，大家都明白的。</p>\n<p>再往下看，疑惑的地方就来了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-14h]                    ;拿到this指针</span><br><span class=\"line\">call HelloWorld2005!TestDerive::VirtualFunc1    ;调用VirtualFunc1</span><br></pre></td></tr></table></figure></p>\n<p>说好的运行时多态呢？为什么好像在编译期直接就给我确定了调用的地址了？老师教的不是说先查找虚函数表，然后再找到对应的虚函数地址么？好像和我以前知道的有一点偏差。但是我现在也不知道为什么，我暂时理解为编译的优化吧。这里留一个疑问，以后看看能不能解决。</p>\n<p>这时我们回到<code>main</code>函数中继续看那几个函数调用，貌似看起来也都是直接在编译期就决定了函数跳转到哪里了，和普通的函数完全没有区别。是不是被那些将虚函数的书坑了啊？我现在有一点怀疑了。当然不排除怀疑这是微软的特立独行。</p>\n<p>算了，我们继续看下面通过成员函数指针进行的调用，首先是三个普通成员函数，它对应的汇编代码是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea ecx, [ebp-6Ch]</span><br><span class=\"line\">call dword ptr [ebp-14h]</span><br><span class=\"line\"></span><br><span class=\"line\">lea ecx, [ebp-8Ch]</span><br><span class=\"line\">call dword ptr [ebp-20h]</span><br><span class=\"line\"></span><br><span class=\"line\">lea ecx, [ebp-8Ch]</span><br><span class=\"line\">call dword ptr [ebp-14h]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到其实对成员函数指针的调用和平时成员函数的调用没有什么区别，只是把<code>call</code>的函数名变成了一个地址，<code>this</code>指针仍然存放在<code>ecx</code>寄存器中。而且我们可以通过<code>x</code>指令来查看两个普通函数的地址：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/NormalFunc1Addresses.png\" title=\"NormalFunc1的地址\"></p>\n<p>好像在这一块儿并没有任何歧义，因为知道地址对应的函数之后，都很好理解该跳转到哪里，所以我就不多说什么了。接下来</p>\n<p>接着看虚函数，因为之前在前面虚函数地址进行赋值时，看到<code>TestBase</code>的虚函数地址和<code>TestDerive</code>的虚函数地址居然完全一样，这和我们刚刚用<code>x</code>命令看到的不同。好啊吧，闲话少说，首先看第一组，用<code>base1</code>调用<code>baseVirtualFunc1Pointer</code>和<code>baseVirtualFunc2Pointer</code>，对应的汇编代码是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea ecx, [ebp-6Ch]</span><br><span class=\"line\">call dword ptr [ebp-2Ch]</span><br><span class=\"line\"></span><br><span class=\"line\">lea ecx, [ebp-6Ch]</span><br><span class=\"line\">call dword ptr [ebp-38h]</span><br></pre></td></tr></table></figure></p>\n<p>在执行<code>call</code>语句时用<code>F11</code>进入函数内部查看，发现这次调用到的函数不一样了，如下：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseVcall0.png\" title=\"调用虚函数后的结果\"></p>\n<p>但是细看的话，其实很简(sha)单(bi)！！！！！因为它就只做了两个操作：</p>\n<ol>\n<li>获取到this指针指向的第一个值（四字节），而这个值正好就是虚函数表的地址</li>\n<li>然后直接对虚函数表指向的第一个函数地址进行一次跳转(<code>jmp</code>)</li>\n</ol>\n<p>额。。。。好像这样做确实能够实现调用到正确的虚函数哦。恩，果然是源码之下，了无秘密。只怪我之前怎么没想到呢= =</p>\n<p>那其实下面的那些虚函数的调用也就不需要我分析了吧，只是调用<code>TestVirtualFunc2</code>的时候，跳转函数里面在虚表的基础上，加了四个字节的偏移。把这里的虚函数调用也理解为做了一个函数的跳转，这个函数跳转中所做的事情就是获取到正确的虚函数地址，而这个虚函数地址的获取依赖于构造对象时，赋值给<code>this</code>指针的虚表地址。</p>\n<p>那么今天的分析就到这里了，大家好好消化一下吧，如果对本系列有什么改进的建议，欢迎找我提出来(<a href=\"mailto:cloudy064@gmail.com\" target=\"_blank\" rel=\"noopener\">cloudy064@gmail.com</a>)</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"内容概要\"><a href=\"#内容概要\" class=\"headerlink\" title=\"内容概要\"></a>内容概要</h2><p>前面一章在探究类的时候，遗留了很多问题，比如参数的构造顺序，虚函数的调用实现等等，那么这一章的就是来填这些坑的。当然这一章不会把这些坑都填完，因为类里面需要讲的东西实在是太多了。那么我先把这一章里面需要既觉得几个问题都罗列出来吧：</p>\n<ol>\n<li>如果我在构造函数中调用虚函数，会执行到正确的（或者说我们所希望的）虚函数么</li>\n<li>构造函数成员初始化的顺序</li>\n<li>在子类中，父类的数据被放在什么地方</li>\n<li>普通成员覆盖和虚函数重写有什么区别</li>\n<li>虚函数重写之后，子类的虚函数表会发生什么变化</li>\n<li>发生继承时，子类是会完全复制父类的虚函数表，还是只会将自己类中的虚函数写入表中</li>\n<li>通过函数指针进行调用和直接调用成员函数有什么区别</li>\n<li>父类能够通过成员函数指针来调用子类的普通成员函数和虚函数么</li>\n<li>子类能够通过成员函数指针来调用父类的普通成员函数和虚函数么","more":"<h2 id=\"执行哪个函数？运行的时候才知道啊！\"><a href=\"#执行哪个函数？运行的时候才知道啊！\" class=\"headerlink\" title=\"执行哪个函数？运行的时候才知道啊！\"></a>执行哪个函数？运行的时候才知道啊！</h2>本章进行分析的代码内容如下：<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestBase()</span><br><span class=\"line\">        : e(<span class=\"number\">12</span>)</span><br><span class=\"line\">        , c(<span class=\"number\">3</span>)</span><br><span class=\"line\">        , a(<span class=\"number\">12</span>)</span><br><span class=\"line\">        , b(<span class=\"number\">1</span>)</span><br><span class=\"line\">        , f(<span class=\"string\">'l'</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        d = <span class=\"number\">19</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        VirtualFunc1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~TestBase()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a = <span class=\"number\">12</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">VirtualFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        a += <span class=\"number\">12</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">VirtualFunc2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        b += <span class=\"number\">22</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NormalFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        c += <span class=\"number\">14</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> e;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> f;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDerive</span> </span></span><br><span class=\"line\"><span class=\"class\">    :</span> <span class=\"keyword\">public</span> TestBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestDerive(<span class=\"keyword\">int</span> a)</span><br><span class=\"line\">        : TestBase()</span><br><span class=\"line\">        , f(a)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        VirtualFunc1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~TestDerive()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        b = <span class=\"number\">12</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">VirtualFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        a += <span class=\"number\">99</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">NormalFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        c += <span class=\"number\">54</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestBase::*BaseNormalFuncType)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    BaseNormalFuncType baseNormalFuncPointer = &amp;TestBase::NormalFunc1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestDerive::*DeriveNormalFuncType)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    DeriveNormalFuncType deriveNormalFuncPointer = &amp;TestDerive::NormalFunc1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestBase::*BaseVirtualFunc1Type)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    BaseVirtualFunc1Type baseVirtualFunc1Pointer = &amp;TestBase::VirtualFunc1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestBase::*BaseVirtualFunc2Type)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    BaseVirtualFunc2Type baseVirtualFunc2Pointer = &amp;TestBase::VirtualFunc2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestDerive::*DeriveVirtualFunc1Type)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    DeriveVirtualFunc1Type deriveVirtualFunc1Pointer = &amp;TestDerive::VirtualFunc1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(TestDerive::*DeriveVirtualFunc2Type)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    DeriveVirtualFunc2Type deriveVirtualFunc2Pointer = &amp;TestDerive::VirtualFunc2;</span><br><span class=\"line\"></span><br><span class=\"line\">    TestBase base1;</span><br><span class=\"line\">    base1.NormalFunc1();</span><br><span class=\"line\">    base1.VirtualFunc1();</span><br><span class=\"line\">    base1.VirtualFunc2();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TestDerive <span class=\"title\">derive1</span><span class=\"params\">(<span class=\"number\">77</span>)</span></span>;</span><br><span class=\"line\">    derive1.NormalFunc1();</span><br><span class=\"line\">    derive1.VirtualFunc1();</span><br><span class=\"line\">    derive1.VirtualFunc2();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    (base1.*baseNormalFuncPointer)();</span><br><span class=\"line\">    (derive1.*deriveNormalFuncPointer)();</span><br><span class=\"line\">    (derive1.*baseNormalFuncPointer)();</span><br><span class=\"line\">    </span><br><span class=\"line\">    (base1.*baseVirtualFunc1Pointer)();</span><br><span class=\"line\">    (base1.*baseVirtualFunc2Pointer)();</span><br><span class=\"line\">    </span><br><span class=\"line\">    (derive1.*baseVirtualFunc1Pointer)();</span><br><span class=\"line\">    (derive1.*baseVirtualFunc2Pointer)();</span><br><span class=\"line\"></span><br><span class=\"line\">    (derive1.*deriveVirtualFunc1Pointer)();</span><br><span class=\"line\">    (derive1.*deriveVirtualFunc2Pointer)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>代码确实越来越长了，但是其实分析的内容不是特别多，那么就照旧，打开windbg一步一步来分析代码吧。</p>\n<p>跳过初始化的部分，我们来到第一句代码，诶，为什么<code>typedef void (TestBase::*BaseNormalFuncType)()</code>没有执行啊喂，第一句代码直接运行赋值操作了？<br><img src=\"/2016/04/26/windbg-windbg-chapter4/AssignMemberFuncPointer.png\" title=\"第一句代码\"></p>\n<p>恩，其实我也不知道，而且我google也没有找到答案，咱忽略这个问题好不好？</p>\n<p>那么看下面六个函数指针的赋值吧，前面两个没话说，和普通的函数地址一样，因为经过上一章的研究，其实<code>this</code>指针并不是类内部或者函数内部的，而是函数调用时外部通过<code>ecx</code>寄存器传递给函数的一个隐式参数。（当然如果你想知道函数的地址是怎么得到的，可以等我开一个讲编译器的新坑）那么这里我们主要需要看的是最后四个虚函数的指针的赋值。可以看到它的代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-2Ch], offset HelloWorld2005!TestBase::`vcall&apos;&#123;0&#125;&apos;</span><br><span class=\"line\">mov dword ptr [ebp-38h], offset HelloWorld2005!TestBase::`vcall&apos;&#123;4&#125;&apos;</span><br><span class=\"line\">mov dword ptr [ebp-44h], offset HelloWorld2005!TestBase::`vcall&apos;&#123;0&#125;&apos;</span><br><span class=\"line\">mov dword ptr [ebp-50h], offset HelloWorld2005!TestBase::`vcall&apos;&#123;4&#125;&apos;</span><br></pre></td></tr></table></figure></p>\n<p>不对啊喂，我后面两个明明是取的<code>TestDerive</code>中的虚函数，为什么在汇编代码中还是给我<code>TestBase</code>中虚函数的地址啊？好吧，我暂时也无法给你解答，把所有的疑问全部都放一放，然后继续研究吧。</p>\n<p>然后我们开始定义第一个类变量：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/FirstClassVariable.png\" title=\"定义TestBase变量\"></p>\n<p>我们进入到构造函数内部看下吧（这里<code>this</code>指针的值为`0019febc）：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseConstructor.png\" title=\"TestBase的构造函数\"></p>\n<p>还记得下面构造函数会做哪些事情吗？</p>\n<ol>\n<li>将<code>this</code>指针放到<code>ebp-8</code>的位置</li>\n<li>将<code>ebp-8</code>位置的值放到<code>eax</code>中</li>\n<li>如果有虚函数，下面就会把虚函数表的地址放到<code>this</code>指针指向的第一个地址</li>\n</ol>\n<p>这一章里面主要研究虚函数表，之所以叫虚函数表，我想应该就是一张表里面有很多的<code>entry</code>，然后每个<code>entry</code>指向了一个对应的虚函数地址吧，好吧这都是我意淫出来的。所以，我们首先用<code>x</code>指令来查看<code>TestBase</code>中所有虚函数的地址是多少：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseVirtualFunctionsAddress.png\" title=\"TestBase中的虚函数\"></p>\n<p>然后我们用<code>dd eax</code>来查看<code>this</code>指针指向的内存：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseLookupThis.png\" title=\"this指针指向的内存\"></p>\n<p>第一个4字节的值<code>00404130</code>就是虚函数表的地址，我们再用<code>dd 00404130</code>查看这个地址下是不是存放了上面两个虚函数的地址：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseContentOfVirtualTable.png\" title=\"TestBase虚函数表的内容\"></p>\n<p>这不是演习，果然后面一个一个存放着虚函数的指针，暂且认为它们是按照声明的顺序来存放的吧，毕竟其实这个顺序如果你不是想<code>hack</code>的话，对于我们来说没什么意义。所以从汇编的层面来看的话，虚函数表其实没啥神奇的。</p>\n<p>好吧，那么我们继续往下面看，需要注意的是，我这里把成员变量声明的顺序和类初始化器的顺序安排成不一致，那么现在我们需要一边看一边关注是在为哪个变量赋值。或者。。。。。我们不妨用<code>dt</code>看下<code>TestBase</code>的内存结构吧：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/dtTestBase.png\" title=\"TestBase的内存结构\"></p>\n<p>额，内存结构里面的内存对齐我觉得可以自己分析，我这里就不多说了。然后就是对照着目标地址和内存结构进行对应了：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseInitSequence.png\" title=\"TestBase成员变量初始化顺序\"></p>\n<p>诶，好像和我在初始化器里面摆放的顺序不一样，完全就是和成员变量声明的顺序是一致的，当然除了最后一个在函数体中进行的一次赋值。这样的话概要中的第二个问题就已经解决了。</p>\n<p>接着下面调用了一个虚函数<code>VirtualFunc1</code>，进去看了下好像和我们以前调用的普通函数没有什么区别，那我们就直接跳过吧：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseVirtualFunc2Function.png\" title=\"VirtualFunc1的汇编实现\"></p>\n<p>然后我们跳过函数的调用，等下一起看，直接来看下<code>TestDerive</code>对象的定义，进去它的构造函数看下汇编实现（此时<code>this</code>指针的值是<code>0019fe9c</code>）：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestDeriveConstructor.png\" title=\"TestDerive的构造函数\"></p>\n<p>在看调用父类构造函数之前，我们继续用<code>dt</code>来看下<code>TestDerive</code>的内存结构：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/dtTestDerive.png\" title=\"TestDerive的内存结构\"></p>\n<p>可以看出，<code>TestDerive</code>是把父类的内存结构拷贝过来（而不是在开始的位置放一个<code>TestBase</code>），然后在最后加上一个<code>TestDerive</code>中定义的变量<code>f</code>，而虚函数表指针也只有一个。根据之前的经验，类会先初始化虚函数表，在进行成员变量的初始化，然而在往下看的过程中，可以看到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-14h], ecx</span><br><span class=\"line\">mov ecx, dword ptr [ebp-14h]</span><br><span class=\"line\">call HelloWorld2005!TestBase::TestBase</span><br></pre></td></tr></table></figure></p>\n<p>尼玛，为什么这里<code>this</code>指针就存放在了<code>ebp-14h</code>这个位置上，之前都是放在<code>ebp-8</code>的位置的。哎，我觉得我又要画一个此时堆栈的内存图了：<br></p>\n<p>= =，为什么这个构造函数里面又多了这么多东西？说好的只需要初始化堆栈区域呢？至于为什么会多出这么多东西，我暂时也不知道，所以无法给大家解答。那这样的话，加上第一个局部变量都会空出4个字节出来的尿性，这里<code>this</code>指针确实应该放在<code>ebp-14h</code>的位置。</p>\n<p>接着它就开始调用父类构造函数<code>TestBase</code>了。这么一来，虚函数表就肯定是在父类中进行赋值了，所以这样的话，父类中调用的<code>VirtualFunc1</code>肯定也就是<code>TestBase</code>中的<code>VirtualFunc1</code>了。这个我就不跟进去看了，那么现在的问题就是，我在子类中重写了虚函数<code>VirtualFunc1</code>，那么这个虚函数的地址是怎么写入到虚函数表的呢？继续往下看就知道了。</p>\n<p>下面一句<code>mov dword ptr [ebp-4], 0</code>这个我还是没有明白是啥意思，忽略它。主要是下面这两句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-14h]</span><br><span class=\"line\">mov dword ptr [eax], offset HelloWorld2005!TestDerive::`vftable&apos;</span><br></pre></td></tr></table></figure></p>\n<p>看到这里的动作就是修改<code>this</code>指向的基地址的值，也就是虚表的地址，我们前面拿到的虚函数表的地址是<code>00404130</code>，那我们这里看下它的地址是多少：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestDeriveAfterAssignVftable.png\" title=\"虚函数表的地址\"></p>\n<p>可看到这个地址变成了<code>0040413c</code>。那么查看这个地址下的内容：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestDeriveVtableContent.png\" title=\"虚函数表中的内容\"></p>\n<p>我们可以来看下是不是正好就是我们虚函数的地址，利用<code>x</code>指令即可：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestDeriveVirtualFunctionAddress.png\" title=\"虚函数地址\"></p>\n<p>居然没有输出<code>VirtualFunc2</code>的地址，只能猜测<code>x</code>指令只能输出类中实际实现的函数的地址。但是这里我们仍然可以看到<code>VirtualFunc1</code>的地址明显变成了<code>00401460</code>，正好就是虚函数表中第一个地址。而虚函数表中第二个地址也正好就是父类中<code>VirtualFunc2</code>的地址。所以其实有几个点我们就弄清楚了：</p>\n<ol>\n<li>在构造时会先调用父类的构造函数，并且将父类的虚函数表地址传递给<code>this</code>指针，所以在父类构造函数中仍然可以调用虚函数，但是调用的只是父类中实现的版本</li>\n<li>在父类构造函数返回后，会将子类中的虚函数表地址传递给<code>this</code>指针，也就是会覆盖掉父类的虚函数表地址。所以在此之后，构造函数中调用的虚函数就是子类中的版本了。</li>\n</ol>\n<p>接着往下看到两句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-14h]    ;获取this指针</span><br><span class=\"line\">mov ecx, dword ptr [ebp+8]      ;拿到传递给构造函数的参数</span><br><span class=\"line\">mov dword ptr [eax+14h], ecx    ;执行f的初始化</span><br></pre></td></tr></table></figure></p>\n<p>加上注释之后也就不需要我解释了，大家都明白的。</p>\n<p>再往下看，疑惑的地方就来了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-14h]                    ;拿到this指针</span><br><span class=\"line\">call HelloWorld2005!TestDerive::VirtualFunc1    ;调用VirtualFunc1</span><br></pre></td></tr></table></figure></p>\n<p>说好的运行时多态呢？为什么好像在编译期直接就给我确定了调用的地址了？老师教的不是说先查找虚函数表，然后再找到对应的虚函数地址么？好像和我以前知道的有一点偏差。但是我现在也不知道为什么，我暂时理解为编译的优化吧。这里留一个疑问，以后看看能不能解决。</p>\n<p>这时我们回到<code>main</code>函数中继续看那几个函数调用，貌似看起来也都是直接在编译期就决定了函数跳转到哪里了，和普通的函数完全没有区别。是不是被那些将虚函数的书坑了啊？我现在有一点怀疑了。当然不排除怀疑这是微软的特立独行。</p>\n<p>算了，我们继续看下面通过成员函数指针进行的调用，首先是三个普通成员函数，它对应的汇编代码是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea ecx, [ebp-6Ch]</span><br><span class=\"line\">call dword ptr [ebp-14h]</span><br><span class=\"line\"></span><br><span class=\"line\">lea ecx, [ebp-8Ch]</span><br><span class=\"line\">call dword ptr [ebp-20h]</span><br><span class=\"line\"></span><br><span class=\"line\">lea ecx, [ebp-8Ch]</span><br><span class=\"line\">call dword ptr [ebp-14h]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到其实对成员函数指针的调用和平时成员函数的调用没有什么区别，只是把<code>call</code>的函数名变成了一个地址，<code>this</code>指针仍然存放在<code>ecx</code>寄存器中。而且我们可以通过<code>x</code>指令来查看两个普通函数的地址：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/NormalFunc1Addresses.png\" title=\"NormalFunc1的地址\"></p>\n<p>好像在这一块儿并没有任何歧义，因为知道地址对应的函数之后，都很好理解该跳转到哪里，所以我就不多说什么了。接下来</p>\n<p>接着看虚函数，因为之前在前面虚函数地址进行赋值时，看到<code>TestBase</code>的虚函数地址和<code>TestDerive</code>的虚函数地址居然完全一样，这和我们刚刚用<code>x</code>命令看到的不同。好啊吧，闲话少说，首先看第一组，用<code>base1</code>调用<code>baseVirtualFunc1Pointer</code>和<code>baseVirtualFunc2Pointer</code>，对应的汇编代码是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea ecx, [ebp-6Ch]</span><br><span class=\"line\">call dword ptr [ebp-2Ch]</span><br><span class=\"line\"></span><br><span class=\"line\">lea ecx, [ebp-6Ch]</span><br><span class=\"line\">call dword ptr [ebp-38h]</span><br></pre></td></tr></table></figure></p>\n<p>在执行<code>call</code>语句时用<code>F11</code>进入函数内部查看，发现这次调用到的函数不一样了，如下：<br><img src=\"/2016/04/26/windbg-windbg-chapter4/TestBaseVcall0.png\" title=\"调用虚函数后的结果\"></p>\n<p>但是细看的话，其实很简(sha)单(bi)！！！！！因为它就只做了两个操作：</p>\n<ol>\n<li>获取到this指针指向的第一个值（四字节），而这个值正好就是虚函数表的地址</li>\n<li>然后直接对虚函数表指向的第一个函数地址进行一次跳转(<code>jmp</code>)</li>\n</ol>\n<p>额。。。。好像这样做确实能够实现调用到正确的虚函数哦。恩，果然是源码之下，了无秘密。只怪我之前怎么没想到呢= =</p>\n<p>那其实下面的那些虚函数的调用也就不需要我分析了吧，只是调用<code>TestVirtualFunc2</code>的时候，跳转函数里面在虚表的基础上，加了四个字节的偏移。把这里的虚函数调用也理解为做了一个函数的跳转，这个函数跳转中所做的事情就是获取到正确的虚函数地址，而这个虚函数地址的获取依赖于构造对象时，赋值给<code>this</code>指针的虚表地址。</p>\n<p>那么今天的分析就到这里了，大家好好消化一下吧，如果对本系列有什么改进的建议，欢迎找我提出来(<a href=\"mailto:cloudy064@gmail.com\" target=\"_blank\" rel=\"noopener\">cloudy064@gmail.com</a>)</p>"},{"title":"WinDBG观世界（五）","date":"2016-06-15T15:34:06.000Z","_content":"\n## 导言\nすみません，好久没有更新博客了，因为我觉得越写要写的东西越多，这真的是个大坑，而且我还只挑了`C++99`的相关特性，`C++11`那个真心不敢讲。而且用`hexo`写东西真的有点蛋疼，尤其是截图，简直是煎熬啊。好了闲话不多说了，我们这次要看的东西不多，我们只看虚继承的内容，怕同学们消化不良啊，多重继承的知识放到下一部分讲解。\n<!--more-->\n## 诶？我父亲呢？\n国际惯例，看看今天要解读的代码吧：\n```cpp\nclass Super\n{\npublic:\n    ~Super()\n    {\n\n    }\n\npublic:\n    int NormalFunc1()\n    {\n        return a;\n    }\n\n    virtual int VirtualFunc1()\n    {\n        return a + c;\n    }\n\nprotected:\n    int a;\n    int c;\n};\n\nclass Derive\n    : virtual public Super\n{\npublic:\n    Derive()\n        : a(10)\n        , b(12)\n    {\n        Super::a = 19;\n    }\n\n    ~Derive()\n    {\n\n    }\n\npublic:\n    virtual int VirtualFunc1() override\n    {\n        return Super::a + a + c + b;\n    }\n\nprivate:\n    int a;\n    int b;\n};\n\nint main(int argc, char** argv)\n{\n    Derive d;\n    d.VirtualFunc1();\n    d.NormalFunc1();\n}\n\n```\n\n这里大家带着下面几个问题来听我说吧：\n1. `Derive`的内存分布是怎么样的？`Super`放在什么位置？\n2. `Derive`对象是如何找到父类的虚函数和成员函数的\n3. `Derive`内部是如何传递`this`指针给父类的\n\n如何？没骗你们吧，内容真的不多哦！（不许说我越来越短了！）好了，打开你的`windbg`，把这个`exe`跑起来吧！对了，在此之前为了不让`Visual Studio`生成多余的代码，所以我修改了一些编译选项，包括增量式编译、c++异常检测、堆栈检测等等，设置如下：\n{% asset_img vsoptions.png VS设置1 %}\n{% asset_img linkoptions.png VS设置2 %}\n\n那么下面我们就单步调试到第一行代码对应的汇编码吧：\n{% asset_img firststep.png 第一行代码 %}\n\n第一句话是`push 1`，这个其实以前也遇到过，但是我没有说明是啥，因为我也没有仔细研究过，这里我只是怀疑可能是堆栈上对象的个数。这个坑留着以后填吧。\n\n之后的两句话\n```asm\nlea ecx, [ebp-1Ch]\ncall HelloWorld2005!Derive::Derive\n```\n\n很明显第一句就是在当前堆栈上计算出`d`对象的地址，然后将这个地址当做`this`指针的值传递给构造函数。我们先把当前的堆栈用一个图画出来吧：\n{% asset_img beforedconstructorstack.png 当前堆栈的样子 %}\n\n其中黄色区域是运行时栈上的内容，粉红色区域就是局部变量区域分配给`d`对象的栈上内存（当然那也可能有浪费的，我们前面也了解到了`VS`的尿性）。不过至少能够知道`d`对象的`this`指针是`ebp-1Ch`。那我们`F11`进去函数里面看下吧，我们可以一直走到`this`指针保存到`dword ptr [ebp-4]`的地方：\n{% asset_img inderiveconstructor.png 开始运行Derive构造函数 %}\n\n现在堆栈的图如下：\n{% asset_img inderiveconstructorstack.png 当前的堆栈情况 %}\n\n下面几句就是从来没有见过的了，因为我们知道，构造函数都是先构造父类，然后再构造自己的。所以这里用脚趾头想想应该也知道肯定是准备数据初始化父类的，当然只是猜想哈。来看下面几句：\n```asm\nmov dword ptr [ebp-48h], 0\ncmp dword ptr [ebp+8], 0\nje HelloWorld2005!Derive::Derive+0x31\nmov eax, dword ptr [ebp-4]\nmov dword ptr [eax], offset HelloWorld2005!Derive::`vbtable'\nmov ecx, dword ptr [ebp-4]\nadd ecx, 10h\ncall HelloWorld2005!Super::Super\n```\n\n不要惊讶为什么一下子要看这么多代码，因为我抄到这里才看到熟悉的父类构造函数。前面第一句我真TM不知道是干嘛用的，我真的想一句一句讲，我们忽略它好不好。第二句，要知道`ebp+8`指向的内容就是我刚刚猜测是堆栈上对象个数的值，看上面的图就知道，就是`1`，这里和0进行比，如果等于`0`，就跳转到`Derive::Derive+0x31`的位置。意义何在啊？当然你可以用`u HelloWorld2005+Derive::Derive+0x31`指令去看下这个地方的汇编代码。可以看出来，这句话的作用其实是跳过了父类构造函数的调用，如下所示：\n{% asset_img jumpoversupercall.png 跳过了父类构造函数 %}\n\n那么应该存在某种情况，我们调用构造函数不会调用父类构造函数，但是我也不知道什么时候会发生这种情况。那么我们继续往下看：\n```asm\nmov eax, dword ptr [ebp-4]\nmov dword ptr [eax], offset HelloWorld2005!Derive::`vbtable'\n```\n\n要知道`ebp-4`的地方保存的是`this`指针，而它拿到`this`指针之后就把一个`vbtable`赋值给了`this`指针指向的起始地址。同学们（装腔作势样），你们还记得前面介绍虚函数的时候有一个`vftable`么，应该不难猜出这个地方的`vbtable`应该就是`virtual base table`的意思吧（我自己翻译的，官方翻译我没有查过）。那么这里就是和普通的继承的一点局别，引入了一个虚基类表指针。那么类比于`vftable`的内容，我猜`vbtable`里面保存的应该也是一个个的指针，而这些指针指向了某片基类内存。\n\n继续往下看：\n```asm\nmov ecx, dword ptr [ebp-4]\nadd ecx, 10h\ncall HelloWorld2005!Super::Super\n```\n\n要知道在调用构造函数的时候，`ecx`寄存器保存的都是`this`指针（未开启优化的情况下），所以这里好像是把`this+10h`的位置作为了父类的`this`指针，我们看下`ecx`的内容：\n{% asset_img contentofecx.png this指针的值 %}\n\n然后我们进去`Super`构造函数里面看下吧：\n{% asset_img superconstructor.png Super构造函数 %}\n\n好像和平时没有什么两样，完全就是一个普通的构造函数，除了`this`指针是借的`Base`的之外。我们是时候画一下执行完该构造函数之后，`d`对象的内存分布了：\n{% asset_img contentofobjectd.png d的内存分布 %}\n\n好像和我们猜想的不一样，我以前以为是虚表中一个指针指向一块内存，然后这块内存里面有父类的成员啊什么的。\n\n从构造函数里出来之后，第一句话又把我干懵了:\n```asm\nor dword ptr [ebp-48h], 1\n```\n\n因为我真的不知道`ebp-48h`这个地方存放的是个啥东西。。。\n\n接下来的五句话其实很亲切，子类要开始改写虚函数表了：\n```asm\nmov eax, dword ptr [ebp-4]\nmov ecx, dword ptr [eax]\nmov edx, dword ptr [ecx+4]\nmov eax, dowrd ptr [ebp-4]\nmov dword ptr [eax+edx], offset HelloWorld2005!Derive::`vftable'\n```\n\n恩。。。。同学们要不然我们下课吧，好复杂T_T。\n\n首先我们通过`eax`拿到`this`指针，然后把`this`指针指向的第一项内容取出来，放到`ecx`，可以看下上面的内存分布，这个地方存放的就是虚基类表指针。然后将虚基类表指针偏移四个字节，取出一个值存放在edx中，然后将`vftable`放到了`eax+edx`指向的地方。我也没想到会这么复杂。\n\n我们先看看虚基类表指向的那块内存里面到底放了些什么东西吧：\n{% asset_img vbtablecontent.png 虚基类表的内容 %}\n\n还是没有头绪，它偏移四个字节之后，得到的值是`10h`，我们现在又把`this`指针加上`10h`。。。。\n\n诶，好像得到的是父类的基类指针，然后我们把这个基类指针的第一个值改写为`Derive::vftable`，也就是子类的虚函数表，好像一切又明朗起来了。（那个问多重继承怎么办的同学请你以后上课站着）\n\n那么我们是不是可以得出一个结论，虚基类表每个表项的内容其实是它所虚拟继承的所有父类的`this`指针偏移呢？这个问题留待下一章进行讲解。\n\n有了这个解释之后下面的成员变量初始化也就不难解释了，我只在后面加注释了，就不一一讲解了：\n```asm\nmov eax, dword ptr [ebp-4]        ;this\nmov ecx, dword ptr [eax]          ;vbtable\nmov edx, dword ptr [ecx+4]        ;10h，Super指针偏移\nsub edx, 10h                      ;吃饱了撑的？变成0了\nmov eax dword ptr [ebp-4]         ;this\nmov ecx, dword ptr [eax]          ;vbtable\nmov eax, dword ptr [ecx+4]        ;10h\nmov ecx, dword ptr [ebp-4]        ;this\nmov dword ptr [ecx+eax-4], edx    ;vftable上面的那个值（暂时不知道啥用）\n\nmov eax, dword ptr [ebp-4]        ;this指针\nmov dword ptr [eax+4], 0Ah        ;a:10\n\nmov eax, dword ptr [ebp-4]        ;this\nmov dword ptr [eax+8], 0Ch        ;b:12\n\nmov eax, dowrd ptr [ebp-4]        ;this\nmov ecx, dword ptr [eax]          ;vtable\nmov edx, dword ptr [ecx+4]        ;10h\nmov dword ptr [eax+edx+4], 13h    ;Super指针偏移4个字节\n```\n\n那么构造函数已经完全分析完了，我们跳出来，看虚函数的调用，如下：\n```asm\nlea ecx, [ebp-0Ch]\ncall HelloWorld2005!Derive::VirtualFunc1\n```\n\n我们从上面的对象内存分布图可以知道，父类指针存放在`+10h`的位置，这样这里的`ebp-0Ch`就很明白了，它取的是`Derive`中父类`Super`对应的`this`指针。为什么呢？留待以后进一步验证。但是它调用却是`Derive::VirtualFunc1`，恩，我现在和你有相同的疑问，但是不要问，我也不知道。\n\n`F11`进去的代码如下：\n{% asset_img VirtualFunc1Code.png VirtualFunc1的代码 %}\n\n这里我直接跳到了`this`指针保存的后面一句代码。从这里开始计算`Super::a + a + c + b;`，我把代码摘录下来，并在后面加上注释，方便大家理解：\n```asm\nmov dword ptr [ebp-4], ecx          ; 保存this\nmov eax, dword ptr [ebp-4]          ; this放到eax中\nmov ecx, dword ptr [eax-10h]        ; eax-10后是Derive的this指针，然后取址得到虚类表\nmov edx, dword ptr [ecx+4]          ; 得到Super父类的地址偏移，10h\nmov eax, dword ptr [eax+edx-0Ch]    ; 将edx=10h带入到表达式，就是mov eax, dword ptr [eax+4]，也就是Super中的a，保存到了eax\n\nmov ecx, dword ptr [ebp-4]          ; this放到ecx中\nadd eax, dword ptr [ecx-0Ch]        ; this-0Ch的地址保存的就是Derive中的a\n\nmov edx, dword ptr [ebp-4]          ; this保存到edx中\nmov ecx, dword ptr [edx-10h]        ; 虚表类地址\nmov edx, dword ptr [ecx+4]          ; Super父类的地址偏移，10h\nmov ecx, dword ptr [ebp-4]          ; this指针\nadd eax, dword ptr [ecx+edx-8]      ; 这里就是add eax, dword ptr [ecx+8]，也就是Super中的c\n\nmov edx, dword ptr [ebp-4]          ; this指针\nadd eax, dword ptr [edx-8]          ; Derive中的b\n```\n\n可以看到，Derive中的成员变量获取还是很简单的，但是一旦涉及到父类的成员变量，就要先取到虚基类表，然后在通过各种地址偏移得到目标成员变量。我也不知道为什么要这么吃饱了撑得，可能有它自己的权衡吧，或者我猜在多重继承里面会有作用吧。\n\n再往下就开始调用从父类继承过来的`NormalFunc1`函数了，看下给出的汇编指令：\n```asm\nmov eax, dword ptr [ebp-1Ch]\nmov ecx, dword ptr [eax+4]\nlea ecx, [ebp+ecx-1Ch]\ncall HelloWorld2005!Super::NormalFunc1\n```\n\n首先我们直到`d`在堆栈上的地址其实是`ebp-1Ch`（从调用构造函数时压入`ecx`中的值得到），那这里第一步就是先拿到`d`的指针（即`this`指针）指向的内容（这里千万要注意，如果是简单的取`this`指针的话,`lea eax, [ebp-1Ch]`就行了，这里还做了一层析址的操作）。但是我们这里调用的是父类继承过来的成员函数，所以要传递给该成员函数的`this`指针必须是指向`Super`部分的指针。\n\n好，接着往下看，第二句`mov ecx, dword ptr [eax+4]`，`eax+4`保存的是`Super`在子类中分布的地址偏移。所以`ecx`理所当然这里就是`10h`。\n\n第三句`lea ecx, [ebp+ecx-1Ch]`，恩，这里`ebp-1Ch`是对象`d`的`this`指针，然后加上偏移量`ecx`，得到的就是`d`中`Super`的内容的地址（好好想一下，有一点绕）。\n\n最后一句就不用我解释了，很简单，简单的调用啦。\n\n好了到目前为止第五章已经完全讲完了，大家慢慢消化吧。\n\n## 写在后面的话\n我写这个系列完全是在一点都不懂的情况下写的，大家会看到我会做很多猜想、假设，那只是因为我真的也不知道，并不是在卖关子。很多时候都是一边摸索一边写，把自己摸索的过程写下来，然后尽可能地把各种弯路给去掉，但是大家看起来肯定也会觉得有些绕，没办法，因为我也是在摸索阶段。\n\n我在想等把这个出得差不多了，再出一个和编译器相关的系列文章。然后等把这些坑都填完了之后，就可以去整一整平台相关的东西了。恩恩，谢谢大家的支持。","source":"_posts/windbg/windbg-chapter5.md","raw":"---\ntitle: WinDBG观世界（五）\ndate: 2016-06-15 23:34:06\ncategories: windbg\ntags: [windbg,disassembly,c++]\n---\n\n## 导言\nすみません，好久没有更新博客了，因为我觉得越写要写的东西越多，这真的是个大坑，而且我还只挑了`C++99`的相关特性，`C++11`那个真心不敢讲。而且用`hexo`写东西真的有点蛋疼，尤其是截图，简直是煎熬啊。好了闲话不多说了，我们这次要看的东西不多，我们只看虚继承的内容，怕同学们消化不良啊，多重继承的知识放到下一部分讲解。\n<!--more-->\n## 诶？我父亲呢？\n国际惯例，看看今天要解读的代码吧：\n```cpp\nclass Super\n{\npublic:\n    ~Super()\n    {\n\n    }\n\npublic:\n    int NormalFunc1()\n    {\n        return a;\n    }\n\n    virtual int VirtualFunc1()\n    {\n        return a + c;\n    }\n\nprotected:\n    int a;\n    int c;\n};\n\nclass Derive\n    : virtual public Super\n{\npublic:\n    Derive()\n        : a(10)\n        , b(12)\n    {\n        Super::a = 19;\n    }\n\n    ~Derive()\n    {\n\n    }\n\npublic:\n    virtual int VirtualFunc1() override\n    {\n        return Super::a + a + c + b;\n    }\n\nprivate:\n    int a;\n    int b;\n};\n\nint main(int argc, char** argv)\n{\n    Derive d;\n    d.VirtualFunc1();\n    d.NormalFunc1();\n}\n\n```\n\n这里大家带着下面几个问题来听我说吧：\n1. `Derive`的内存分布是怎么样的？`Super`放在什么位置？\n2. `Derive`对象是如何找到父类的虚函数和成员函数的\n3. `Derive`内部是如何传递`this`指针给父类的\n\n如何？没骗你们吧，内容真的不多哦！（不许说我越来越短了！）好了，打开你的`windbg`，把这个`exe`跑起来吧！对了，在此之前为了不让`Visual Studio`生成多余的代码，所以我修改了一些编译选项，包括增量式编译、c++异常检测、堆栈检测等等，设置如下：\n{% asset_img vsoptions.png VS设置1 %}\n{% asset_img linkoptions.png VS设置2 %}\n\n那么下面我们就单步调试到第一行代码对应的汇编码吧：\n{% asset_img firststep.png 第一行代码 %}\n\n第一句话是`push 1`，这个其实以前也遇到过，但是我没有说明是啥，因为我也没有仔细研究过，这里我只是怀疑可能是堆栈上对象的个数。这个坑留着以后填吧。\n\n之后的两句话\n```asm\nlea ecx, [ebp-1Ch]\ncall HelloWorld2005!Derive::Derive\n```\n\n很明显第一句就是在当前堆栈上计算出`d`对象的地址，然后将这个地址当做`this`指针的值传递给构造函数。我们先把当前的堆栈用一个图画出来吧：\n{% asset_img beforedconstructorstack.png 当前堆栈的样子 %}\n\n其中黄色区域是运行时栈上的内容，粉红色区域就是局部变量区域分配给`d`对象的栈上内存（当然那也可能有浪费的，我们前面也了解到了`VS`的尿性）。不过至少能够知道`d`对象的`this`指针是`ebp-1Ch`。那我们`F11`进去函数里面看下吧，我们可以一直走到`this`指针保存到`dword ptr [ebp-4]`的地方：\n{% asset_img inderiveconstructor.png 开始运行Derive构造函数 %}\n\n现在堆栈的图如下：\n{% asset_img inderiveconstructorstack.png 当前的堆栈情况 %}\n\n下面几句就是从来没有见过的了，因为我们知道，构造函数都是先构造父类，然后再构造自己的。所以这里用脚趾头想想应该也知道肯定是准备数据初始化父类的，当然只是猜想哈。来看下面几句：\n```asm\nmov dword ptr [ebp-48h], 0\ncmp dword ptr [ebp+8], 0\nje HelloWorld2005!Derive::Derive+0x31\nmov eax, dword ptr [ebp-4]\nmov dword ptr [eax], offset HelloWorld2005!Derive::`vbtable'\nmov ecx, dword ptr [ebp-4]\nadd ecx, 10h\ncall HelloWorld2005!Super::Super\n```\n\n不要惊讶为什么一下子要看这么多代码，因为我抄到这里才看到熟悉的父类构造函数。前面第一句我真TM不知道是干嘛用的，我真的想一句一句讲，我们忽略它好不好。第二句，要知道`ebp+8`指向的内容就是我刚刚猜测是堆栈上对象个数的值，看上面的图就知道，就是`1`，这里和0进行比，如果等于`0`，就跳转到`Derive::Derive+0x31`的位置。意义何在啊？当然你可以用`u HelloWorld2005+Derive::Derive+0x31`指令去看下这个地方的汇编代码。可以看出来，这句话的作用其实是跳过了父类构造函数的调用，如下所示：\n{% asset_img jumpoversupercall.png 跳过了父类构造函数 %}\n\n那么应该存在某种情况，我们调用构造函数不会调用父类构造函数，但是我也不知道什么时候会发生这种情况。那么我们继续往下看：\n```asm\nmov eax, dword ptr [ebp-4]\nmov dword ptr [eax], offset HelloWorld2005!Derive::`vbtable'\n```\n\n要知道`ebp-4`的地方保存的是`this`指针，而它拿到`this`指针之后就把一个`vbtable`赋值给了`this`指针指向的起始地址。同学们（装腔作势样），你们还记得前面介绍虚函数的时候有一个`vftable`么，应该不难猜出这个地方的`vbtable`应该就是`virtual base table`的意思吧（我自己翻译的，官方翻译我没有查过）。那么这里就是和普通的继承的一点局别，引入了一个虚基类表指针。那么类比于`vftable`的内容，我猜`vbtable`里面保存的应该也是一个个的指针，而这些指针指向了某片基类内存。\n\n继续往下看：\n```asm\nmov ecx, dword ptr [ebp-4]\nadd ecx, 10h\ncall HelloWorld2005!Super::Super\n```\n\n要知道在调用构造函数的时候，`ecx`寄存器保存的都是`this`指针（未开启优化的情况下），所以这里好像是把`this+10h`的位置作为了父类的`this`指针，我们看下`ecx`的内容：\n{% asset_img contentofecx.png this指针的值 %}\n\n然后我们进去`Super`构造函数里面看下吧：\n{% asset_img superconstructor.png Super构造函数 %}\n\n好像和平时没有什么两样，完全就是一个普通的构造函数，除了`this`指针是借的`Base`的之外。我们是时候画一下执行完该构造函数之后，`d`对象的内存分布了：\n{% asset_img contentofobjectd.png d的内存分布 %}\n\n好像和我们猜想的不一样，我以前以为是虚表中一个指针指向一块内存，然后这块内存里面有父类的成员啊什么的。\n\n从构造函数里出来之后，第一句话又把我干懵了:\n```asm\nor dword ptr [ebp-48h], 1\n```\n\n因为我真的不知道`ebp-48h`这个地方存放的是个啥东西。。。\n\n接下来的五句话其实很亲切，子类要开始改写虚函数表了：\n```asm\nmov eax, dword ptr [ebp-4]\nmov ecx, dword ptr [eax]\nmov edx, dword ptr [ecx+4]\nmov eax, dowrd ptr [ebp-4]\nmov dword ptr [eax+edx], offset HelloWorld2005!Derive::`vftable'\n```\n\n恩。。。。同学们要不然我们下课吧，好复杂T_T。\n\n首先我们通过`eax`拿到`this`指针，然后把`this`指针指向的第一项内容取出来，放到`ecx`，可以看下上面的内存分布，这个地方存放的就是虚基类表指针。然后将虚基类表指针偏移四个字节，取出一个值存放在edx中，然后将`vftable`放到了`eax+edx`指向的地方。我也没想到会这么复杂。\n\n我们先看看虚基类表指向的那块内存里面到底放了些什么东西吧：\n{% asset_img vbtablecontent.png 虚基类表的内容 %}\n\n还是没有头绪，它偏移四个字节之后，得到的值是`10h`，我们现在又把`this`指针加上`10h`。。。。\n\n诶，好像得到的是父类的基类指针，然后我们把这个基类指针的第一个值改写为`Derive::vftable`，也就是子类的虚函数表，好像一切又明朗起来了。（那个问多重继承怎么办的同学请你以后上课站着）\n\n那么我们是不是可以得出一个结论，虚基类表每个表项的内容其实是它所虚拟继承的所有父类的`this`指针偏移呢？这个问题留待下一章进行讲解。\n\n有了这个解释之后下面的成员变量初始化也就不难解释了，我只在后面加注释了，就不一一讲解了：\n```asm\nmov eax, dword ptr [ebp-4]        ;this\nmov ecx, dword ptr [eax]          ;vbtable\nmov edx, dword ptr [ecx+4]        ;10h，Super指针偏移\nsub edx, 10h                      ;吃饱了撑的？变成0了\nmov eax dword ptr [ebp-4]         ;this\nmov ecx, dword ptr [eax]          ;vbtable\nmov eax, dword ptr [ecx+4]        ;10h\nmov ecx, dword ptr [ebp-4]        ;this\nmov dword ptr [ecx+eax-4], edx    ;vftable上面的那个值（暂时不知道啥用）\n\nmov eax, dword ptr [ebp-4]        ;this指针\nmov dword ptr [eax+4], 0Ah        ;a:10\n\nmov eax, dword ptr [ebp-4]        ;this\nmov dword ptr [eax+8], 0Ch        ;b:12\n\nmov eax, dowrd ptr [ebp-4]        ;this\nmov ecx, dword ptr [eax]          ;vtable\nmov edx, dword ptr [ecx+4]        ;10h\nmov dword ptr [eax+edx+4], 13h    ;Super指针偏移4个字节\n```\n\n那么构造函数已经完全分析完了，我们跳出来，看虚函数的调用，如下：\n```asm\nlea ecx, [ebp-0Ch]\ncall HelloWorld2005!Derive::VirtualFunc1\n```\n\n我们从上面的对象内存分布图可以知道，父类指针存放在`+10h`的位置，这样这里的`ebp-0Ch`就很明白了，它取的是`Derive`中父类`Super`对应的`this`指针。为什么呢？留待以后进一步验证。但是它调用却是`Derive::VirtualFunc1`，恩，我现在和你有相同的疑问，但是不要问，我也不知道。\n\n`F11`进去的代码如下：\n{% asset_img VirtualFunc1Code.png VirtualFunc1的代码 %}\n\n这里我直接跳到了`this`指针保存的后面一句代码。从这里开始计算`Super::a + a + c + b;`，我把代码摘录下来，并在后面加上注释，方便大家理解：\n```asm\nmov dword ptr [ebp-4], ecx          ; 保存this\nmov eax, dword ptr [ebp-4]          ; this放到eax中\nmov ecx, dword ptr [eax-10h]        ; eax-10后是Derive的this指针，然后取址得到虚类表\nmov edx, dword ptr [ecx+4]          ; 得到Super父类的地址偏移，10h\nmov eax, dword ptr [eax+edx-0Ch]    ; 将edx=10h带入到表达式，就是mov eax, dword ptr [eax+4]，也就是Super中的a，保存到了eax\n\nmov ecx, dword ptr [ebp-4]          ; this放到ecx中\nadd eax, dword ptr [ecx-0Ch]        ; this-0Ch的地址保存的就是Derive中的a\n\nmov edx, dword ptr [ebp-4]          ; this保存到edx中\nmov ecx, dword ptr [edx-10h]        ; 虚表类地址\nmov edx, dword ptr [ecx+4]          ; Super父类的地址偏移，10h\nmov ecx, dword ptr [ebp-4]          ; this指针\nadd eax, dword ptr [ecx+edx-8]      ; 这里就是add eax, dword ptr [ecx+8]，也就是Super中的c\n\nmov edx, dword ptr [ebp-4]          ; this指针\nadd eax, dword ptr [edx-8]          ; Derive中的b\n```\n\n可以看到，Derive中的成员变量获取还是很简单的，但是一旦涉及到父类的成员变量，就要先取到虚基类表，然后在通过各种地址偏移得到目标成员变量。我也不知道为什么要这么吃饱了撑得，可能有它自己的权衡吧，或者我猜在多重继承里面会有作用吧。\n\n再往下就开始调用从父类继承过来的`NormalFunc1`函数了，看下给出的汇编指令：\n```asm\nmov eax, dword ptr [ebp-1Ch]\nmov ecx, dword ptr [eax+4]\nlea ecx, [ebp+ecx-1Ch]\ncall HelloWorld2005!Super::NormalFunc1\n```\n\n首先我们直到`d`在堆栈上的地址其实是`ebp-1Ch`（从调用构造函数时压入`ecx`中的值得到），那这里第一步就是先拿到`d`的指针（即`this`指针）指向的内容（这里千万要注意，如果是简单的取`this`指针的话,`lea eax, [ebp-1Ch]`就行了，这里还做了一层析址的操作）。但是我们这里调用的是父类继承过来的成员函数，所以要传递给该成员函数的`this`指针必须是指向`Super`部分的指针。\n\n好，接着往下看，第二句`mov ecx, dword ptr [eax+4]`，`eax+4`保存的是`Super`在子类中分布的地址偏移。所以`ecx`理所当然这里就是`10h`。\n\n第三句`lea ecx, [ebp+ecx-1Ch]`，恩，这里`ebp-1Ch`是对象`d`的`this`指针，然后加上偏移量`ecx`，得到的就是`d`中`Super`的内容的地址（好好想一下，有一点绕）。\n\n最后一句就不用我解释了，很简单，简单的调用啦。\n\n好了到目前为止第五章已经完全讲完了，大家慢慢消化吧。\n\n## 写在后面的话\n我写这个系列完全是在一点都不懂的情况下写的，大家会看到我会做很多猜想、假设，那只是因为我真的也不知道，并不是在卖关子。很多时候都是一边摸索一边写，把自己摸索的过程写下来，然后尽可能地把各种弯路给去掉，但是大家看起来肯定也会觉得有些绕，没办法，因为我也是在摸索阶段。\n\n我在想等把这个出得差不多了，再出一个和编译器相关的系列文章。然后等把这些坑都填完了之后，就可以去整一整平台相关的东西了。恩恩，谢谢大家的支持。","slug":"windbg-windbg-chapter5","published":1,"updated":"2018-06-25T11:14:49.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjivnhtpa001q2gusrrjdberd","content":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>すみません，好久没有更新博客了，因为我觉得越写要写的东西越多，这真的是个大坑，而且我还只挑了<code>C++99</code>的相关特性，<code>C++11</code>那个真心不敢讲。而且用<code>hexo</code>写东西真的有点蛋疼，尤其是截图，简直是煎熬啊。好了闲话不多说了，我们这次要看的东西不多，我们只看虚继承的内容，怕同学们消化不良啊，多重继承的知识放到下一部分讲解。<br><a id=\"more\"></a></p>\n<h2 id=\"诶？我父亲呢？\"><a href=\"#诶？我父亲呢？\" class=\"headerlink\" title=\"诶？我父亲呢？\"></a>诶？我父亲呢？</h2><p>国际惯例，看看今天要解读的代码吧：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Super</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~Super()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NormalFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">VirtualFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derive</span></span></span><br><span class=\"line\"><span class=\"class\">    :</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Super</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derive()</span><br><span class=\"line\">        : a(<span class=\"number\">10</span>)</span><br><span class=\"line\">        , b(<span class=\"number\">12</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Super::a = <span class=\"number\">19</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~Derive()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">VirtualFunc1</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Super::a + a + c + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derive d;</span><br><span class=\"line\">    d.VirtualFunc1();</span><br><span class=\"line\">    d.NormalFunc1();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里大家带着下面几个问题来听我说吧：</p>\n<ol>\n<li><code>Derive</code>的内存分布是怎么样的？<code>Super</code>放在什么位置？</li>\n<li><code>Derive</code>对象是如何找到父类的虚函数和成员函数的</li>\n<li><code>Derive</code>内部是如何传递<code>this</code>指针给父类的</li>\n</ol>\n<p>如何？没骗你们吧，内容真的不多哦！（不许说我越来越短了！）好了，打开你的<code>windbg</code>，把这个<code>exe</code>跑起来吧！对了，在此之前为了不让<code>Visual Studio</code>生成多余的代码，所以我修改了一些编译选项，包括增量式编译、c++异常检测、堆栈检测等等，设置如下：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/vsoptions.png\" title=\"VS设置1\"><br><img src=\"/2016/06/15/windbg-windbg-chapter5/linkoptions.png\" title=\"VS设置2\"></p>\n<p>那么下面我们就单步调试到第一行代码对应的汇编码吧：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/firststep.png\" title=\"第一行代码\"></p>\n<p>第一句话是<code>push 1</code>，这个其实以前也遇到过，但是我没有说明是啥，因为我也没有仔细研究过，这里我只是怀疑可能是堆栈上对象的个数。这个坑留着以后填吧。</p>\n<p>之后的两句话<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea ecx, [ebp-1Ch]</span><br><span class=\"line\">call HelloWorld2005!Derive::Derive</span><br></pre></td></tr></table></figure></p>\n<p>很明显第一句就是在当前堆栈上计算出<code>d</code>对象的地址，然后将这个地址当做<code>this</code>指针的值传递给构造函数。我们先把当前的堆栈用一个图画出来吧：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/beforedconstructorstack.png\" title=\"当前堆栈的样子\"></p>\n<p>其中黄色区域是运行时栈上的内容，粉红色区域就是局部变量区域分配给<code>d</code>对象的栈上内存（当然那也可能有浪费的，我们前面也了解到了<code>VS</code>的尿性）。不过至少能够知道<code>d</code>对象的<code>this</code>指针是<code>ebp-1Ch</code>。那我们<code>F11</code>进去函数里面看下吧，我们可以一直走到<code>this</code>指针保存到<code>dword ptr [ebp-4]</code>的地方：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/inderiveconstructor.png\" title=\"开始运行Derive构造函数\"></p>\n<p>现在堆栈的图如下：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/inderiveconstructorstack.png\" title=\"当前的堆栈情况\"></p>\n<p>下面几句就是从来没有见过的了，因为我们知道，构造函数都是先构造父类，然后再构造自己的。所以这里用脚趾头想想应该也知道肯定是准备数据初始化父类的，当然只是猜想哈。来看下面几句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-48h], 0</span><br><span class=\"line\">cmp dword ptr [ebp+8], 0</span><br><span class=\"line\">je HelloWorld2005!Derive::Derive+0x31</span><br><span class=\"line\">mov eax, dword ptr [ebp-4]</span><br><span class=\"line\">mov dword ptr [eax], offset HelloWorld2005!Derive::`vbtable&apos;</span><br><span class=\"line\">mov ecx, dword ptr [ebp-4]</span><br><span class=\"line\">add ecx, 10h</span><br><span class=\"line\">call HelloWorld2005!Super::Super</span><br></pre></td></tr></table></figure></p>\n<p>不要惊讶为什么一下子要看这么多代码，因为我抄到这里才看到熟悉的父类构造函数。前面第一句我真TM不知道是干嘛用的，我真的想一句一句讲，我们忽略它好不好。第二句，要知道<code>ebp+8</code>指向的内容就是我刚刚猜测是堆栈上对象个数的值，看上面的图就知道，就是<code>1</code>，这里和0进行比，如果等于<code>0</code>，就跳转到<code>Derive::Derive+0x31</code>的位置。意义何在啊？当然你可以用<code>u HelloWorld2005+Derive::Derive+0x31</code>指令去看下这个地方的汇编代码。可以看出来，这句话的作用其实是跳过了父类构造函数的调用，如下所示：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/jumpoversupercall.png\" title=\"跳过了父类构造函数\"></p>\n<p>那么应该存在某种情况，我们调用构造函数不会调用父类构造函数，但是我也不知道什么时候会发生这种情况。那么我们继续往下看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-4]</span><br><span class=\"line\">mov dword ptr [eax], offset HelloWorld2005!Derive::`vbtable&apos;</span><br></pre></td></tr></table></figure></p>\n<p>要知道<code>ebp-4</code>的地方保存的是<code>this</code>指针，而它拿到<code>this</code>指针之后就把一个<code>vbtable</code>赋值给了<code>this</code>指针指向的起始地址。同学们（装腔作势样），你们还记得前面介绍虚函数的时候有一个<code>vftable</code>么，应该不难猜出这个地方的<code>vbtable</code>应该就是<code>virtual base table</code>的意思吧（我自己翻译的，官方翻译我没有查过）。那么这里就是和普通的继承的一点局别，引入了一个虚基类表指针。那么类比于<code>vftable</code>的内容，我猜<code>vbtable</code>里面保存的应该也是一个个的指针，而这些指针指向了某片基类内存。</p>\n<p>继续往下看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx, dword ptr [ebp-4]</span><br><span class=\"line\">add ecx, 10h</span><br><span class=\"line\">call HelloWorld2005!Super::Super</span><br></pre></td></tr></table></figure></p>\n<p>要知道在调用构造函数的时候，<code>ecx</code>寄存器保存的都是<code>this</code>指针（未开启优化的情况下），所以这里好像是把<code>this+10h</code>的位置作为了父类的<code>this</code>指针，我们看下<code>ecx</code>的内容：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/contentofecx.png\" title=\"this指针的值\"></p>\n<p>然后我们进去<code>Super</code>构造函数里面看下吧：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/superconstructor.png\" title=\"Super构造函数\"></p>\n<p>好像和平时没有什么两样，完全就是一个普通的构造函数，除了<code>this</code>指针是借的<code>Base</code>的之外。我们是时候画一下执行完该构造函数之后，<code>d</code>对象的内存分布了：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/contentofobjectd.png\" title=\"d的内存分布\"></p>\n<p>好像和我们猜想的不一样，我以前以为是虚表中一个指针指向一块内存，然后这块内存里面有父类的成员啊什么的。</p>\n<p>从构造函数里出来之后，第一句话又把我干懵了:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">or dword ptr [ebp-48h], 1</span><br></pre></td></tr></table></figure></p>\n<p>因为我真的不知道<code>ebp-48h</code>这个地方存放的是个啥东西。。。</p>\n<p>接下来的五句话其实很亲切，子类要开始改写虚函数表了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-4]</span><br><span class=\"line\">mov ecx, dword ptr [eax]</span><br><span class=\"line\">mov edx, dword ptr [ecx+4]</span><br><span class=\"line\">mov eax, dowrd ptr [ebp-4]</span><br><span class=\"line\">mov dword ptr [eax+edx], offset HelloWorld2005!Derive::`vftable&apos;</span><br></pre></td></tr></table></figure></p>\n<p>恩。。。。同学们要不然我们下课吧，好复杂T_T。</p>\n<p>首先我们通过<code>eax</code>拿到<code>this</code>指针，然后把<code>this</code>指针指向的第一项内容取出来，放到<code>ecx</code>，可以看下上面的内存分布，这个地方存放的就是虚基类表指针。然后将虚基类表指针偏移四个字节，取出一个值存放在edx中，然后将<code>vftable</code>放到了<code>eax+edx</code>指向的地方。我也没想到会这么复杂。</p>\n<p>我们先看看虚基类表指向的那块内存里面到底放了些什么东西吧：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/vbtablecontent.png\" title=\"虚基类表的内容\"></p>\n<p>还是没有头绪，它偏移四个字节之后，得到的值是<code>10h</code>，我们现在又把<code>this</code>指针加上<code>10h</code>。。。。</p>\n<p>诶，好像得到的是父类的基类指针，然后我们把这个基类指针的第一个值改写为<code>Derive::vftable</code>，也就是子类的虚函数表，好像一切又明朗起来了。（那个问多重继承怎么办的同学请你以后上课站着）</p>\n<p>那么我们是不是可以得出一个结论，虚基类表每个表项的内容其实是它所虚拟继承的所有父类的<code>this</code>指针偏移呢？这个问题留待下一章进行讲解。</p>\n<p>有了这个解释之后下面的成员变量初始化也就不难解释了，我只在后面加注释了，就不一一讲解了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-4]        ;this</span><br><span class=\"line\">mov ecx, dword ptr [eax]          ;vbtable</span><br><span class=\"line\">mov edx, dword ptr [ecx+4]        ;10h，Super指针偏移</span><br><span class=\"line\">sub edx, 10h                      ;吃饱了撑的？变成0了</span><br><span class=\"line\">mov eax dword ptr [ebp-4]         ;this</span><br><span class=\"line\">mov ecx, dword ptr [eax]          ;vbtable</span><br><span class=\"line\">mov eax, dword ptr [ecx+4]        ;10h</span><br><span class=\"line\">mov ecx, dword ptr [ebp-4]        ;this</span><br><span class=\"line\">mov dword ptr [ecx+eax-4], edx    ;vftable上面的那个值（暂时不知道啥用）</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-4]        ;this指针</span><br><span class=\"line\">mov dword ptr [eax+4], 0Ah        ;a:10</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-4]        ;this</span><br><span class=\"line\">mov dword ptr [eax+8], 0Ch        ;b:12</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dowrd ptr [ebp-4]        ;this</span><br><span class=\"line\">mov ecx, dword ptr [eax]          ;vtable</span><br><span class=\"line\">mov edx, dword ptr [ecx+4]        ;10h</span><br><span class=\"line\">mov dword ptr [eax+edx+4], 13h    ;Super指针偏移4个字节</span><br></pre></td></tr></table></figure></p>\n<p>那么构造函数已经完全分析完了，我们跳出来，看虚函数的调用，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea ecx, [ebp-0Ch]</span><br><span class=\"line\">call HelloWorld2005!Derive::VirtualFunc1</span><br></pre></td></tr></table></figure></p>\n<p>我们从上面的对象内存分布图可以知道，父类指针存放在<code>+10h</code>的位置，这样这里的<code>ebp-0Ch</code>就很明白了，它取的是<code>Derive</code>中父类<code>Super</code>对应的<code>this</code>指针。为什么呢？留待以后进一步验证。但是它调用却是<code>Derive::VirtualFunc1</code>，恩，我现在和你有相同的疑问，但是不要问，我也不知道。</p>\n<p><code>F11</code>进去的代码如下：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/VirtualFunc1Code.png\" title=\"VirtualFunc1的代码\"></p>\n<p>这里我直接跳到了<code>this</code>指针保存的后面一句代码。从这里开始计算<code>Super::a + a + c + b;</code>，我把代码摘录下来，并在后面加上注释，方便大家理解：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-4], ecx          ; 保存this</span><br><span class=\"line\">mov eax, dword ptr [ebp-4]          ; this放到eax中</span><br><span class=\"line\">mov ecx, dword ptr [eax-10h]        ; eax-10后是Derive的this指针，然后取址得到虚类表</span><br><span class=\"line\">mov edx, dword ptr [ecx+4]          ; 得到Super父类的地址偏移，10h</span><br><span class=\"line\">mov eax, dword ptr [eax+edx-0Ch]    ; 将edx=10h带入到表达式，就是mov eax, dword ptr [eax+4]，也就是Super中的a，保存到了eax</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [ebp-4]          ; this放到ecx中</span><br><span class=\"line\">add eax, dword ptr [ecx-0Ch]        ; this-0Ch的地址保存的就是Derive中的a</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-4]          ; this保存到edx中</span><br><span class=\"line\">mov ecx, dword ptr [edx-10h]        ; 虚表类地址</span><br><span class=\"line\">mov edx, dword ptr [ecx+4]          ; Super父类的地址偏移，10h</span><br><span class=\"line\">mov ecx, dword ptr [ebp-4]          ; this指针</span><br><span class=\"line\">add eax, dword ptr [ecx+edx-8]      ; 这里就是add eax, dword ptr [ecx+8]，也就是Super中的c</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-4]          ; this指针</span><br><span class=\"line\">add eax, dword ptr [edx-8]          ; Derive中的b</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，Derive中的成员变量获取还是很简单的，但是一旦涉及到父类的成员变量，就要先取到虚基类表，然后在通过各种地址偏移得到目标成员变量。我也不知道为什么要这么吃饱了撑得，可能有它自己的权衡吧，或者我猜在多重继承里面会有作用吧。</p>\n<p>再往下就开始调用从父类继承过来的<code>NormalFunc1</code>函数了，看下给出的汇编指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-1Ch]</span><br><span class=\"line\">mov ecx, dword ptr [eax+4]</span><br><span class=\"line\">lea ecx, [ebp+ecx-1Ch]</span><br><span class=\"line\">call HelloWorld2005!Super::NormalFunc1</span><br></pre></td></tr></table></figure></p>\n<p>首先我们直到<code>d</code>在堆栈上的地址其实是<code>ebp-1Ch</code>（从调用构造函数时压入<code>ecx</code>中的值得到），那这里第一步就是先拿到<code>d</code>的指针（即<code>this</code>指针）指向的内容（这里千万要注意，如果是简单的取<code>this</code>指针的话,<code>lea eax, [ebp-1Ch]</code>就行了，这里还做了一层析址的操作）。但是我们这里调用的是父类继承过来的成员函数，所以要传递给该成员函数的<code>this</code>指针必须是指向<code>Super</code>部分的指针。</p>\n<p>好，接着往下看，第二句<code>mov ecx, dword ptr [eax+4]</code>，<code>eax+4</code>保存的是<code>Super</code>在子类中分布的地址偏移。所以<code>ecx</code>理所当然这里就是<code>10h</code>。</p>\n<p>第三句<code>lea ecx, [ebp+ecx-1Ch]</code>，恩，这里<code>ebp-1Ch</code>是对象<code>d</code>的<code>this</code>指针，然后加上偏移量<code>ecx</code>，得到的就是<code>d</code>中<code>Super</code>的内容的地址（好好想一下，有一点绕）。</p>\n<p>最后一句就不用我解释了，很简单，简单的调用啦。</p>\n<p>好了到目前为止第五章已经完全讲完了，大家慢慢消化吧。</p>\n<h2 id=\"写在后面的话\"><a href=\"#写在后面的话\" class=\"headerlink\" title=\"写在后面的话\"></a>写在后面的话</h2><p>我写这个系列完全是在一点都不懂的情况下写的，大家会看到我会做很多猜想、假设，那只是因为我真的也不知道，并不是在卖关子。很多时候都是一边摸索一边写，把自己摸索的过程写下来，然后尽可能地把各种弯路给去掉，但是大家看起来肯定也会觉得有些绕，没办法，因为我也是在摸索阶段。</p>\n<p>我在想等把这个出得差不多了，再出一个和编译器相关的系列文章。然后等把这些坑都填完了之后，就可以去整一整平台相关的东西了。恩恩，谢谢大家的支持。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>すみません，好久没有更新博客了，因为我觉得越写要写的东西越多，这真的是个大坑，而且我还只挑了<code>C++99</code>的相关特性，<code>C++11</code>那个真心不敢讲。而且用<code>hexo</code>写东西真的有点蛋疼，尤其是截图，简直是煎熬啊。好了闲话不多说了，我们这次要看的东西不多，我们只看虚继承的内容，怕同学们消化不良啊，多重继承的知识放到下一部分讲解。<br>","more":"</p>\n<h2 id=\"诶？我父亲呢？\"><a href=\"#诶？我父亲呢？\" class=\"headerlink\" title=\"诶？我父亲呢？\"></a>诶？我父亲呢？</h2><p>国际惯例，看看今天要解读的代码吧：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Super</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~Super()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NormalFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">VirtualFunc1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derive</span></span></span><br><span class=\"line\"><span class=\"class\">    :</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> Super</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Derive()</span><br><span class=\"line\">        : a(<span class=\"number\">10</span>)</span><br><span class=\"line\">        , b(<span class=\"number\">12</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Super::a = <span class=\"number\">19</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~Derive()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">VirtualFunc1</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Super::a + a + c + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Derive d;</span><br><span class=\"line\">    d.VirtualFunc1();</span><br><span class=\"line\">    d.NormalFunc1();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里大家带着下面几个问题来听我说吧：</p>\n<ol>\n<li><code>Derive</code>的内存分布是怎么样的？<code>Super</code>放在什么位置？</li>\n<li><code>Derive</code>对象是如何找到父类的虚函数和成员函数的</li>\n<li><code>Derive</code>内部是如何传递<code>this</code>指针给父类的</li>\n</ol>\n<p>如何？没骗你们吧，内容真的不多哦！（不许说我越来越短了！）好了，打开你的<code>windbg</code>，把这个<code>exe</code>跑起来吧！对了，在此之前为了不让<code>Visual Studio</code>生成多余的代码，所以我修改了一些编译选项，包括增量式编译、c++异常检测、堆栈检测等等，设置如下：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/vsoptions.png\" title=\"VS设置1\"><br><img src=\"/2016/06/15/windbg-windbg-chapter5/linkoptions.png\" title=\"VS设置2\"></p>\n<p>那么下面我们就单步调试到第一行代码对应的汇编码吧：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/firststep.png\" title=\"第一行代码\"></p>\n<p>第一句话是<code>push 1</code>，这个其实以前也遇到过，但是我没有说明是啥，因为我也没有仔细研究过，这里我只是怀疑可能是堆栈上对象的个数。这个坑留着以后填吧。</p>\n<p>之后的两句话<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea ecx, [ebp-1Ch]</span><br><span class=\"line\">call HelloWorld2005!Derive::Derive</span><br></pre></td></tr></table></figure></p>\n<p>很明显第一句就是在当前堆栈上计算出<code>d</code>对象的地址，然后将这个地址当做<code>this</code>指针的值传递给构造函数。我们先把当前的堆栈用一个图画出来吧：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/beforedconstructorstack.png\" title=\"当前堆栈的样子\"></p>\n<p>其中黄色区域是运行时栈上的内容，粉红色区域就是局部变量区域分配给<code>d</code>对象的栈上内存（当然那也可能有浪费的，我们前面也了解到了<code>VS</code>的尿性）。不过至少能够知道<code>d</code>对象的<code>this</code>指针是<code>ebp-1Ch</code>。那我们<code>F11</code>进去函数里面看下吧，我们可以一直走到<code>this</code>指针保存到<code>dword ptr [ebp-4]</code>的地方：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/inderiveconstructor.png\" title=\"开始运行Derive构造函数\"></p>\n<p>现在堆栈的图如下：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/inderiveconstructorstack.png\" title=\"当前的堆栈情况\"></p>\n<p>下面几句就是从来没有见过的了，因为我们知道，构造函数都是先构造父类，然后再构造自己的。所以这里用脚趾头想想应该也知道肯定是准备数据初始化父类的，当然只是猜想哈。来看下面几句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-48h], 0</span><br><span class=\"line\">cmp dword ptr [ebp+8], 0</span><br><span class=\"line\">je HelloWorld2005!Derive::Derive+0x31</span><br><span class=\"line\">mov eax, dword ptr [ebp-4]</span><br><span class=\"line\">mov dword ptr [eax], offset HelloWorld2005!Derive::`vbtable&apos;</span><br><span class=\"line\">mov ecx, dword ptr [ebp-4]</span><br><span class=\"line\">add ecx, 10h</span><br><span class=\"line\">call HelloWorld2005!Super::Super</span><br></pre></td></tr></table></figure></p>\n<p>不要惊讶为什么一下子要看这么多代码，因为我抄到这里才看到熟悉的父类构造函数。前面第一句我真TM不知道是干嘛用的，我真的想一句一句讲，我们忽略它好不好。第二句，要知道<code>ebp+8</code>指向的内容就是我刚刚猜测是堆栈上对象个数的值，看上面的图就知道，就是<code>1</code>，这里和0进行比，如果等于<code>0</code>，就跳转到<code>Derive::Derive+0x31</code>的位置。意义何在啊？当然你可以用<code>u HelloWorld2005+Derive::Derive+0x31</code>指令去看下这个地方的汇编代码。可以看出来，这句话的作用其实是跳过了父类构造函数的调用，如下所示：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/jumpoversupercall.png\" title=\"跳过了父类构造函数\"></p>\n<p>那么应该存在某种情况，我们调用构造函数不会调用父类构造函数，但是我也不知道什么时候会发生这种情况。那么我们继续往下看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-4]</span><br><span class=\"line\">mov dword ptr [eax], offset HelloWorld2005!Derive::`vbtable&apos;</span><br></pre></td></tr></table></figure></p>\n<p>要知道<code>ebp-4</code>的地方保存的是<code>this</code>指针，而它拿到<code>this</code>指针之后就把一个<code>vbtable</code>赋值给了<code>this</code>指针指向的起始地址。同学们（装腔作势样），你们还记得前面介绍虚函数的时候有一个<code>vftable</code>么，应该不难猜出这个地方的<code>vbtable</code>应该就是<code>virtual base table</code>的意思吧（我自己翻译的，官方翻译我没有查过）。那么这里就是和普通的继承的一点局别，引入了一个虚基类表指针。那么类比于<code>vftable</code>的内容，我猜<code>vbtable</code>里面保存的应该也是一个个的指针，而这些指针指向了某片基类内存。</p>\n<p>继续往下看：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ecx, dword ptr [ebp-4]</span><br><span class=\"line\">add ecx, 10h</span><br><span class=\"line\">call HelloWorld2005!Super::Super</span><br></pre></td></tr></table></figure></p>\n<p>要知道在调用构造函数的时候，<code>ecx</code>寄存器保存的都是<code>this</code>指针（未开启优化的情况下），所以这里好像是把<code>this+10h</code>的位置作为了父类的<code>this</code>指针，我们看下<code>ecx</code>的内容：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/contentofecx.png\" title=\"this指针的值\"></p>\n<p>然后我们进去<code>Super</code>构造函数里面看下吧：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/superconstructor.png\" title=\"Super构造函数\"></p>\n<p>好像和平时没有什么两样，完全就是一个普通的构造函数，除了<code>this</code>指针是借的<code>Base</code>的之外。我们是时候画一下执行完该构造函数之后，<code>d</code>对象的内存分布了：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/contentofobjectd.png\" title=\"d的内存分布\"></p>\n<p>好像和我们猜想的不一样，我以前以为是虚表中一个指针指向一块内存，然后这块内存里面有父类的成员啊什么的。</p>\n<p>从构造函数里出来之后，第一句话又把我干懵了:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">or dword ptr [ebp-48h], 1</span><br></pre></td></tr></table></figure></p>\n<p>因为我真的不知道<code>ebp-48h</code>这个地方存放的是个啥东西。。。</p>\n<p>接下来的五句话其实很亲切，子类要开始改写虚函数表了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-4]</span><br><span class=\"line\">mov ecx, dword ptr [eax]</span><br><span class=\"line\">mov edx, dword ptr [ecx+4]</span><br><span class=\"line\">mov eax, dowrd ptr [ebp-4]</span><br><span class=\"line\">mov dword ptr [eax+edx], offset HelloWorld2005!Derive::`vftable&apos;</span><br></pre></td></tr></table></figure></p>\n<p>恩。。。。同学们要不然我们下课吧，好复杂T_T。</p>\n<p>首先我们通过<code>eax</code>拿到<code>this</code>指针，然后把<code>this</code>指针指向的第一项内容取出来，放到<code>ecx</code>，可以看下上面的内存分布，这个地方存放的就是虚基类表指针。然后将虚基类表指针偏移四个字节，取出一个值存放在edx中，然后将<code>vftable</code>放到了<code>eax+edx</code>指向的地方。我也没想到会这么复杂。</p>\n<p>我们先看看虚基类表指向的那块内存里面到底放了些什么东西吧：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/vbtablecontent.png\" title=\"虚基类表的内容\"></p>\n<p>还是没有头绪，它偏移四个字节之后，得到的值是<code>10h</code>，我们现在又把<code>this</code>指针加上<code>10h</code>。。。。</p>\n<p>诶，好像得到的是父类的基类指针，然后我们把这个基类指针的第一个值改写为<code>Derive::vftable</code>，也就是子类的虚函数表，好像一切又明朗起来了。（那个问多重继承怎么办的同学请你以后上课站着）</p>\n<p>那么我们是不是可以得出一个结论，虚基类表每个表项的内容其实是它所虚拟继承的所有父类的<code>this</code>指针偏移呢？这个问题留待下一章进行讲解。</p>\n<p>有了这个解释之后下面的成员变量初始化也就不难解释了，我只在后面加注释了，就不一一讲解了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-4]        ;this</span><br><span class=\"line\">mov ecx, dword ptr [eax]          ;vbtable</span><br><span class=\"line\">mov edx, dword ptr [ecx+4]        ;10h，Super指针偏移</span><br><span class=\"line\">sub edx, 10h                      ;吃饱了撑的？变成0了</span><br><span class=\"line\">mov eax dword ptr [ebp-4]         ;this</span><br><span class=\"line\">mov ecx, dword ptr [eax]          ;vbtable</span><br><span class=\"line\">mov eax, dword ptr [ecx+4]        ;10h</span><br><span class=\"line\">mov ecx, dword ptr [ebp-4]        ;this</span><br><span class=\"line\">mov dword ptr [ecx+eax-4], edx    ;vftable上面的那个值（暂时不知道啥用）</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-4]        ;this指针</span><br><span class=\"line\">mov dword ptr [eax+4], 0Ah        ;a:10</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dword ptr [ebp-4]        ;this</span><br><span class=\"line\">mov dword ptr [eax+8], 0Ch        ;b:12</span><br><span class=\"line\"></span><br><span class=\"line\">mov eax, dowrd ptr [ebp-4]        ;this</span><br><span class=\"line\">mov ecx, dword ptr [eax]          ;vtable</span><br><span class=\"line\">mov edx, dword ptr [ecx+4]        ;10h</span><br><span class=\"line\">mov dword ptr [eax+edx+4], 13h    ;Super指针偏移4个字节</span><br></pre></td></tr></table></figure></p>\n<p>那么构造函数已经完全分析完了，我们跳出来，看虚函数的调用，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea ecx, [ebp-0Ch]</span><br><span class=\"line\">call HelloWorld2005!Derive::VirtualFunc1</span><br></pre></td></tr></table></figure></p>\n<p>我们从上面的对象内存分布图可以知道，父类指针存放在<code>+10h</code>的位置，这样这里的<code>ebp-0Ch</code>就很明白了，它取的是<code>Derive</code>中父类<code>Super</code>对应的<code>this</code>指针。为什么呢？留待以后进一步验证。但是它调用却是<code>Derive::VirtualFunc1</code>，恩，我现在和你有相同的疑问，但是不要问，我也不知道。</p>\n<p><code>F11</code>进去的代码如下：<br><img src=\"/2016/06/15/windbg-windbg-chapter5/VirtualFunc1Code.png\" title=\"VirtualFunc1的代码\"></p>\n<p>这里我直接跳到了<code>this</code>指针保存的后面一句代码。从这里开始计算<code>Super::a + a + c + b;</code>，我把代码摘录下来，并在后面加上注释，方便大家理解：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr [ebp-4], ecx          ; 保存this</span><br><span class=\"line\">mov eax, dword ptr [ebp-4]          ; this放到eax中</span><br><span class=\"line\">mov ecx, dword ptr [eax-10h]        ; eax-10后是Derive的this指针，然后取址得到虚类表</span><br><span class=\"line\">mov edx, dword ptr [ecx+4]          ; 得到Super父类的地址偏移，10h</span><br><span class=\"line\">mov eax, dword ptr [eax+edx-0Ch]    ; 将edx=10h带入到表达式，就是mov eax, dword ptr [eax+4]，也就是Super中的a，保存到了eax</span><br><span class=\"line\"></span><br><span class=\"line\">mov ecx, dword ptr [ebp-4]          ; this放到ecx中</span><br><span class=\"line\">add eax, dword ptr [ecx-0Ch]        ; this-0Ch的地址保存的就是Derive中的a</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-4]          ; this保存到edx中</span><br><span class=\"line\">mov ecx, dword ptr [edx-10h]        ; 虚表类地址</span><br><span class=\"line\">mov edx, dword ptr [ecx+4]          ; Super父类的地址偏移，10h</span><br><span class=\"line\">mov ecx, dword ptr [ebp-4]          ; this指针</span><br><span class=\"line\">add eax, dword ptr [ecx+edx-8]      ; 这里就是add eax, dword ptr [ecx+8]，也就是Super中的c</span><br><span class=\"line\"></span><br><span class=\"line\">mov edx, dword ptr [ebp-4]          ; this指针</span><br><span class=\"line\">add eax, dword ptr [edx-8]          ; Derive中的b</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，Derive中的成员变量获取还是很简单的，但是一旦涉及到父类的成员变量，就要先取到虚基类表，然后在通过各种地址偏移得到目标成员变量。我也不知道为什么要这么吃饱了撑得，可能有它自己的权衡吧，或者我猜在多重继承里面会有作用吧。</p>\n<p>再往下就开始调用从父类继承过来的<code>NormalFunc1</code>函数了，看下给出的汇编指令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, dword ptr [ebp-1Ch]</span><br><span class=\"line\">mov ecx, dword ptr [eax+4]</span><br><span class=\"line\">lea ecx, [ebp+ecx-1Ch]</span><br><span class=\"line\">call HelloWorld2005!Super::NormalFunc1</span><br></pre></td></tr></table></figure></p>\n<p>首先我们直到<code>d</code>在堆栈上的地址其实是<code>ebp-1Ch</code>（从调用构造函数时压入<code>ecx</code>中的值得到），那这里第一步就是先拿到<code>d</code>的指针（即<code>this</code>指针）指向的内容（这里千万要注意，如果是简单的取<code>this</code>指针的话,<code>lea eax, [ebp-1Ch]</code>就行了，这里还做了一层析址的操作）。但是我们这里调用的是父类继承过来的成员函数，所以要传递给该成员函数的<code>this</code>指针必须是指向<code>Super</code>部分的指针。</p>\n<p>好，接着往下看，第二句<code>mov ecx, dword ptr [eax+4]</code>，<code>eax+4</code>保存的是<code>Super</code>在子类中分布的地址偏移。所以<code>ecx</code>理所当然这里就是<code>10h</code>。</p>\n<p>第三句<code>lea ecx, [ebp+ecx-1Ch]</code>，恩，这里<code>ebp-1Ch</code>是对象<code>d</code>的<code>this</code>指针，然后加上偏移量<code>ecx</code>，得到的就是<code>d</code>中<code>Super</code>的内容的地址（好好想一下，有一点绕）。</p>\n<p>最后一句就不用我解释了，很简单，简单的调用啦。</p>\n<p>好了到目前为止第五章已经完全讲完了，大家慢慢消化吧。</p>\n<h2 id=\"写在后面的话\"><a href=\"#写在后面的话\" class=\"headerlink\" title=\"写在后面的话\"></a>写在后面的话</h2><p>我写这个系列完全是在一点都不懂的情况下写的，大家会看到我会做很多猜想、假设，那只是因为我真的也不知道，并不是在卖关子。很多时候都是一边摸索一边写，把自己摸索的过程写下来，然后尽可能地把各种弯路给去掉，但是大家看起来肯定也会觉得有些绕，没办法，因为我也是在摸索阶段。</p>\n<p>我在想等把这个出得差不多了，再出一个和编译器相关的系列文章。然后等把这些坑都填完了之后，就可以去整一整平台相关的东西了。恩恩，谢谢大家的支持。</p>"},{"title":"WinDBG观世界——番外[一]（在C语言中模拟类的虚函数）","date":"2016-05-02T15:08:05.000Z","_content":"\n## 导言\n很多同学在面试的时候都会遇到这个问题吧，请问在C里面我要怎么实现虚函数呢？我记得当时大多数都是死记硬背的答案：通过函数指针就可以了啊。但是本后的机制当时有弄懂么？如果你懂了，那么这一节你就不需要继续往下看了；如果你是个C语言高手，那么你也可以给我这篇文章提一点意见，因为我用C语言的经验至今就三千行代码，而且还是四年前写的。其他同学就跟着我一起来模拟一下在C语言里面究竟如何才能实现C++中的虚函数。\n<!--more-->\n## 我记得是这样运作的\n回顾一下上面两章的内容，首先我们要弄清楚三个问题：\n1. 类的继承是怎么实现的，内存结构如何\n2. 虚函数表存放在类的什么地方\n3. 虚函数表里面存放了什么\n\n如果上面三个问题还没有弄清楚，我建议先把第三四章的内容搞定再来研究这个吧。\n\n我们这里先来模拟继承，看C++下面这段代码：\n```cpp\nclass TestBase\n{\nprivate:\n    int a;\n};\n\nclass TestDerive : public TestBase\n{\nprivate:\n    int b;\n};\n```\n\n首先，在C语言里面并没有`class`关键字，只有通过`struct`来定义结构体。并且也没有`public`等访问控制符，但是正如我以前所说，其实这些访问控制符在实际生成的代码中并没有任何作用，他们的作用只是将代码语义上的错误在编译期抛出来，我们这里也可以忽略。而父类在子类中的布局其实前面一章也说明了，父类对象的内容位于子类对象最开始的地方（这里我们先不考虑多重继承）。我们所需要做的就是将一个父类对象放到子类对象最开始的地方就行了。所以它所对应的C代码如下：\n```C\ntypedef struct tagTestBase\n{\n    int a;\n} TestBase;\n\ntypedef struct tagTestDerive\n{\n    TestBase base;\n    int b;\n} TestDerive;\n```\n\n接着我们需要加的就是构造函数了，考虑下面这段C++代码：\n```cpp\nclass TestBase\n{\npublic:\n    TestBase()\n        : a(10)\n    {\n\n    }\n\nprivate:\n    int a;\n};\n\nclass TestDerive : public TestBase\n{\npublic:\n    TestDerive()\n        : b(12)\n    {\n\n    }\n\nprivate:\n    int b;\n};\n```\n\n但是在C语言里面，其实我们并不能在结构体里面加入函数（你不要和我说你的能加，你先把cpp后缀改成c再说），所以C语言里面的函数都是全局函数，并且提前说明一下，C语言不支持函数的重载。前面我们研究了`this`指针的由来，还记得么？\n1. 将局部变量的堆栈地址存放到`ecx`寄存器\n2. `call`构造函数\n3. 将`ecx`的值存放到`ebp-8`的位置（也出现了`ebp-14h`的情况）\n4. 将`ebp-8`处的值存放到`eax`寄存器中\n\n也就是说，`this`指针也是每次函数调用时，外部传入的一个指针变量。\n接着构造函数会执行下列操作：\n1. 调用父类构造函数\n2. 调用成员变量的初始化器\n3. 执行函数体\n\n那么这里就好办了，我们可以直接写出下面这段代码：\n```c\ntypedef struct tagTestBase\n{\n    int a;\n} TestBase;\n\ntypedef struct tagTestDerive\n{\n    TestBase base;\n    int b;\n} TestDerive;\n\nvoid TestBaseConstructor(TestBase* pThis)\n{\n    pThis->a = 10;\n}\n\nvoid TestDeriveConstructor(TestDerive* pThis)\n{\n    TestBaseConstructor(pThis->base);\n    pThis->b = 12;\n}\n```\n\n那个说我没有判断指针为空的，你给我出去。好了，我们继续。所以这里构造函数已经模拟完成。\n\n下面该清楚本章的主角了：虚函数。考虑下面这个C++代码：\n```cpp\nclass TestBase\n{\npublic:\n    TestBase()\n        : a(10)\n    {\n\n    }\n\npublic:\n    virtual int add(int k)\n    {\n        return a + k;\n    }\n\n    virtual int sub(int k)\n    {\n        return a - k;\n    }\n\nprivate:\n    int a;\n};\n\nclass TestDerive : public TestBase\n{\npublic:\n    TestDerive()\n        : b(12)\n    {\n\n    }\n\npublic:\n    virtual int add(int k)\n    {\n        return b + k;\n    }\n\n    virtual int sub(int k)\n    {\n        return b - k;\n    }\n\nprivate:\n    int b;\n};\n```\n\n因为刚讲虚函数，所以可能大家还没有消化完全，所以这里我大致画一下这两个类的结构图吧，画完之后大家应该就知道如何用C语言实现虚函数了：\n{% asset_img vftables.png 类的内存结构 %}\n\n我来解释下其中的`TestDerive`吧，`TestBase`同样的道理。虚函数表的地址存放在`this`指针指向的头四个字节，我们把这个地址用变量的方式标记为`vftable`吧，那么`vftable`指向的内存，第一个`DWORD`存放了`TestDerive`类中虚函数`add`的地址，第二个`DWORD`存放了`TestDerive`类中虚函数`sub`的地址。\n\n所以对应到C语言中时，因为这些虚函数表的内容和地址在编T译期就已经固定了，我们这里需要模拟的话可以用一个全局的变量来唯一标识这个虚函数表。那么接下来的工作就容易很多了，虽然跨度有一点大，但是看下代码应该也能够很容易理解了：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct tagTestBase\n{\n    void** pVftable;\n    int a;\n} TestBase;\n\ntypedef struct tagTestDerive\n{\n    TestBase base;\n    int b;\n} TestDerive;\n\nvoid** g_pBaseVftable = 0; // base的虚函数表\nvoid** g_pDeriveVftable = 0; // derive的虚函数表\n\nvoid TestBaseConstructor(TestBase* pThis)\n{\n    pThis->pVftable = g_pBaseVftable; //初始化虚函数表\n    pThis->a = 10;\n}\n\nvoid TestDeriveConstructor(TestDerive* pThis)\n{\n    TestBaseConstructor(&pThis->base);\n    pThis->base.pVftable = g_pDeriveVftable; //改写虚函数表地址\n    pThis->b = 12;\n}\n\n// 这个就是前面一章讲到的虚函数的跳转函数\nint CallVirtualAdd_int(TestBase* pThis, int m)\n{\n    typedef int (*FuncType)(TestBase*, int);\n    FuncType func = (FuncType)pThis->pVftable[0];\n    return func(pThis, m);\n}\n\n// 另外一个跳转函数\nint CallVirtualSub_int(TestBase* pThis, int m)\n{\n    typedef int (*FuncType)(TestBase*, int);\n    FuncType func = (FuncType)pThis->pVftable[1];\n    return func(pThis, m);\n}\n\nint TestBaseVirtualAdd_int(TestBase* pThis, int m)\n{\n    return pThis->a + m;\n}\n\nint TestBaseVirtualSub_int(TestBase* pThis, int m)\n{\n    return pThis->a - m;\n}\n\nint TestDeriveVirtualAdd_int(TestDerive* pThis, int m)\n{\n    return pThis->b + m;\n}\n\nint TestDeriveVirtualSub_int(TestDerive* pThis, int m)\n{\n    return pThis->b - m;\n}\n\nvoid InitVftables()\n{\n    // 构造Base的虚函数表\n    g_pBaseVftable = (void**)malloc(sizeof(void*) * 2);\n    g_pBaseVftable[0] = (void*)&TestBaseVirtualAdd_int;\n    g_pBaseVftable[1] = (void*)&TestBaseVirtualSub_int;\n\n    // 构造Derive的虚函数表\n    g_pDeriveVftable = (void**)malloc(sizeof(void*) * 2);\n    g_pDeriveVftable[0] = (void*)TestDeriveVirtualAdd_int;\n    g_pDeriveVftable[1] = (void*)TestDeriveVirtualSub_int;\n}\n\nvoid UninitVftables()\n{\n    free(g_pBaseVftable);\n    free(g_pDeriveVftable);\n}\n\nint main_core(int argc, char** argv)\n{\n    TestDerive d;\n    TestDeriveConstructor(&d);\n    CallVirtualAdd_int((TestBase*)&d, 19);\n\n    return 0;\n}\n\nint main(int argc, char** argv)\n{\n    InitVftables();\n\n    // 这里之所以要弄一个单独的函数，是因为C语言中变量声明必须放在函数的开头\n    // 这里你可以理解为只是为了对称吧\n    main_core(argc, argv);\n\n    UninitVftables();\n\n    return 0;\n}\n```\n\n那么这样做的话肯定不能满足大多数人的需求，因为不可能每次要用到虚函数都要让我写这么一大坨东西。所以这个时候就需要用到C语言中的利器——宏了，但是我这里不打算介绍宏的编写，因为确实好复杂，以后研究出来了放出来给大家好了。\n\n而其实C语言中使用虚函数更好的方式并不是利用虚函数表，因为这样的话，如果有n个虚函数那么我们就需要写相当多个虚函数的call函数，那么针对上面的虚函数调用，C语言中更常用的代码版本如下：\n```c\nstruct tagTestBase;\n\ntypedef int (*AddFuncType)(struct tagTestBase* pThis, int);\ntypedef int (*SubFuncType)(struct tagTestBase* pThis, int);\n\ntypedef struct tagTestBase\n{\n    AddFuncType addFunc;\n    SubFuncType subFunc;\n    int a;\n} TestBase;\n\ntypedef struct tagTestDerive\n{\n    TestBase base;\n    int b;\n} TestDerive;\n\nint TestBaseVirtualAdd_int(TestBase* pThis, int m)\n{\n    return pThis->a + m;\n}\n\nint TestBaseVirtualSub_int(TestBase* pThis, int m)\n{\n    return pThis->a - m;\n}\n\nint TestDeriveVirtualAdd_int(TestDerive* pThis, int m)\n{\n    return pThis->b + m;\n}\n\nint TestDeriveVirtualSub_int(TestDerive* pThis, int m)\n{\n    return pThis->b - m;\n}\n\nvoid TestBaseConstructor(TestBase* pThis)\n{\n    pThis->addFunc = &TestBaseVirtualAdd_int;\n    pThis->subFunc = &TestBaseVirtualSub_int;\n    pThis->a = 10;\n}\n\nvoid TestDeriveConstructor(TestDerive* pThis)\n{\n    TestBaseConstructor(&pThis->base);\n    pThis->base.addFunc = (AddFuncType)&TestDeriveVirtualAdd_int;\n    pThis->base.subFunc = (SubFuncType)&TestDeriveVirtualSub_int;\n    pThis->b = 12;\n}\n\n\nint main_core(int argc, char** argv)\n{\n    TestDerive d;\n    TestDeriveConstructor(&d);\n    d.base.addFunc((TestBase*)&d, 19);\n\n    return 0;\n}\n\nint main(int argc, char** argv)\n{\n    main_core(argc, argv);\n\n    return 0;\n}\n```\n\n那么这次番外篇就这么结束好了，只是一个简单的介绍，不理解也没有大碍。晚安\n","source":"_posts/windbg/windbg-extra1.md","raw":"---\ntitle: WinDBG观世界——番外[一]（在C语言中模拟类的虚函数）\ndate: 2016-05-02 23:08:05\ncategories: windbg\ntags: [windbg,disassembly,c++,c]\n---\n\n## 导言\n很多同学在面试的时候都会遇到这个问题吧，请问在C里面我要怎么实现虚函数呢？我记得当时大多数都是死记硬背的答案：通过函数指针就可以了啊。但是本后的机制当时有弄懂么？如果你懂了，那么这一节你就不需要继续往下看了；如果你是个C语言高手，那么你也可以给我这篇文章提一点意见，因为我用C语言的经验至今就三千行代码，而且还是四年前写的。其他同学就跟着我一起来模拟一下在C语言里面究竟如何才能实现C++中的虚函数。\n<!--more-->\n## 我记得是这样运作的\n回顾一下上面两章的内容，首先我们要弄清楚三个问题：\n1. 类的继承是怎么实现的，内存结构如何\n2. 虚函数表存放在类的什么地方\n3. 虚函数表里面存放了什么\n\n如果上面三个问题还没有弄清楚，我建议先把第三四章的内容搞定再来研究这个吧。\n\n我们这里先来模拟继承，看C++下面这段代码：\n```cpp\nclass TestBase\n{\nprivate:\n    int a;\n};\n\nclass TestDerive : public TestBase\n{\nprivate:\n    int b;\n};\n```\n\n首先，在C语言里面并没有`class`关键字，只有通过`struct`来定义结构体。并且也没有`public`等访问控制符，但是正如我以前所说，其实这些访问控制符在实际生成的代码中并没有任何作用，他们的作用只是将代码语义上的错误在编译期抛出来，我们这里也可以忽略。而父类在子类中的布局其实前面一章也说明了，父类对象的内容位于子类对象最开始的地方（这里我们先不考虑多重继承）。我们所需要做的就是将一个父类对象放到子类对象最开始的地方就行了。所以它所对应的C代码如下：\n```C\ntypedef struct tagTestBase\n{\n    int a;\n} TestBase;\n\ntypedef struct tagTestDerive\n{\n    TestBase base;\n    int b;\n} TestDerive;\n```\n\n接着我们需要加的就是构造函数了，考虑下面这段C++代码：\n```cpp\nclass TestBase\n{\npublic:\n    TestBase()\n        : a(10)\n    {\n\n    }\n\nprivate:\n    int a;\n};\n\nclass TestDerive : public TestBase\n{\npublic:\n    TestDerive()\n        : b(12)\n    {\n\n    }\n\nprivate:\n    int b;\n};\n```\n\n但是在C语言里面，其实我们并不能在结构体里面加入函数（你不要和我说你的能加，你先把cpp后缀改成c再说），所以C语言里面的函数都是全局函数，并且提前说明一下，C语言不支持函数的重载。前面我们研究了`this`指针的由来，还记得么？\n1. 将局部变量的堆栈地址存放到`ecx`寄存器\n2. `call`构造函数\n3. 将`ecx`的值存放到`ebp-8`的位置（也出现了`ebp-14h`的情况）\n4. 将`ebp-8`处的值存放到`eax`寄存器中\n\n也就是说，`this`指针也是每次函数调用时，外部传入的一个指针变量。\n接着构造函数会执行下列操作：\n1. 调用父类构造函数\n2. 调用成员变量的初始化器\n3. 执行函数体\n\n那么这里就好办了，我们可以直接写出下面这段代码：\n```c\ntypedef struct tagTestBase\n{\n    int a;\n} TestBase;\n\ntypedef struct tagTestDerive\n{\n    TestBase base;\n    int b;\n} TestDerive;\n\nvoid TestBaseConstructor(TestBase* pThis)\n{\n    pThis->a = 10;\n}\n\nvoid TestDeriveConstructor(TestDerive* pThis)\n{\n    TestBaseConstructor(pThis->base);\n    pThis->b = 12;\n}\n```\n\n那个说我没有判断指针为空的，你给我出去。好了，我们继续。所以这里构造函数已经模拟完成。\n\n下面该清楚本章的主角了：虚函数。考虑下面这个C++代码：\n```cpp\nclass TestBase\n{\npublic:\n    TestBase()\n        : a(10)\n    {\n\n    }\n\npublic:\n    virtual int add(int k)\n    {\n        return a + k;\n    }\n\n    virtual int sub(int k)\n    {\n        return a - k;\n    }\n\nprivate:\n    int a;\n};\n\nclass TestDerive : public TestBase\n{\npublic:\n    TestDerive()\n        : b(12)\n    {\n\n    }\n\npublic:\n    virtual int add(int k)\n    {\n        return b + k;\n    }\n\n    virtual int sub(int k)\n    {\n        return b - k;\n    }\n\nprivate:\n    int b;\n};\n```\n\n因为刚讲虚函数，所以可能大家还没有消化完全，所以这里我大致画一下这两个类的结构图吧，画完之后大家应该就知道如何用C语言实现虚函数了：\n{% asset_img vftables.png 类的内存结构 %}\n\n我来解释下其中的`TestDerive`吧，`TestBase`同样的道理。虚函数表的地址存放在`this`指针指向的头四个字节，我们把这个地址用变量的方式标记为`vftable`吧，那么`vftable`指向的内存，第一个`DWORD`存放了`TestDerive`类中虚函数`add`的地址，第二个`DWORD`存放了`TestDerive`类中虚函数`sub`的地址。\n\n所以对应到C语言中时，因为这些虚函数表的内容和地址在编T译期就已经固定了，我们这里需要模拟的话可以用一个全局的变量来唯一标识这个虚函数表。那么接下来的工作就容易很多了，虽然跨度有一点大，但是看下代码应该也能够很容易理解了：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct tagTestBase\n{\n    void** pVftable;\n    int a;\n} TestBase;\n\ntypedef struct tagTestDerive\n{\n    TestBase base;\n    int b;\n} TestDerive;\n\nvoid** g_pBaseVftable = 0; // base的虚函数表\nvoid** g_pDeriveVftable = 0; // derive的虚函数表\n\nvoid TestBaseConstructor(TestBase* pThis)\n{\n    pThis->pVftable = g_pBaseVftable; //初始化虚函数表\n    pThis->a = 10;\n}\n\nvoid TestDeriveConstructor(TestDerive* pThis)\n{\n    TestBaseConstructor(&pThis->base);\n    pThis->base.pVftable = g_pDeriveVftable; //改写虚函数表地址\n    pThis->b = 12;\n}\n\n// 这个就是前面一章讲到的虚函数的跳转函数\nint CallVirtualAdd_int(TestBase* pThis, int m)\n{\n    typedef int (*FuncType)(TestBase*, int);\n    FuncType func = (FuncType)pThis->pVftable[0];\n    return func(pThis, m);\n}\n\n// 另外一个跳转函数\nint CallVirtualSub_int(TestBase* pThis, int m)\n{\n    typedef int (*FuncType)(TestBase*, int);\n    FuncType func = (FuncType)pThis->pVftable[1];\n    return func(pThis, m);\n}\n\nint TestBaseVirtualAdd_int(TestBase* pThis, int m)\n{\n    return pThis->a + m;\n}\n\nint TestBaseVirtualSub_int(TestBase* pThis, int m)\n{\n    return pThis->a - m;\n}\n\nint TestDeriveVirtualAdd_int(TestDerive* pThis, int m)\n{\n    return pThis->b + m;\n}\n\nint TestDeriveVirtualSub_int(TestDerive* pThis, int m)\n{\n    return pThis->b - m;\n}\n\nvoid InitVftables()\n{\n    // 构造Base的虚函数表\n    g_pBaseVftable = (void**)malloc(sizeof(void*) * 2);\n    g_pBaseVftable[0] = (void*)&TestBaseVirtualAdd_int;\n    g_pBaseVftable[1] = (void*)&TestBaseVirtualSub_int;\n\n    // 构造Derive的虚函数表\n    g_pDeriveVftable = (void**)malloc(sizeof(void*) * 2);\n    g_pDeriveVftable[0] = (void*)TestDeriveVirtualAdd_int;\n    g_pDeriveVftable[1] = (void*)TestDeriveVirtualSub_int;\n}\n\nvoid UninitVftables()\n{\n    free(g_pBaseVftable);\n    free(g_pDeriveVftable);\n}\n\nint main_core(int argc, char** argv)\n{\n    TestDerive d;\n    TestDeriveConstructor(&d);\n    CallVirtualAdd_int((TestBase*)&d, 19);\n\n    return 0;\n}\n\nint main(int argc, char** argv)\n{\n    InitVftables();\n\n    // 这里之所以要弄一个单独的函数，是因为C语言中变量声明必须放在函数的开头\n    // 这里你可以理解为只是为了对称吧\n    main_core(argc, argv);\n\n    UninitVftables();\n\n    return 0;\n}\n```\n\n那么这样做的话肯定不能满足大多数人的需求，因为不可能每次要用到虚函数都要让我写这么一大坨东西。所以这个时候就需要用到C语言中的利器——宏了，但是我这里不打算介绍宏的编写，因为确实好复杂，以后研究出来了放出来给大家好了。\n\n而其实C语言中使用虚函数更好的方式并不是利用虚函数表，因为这样的话，如果有n个虚函数那么我们就需要写相当多个虚函数的call函数，那么针对上面的虚函数调用，C语言中更常用的代码版本如下：\n```c\nstruct tagTestBase;\n\ntypedef int (*AddFuncType)(struct tagTestBase* pThis, int);\ntypedef int (*SubFuncType)(struct tagTestBase* pThis, int);\n\ntypedef struct tagTestBase\n{\n    AddFuncType addFunc;\n    SubFuncType subFunc;\n    int a;\n} TestBase;\n\ntypedef struct tagTestDerive\n{\n    TestBase base;\n    int b;\n} TestDerive;\n\nint TestBaseVirtualAdd_int(TestBase* pThis, int m)\n{\n    return pThis->a + m;\n}\n\nint TestBaseVirtualSub_int(TestBase* pThis, int m)\n{\n    return pThis->a - m;\n}\n\nint TestDeriveVirtualAdd_int(TestDerive* pThis, int m)\n{\n    return pThis->b + m;\n}\n\nint TestDeriveVirtualSub_int(TestDerive* pThis, int m)\n{\n    return pThis->b - m;\n}\n\nvoid TestBaseConstructor(TestBase* pThis)\n{\n    pThis->addFunc = &TestBaseVirtualAdd_int;\n    pThis->subFunc = &TestBaseVirtualSub_int;\n    pThis->a = 10;\n}\n\nvoid TestDeriveConstructor(TestDerive* pThis)\n{\n    TestBaseConstructor(&pThis->base);\n    pThis->base.addFunc = (AddFuncType)&TestDeriveVirtualAdd_int;\n    pThis->base.subFunc = (SubFuncType)&TestDeriveVirtualSub_int;\n    pThis->b = 12;\n}\n\n\nint main_core(int argc, char** argv)\n{\n    TestDerive d;\n    TestDeriveConstructor(&d);\n    d.base.addFunc((TestBase*)&d, 19);\n\n    return 0;\n}\n\nint main(int argc, char** argv)\n{\n    main_core(argc, argv);\n\n    return 0;\n}\n```\n\n那么这次番外篇就这么结束好了，只是一个简单的介绍，不理解也没有大碍。晚安\n","slug":"windbg-windbg-extra1","published":1,"updated":"2018-06-25T11:14:49.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjivnhtpc001s2gusk70vz3lq","content":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>很多同学在面试的时候都会遇到这个问题吧，请问在C里面我要怎么实现虚函数呢？我记得当时大多数都是死记硬背的答案：通过函数指针就可以了啊。但是本后的机制当时有弄懂么？如果你懂了，那么这一节你就不需要继续往下看了；如果你是个C语言高手，那么你也可以给我这篇文章提一点意见，因为我用C语言的经验至今就三千行代码，而且还是四年前写的。其他同学就跟着我一起来模拟一下在C语言里面究竟如何才能实现C++中的虚函数。<br><a id=\"more\"></a></p>\n<h2 id=\"我记得是这样运作的\"><a href=\"#我记得是这样运作的\" class=\"headerlink\" title=\"我记得是这样运作的\"></a>我记得是这样运作的</h2><p>回顾一下上面两章的内容，首先我们要弄清楚三个问题：</p>\n<ol>\n<li>类的继承是怎么实现的，内存结构如何</li>\n<li>虚函数表存放在类的什么地方</li>\n<li>虚函数表里面存放了什么</li>\n</ol>\n<p>如果上面三个问题还没有弄清楚，我建议先把第三四章的内容搞定再来研究这个吧。</p>\n<p>我们这里先来模拟继承，看C++下面这段代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDerive</span> :</span> <span class=\"keyword\">public</span> TestBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>首先，在C语言里面并没有<code>class</code>关键字，只有通过<code>struct</code>来定义结构体。并且也没有<code>public</code>等访问控制符，但是正如我以前所说，其实这些访问控制符在实际生成的代码中并没有任何作用，他们的作用只是将代码语义上的错误在编译期抛出来，我们这里也可以忽略。而父类在子类中的布局其实前面一章也说明了，父类对象的内容位于子类对象最开始的地方（这里我们先不考虑多重继承）。我们所需要做的就是将一个父类对象放到子类对象最开始的地方就行了。所以它所对应的C代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125; TestBase;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestDerive</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    TestBase base;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125; TestDerive;</span><br></pre></td></tr></table></figure></p>\n<p>接着我们需要加的就是构造函数了，考虑下面这段C++代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestBase()</span><br><span class=\"line\">        : a(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDerive</span> :</span> <span class=\"keyword\">public</span> TestBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestDerive()</span><br><span class=\"line\">        : b(<span class=\"number\">12</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>但是在C语言里面，其实我们并不能在结构体里面加入函数（你不要和我说你的能加，你先把cpp后缀改成c再说），所以C语言里面的函数都是全局函数，并且提前说明一下，C语言不支持函数的重载。前面我们研究了<code>this</code>指针的由来，还记得么？</p>\n<ol>\n<li>将局部变量的堆栈地址存放到<code>ecx</code>寄存器</li>\n<li><code>call</code>构造函数</li>\n<li>将<code>ecx</code>的值存放到<code>ebp-8</code>的位置（也出现了<code>ebp-14h</code>的情况）</li>\n<li>将<code>ebp-8</code>处的值存放到<code>eax</code>寄存器中</li>\n</ol>\n<p>也就是说，<code>this</code>指针也是每次函数调用时，外部传入的一个指针变量。<br>接着构造函数会执行下列操作：</p>\n<ol>\n<li>调用父类构造函数</li>\n<li>调用成员变量的初始化器</li>\n<li>执行函数体</li>\n</ol>\n<p>那么这里就好办了，我们可以直接写出下面这段代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125; TestBase;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestDerive</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    TestBase base;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125; TestDerive;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestBaseConstructor</span><span class=\"params\">(TestBase* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pThis-&gt;a = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestDeriveConstructor</span><span class=\"params\">(TestDerive* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestBaseConstructor(pThis-&gt;base);</span><br><span class=\"line\">    pThis-&gt;b = <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那个说我没有判断指针为空的，你给我出去。好了，我们继续。所以这里构造函数已经模拟完成。</p>\n<p>下面该清楚本章的主角了：虚函数。考虑下面这个C++代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestBase()</span><br><span class=\"line\">        : a(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">sub</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a - k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDerive</span> :</span> <span class=\"keyword\">public</span> TestBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestDerive()</span><br><span class=\"line\">        : b(<span class=\"number\">12</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b + k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">sub</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b - k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>因为刚讲虚函数，所以可能大家还没有消化完全，所以这里我大致画一下这两个类的结构图吧，画完之后大家应该就知道如何用C语言实现虚函数了：<br><img src=\"/2016/05/02/windbg-windbg-extra1/vftables.png\" title=\"类的内存结构\"></p>\n<p>我来解释下其中的<code>TestDerive</code>吧，<code>TestBase</code>同样的道理。虚函数表的地址存放在<code>this</code>指针指向的头四个字节，我们把这个地址用变量的方式标记为<code>vftable</code>吧，那么<code>vftable</code>指向的内存，第一个<code>DWORD</code>存放了<code>TestDerive</code>类中虚函数<code>add</code>的地址，第二个<code>DWORD</code>存放了<code>TestDerive</code>类中虚函数<code>sub</code>的地址。</p>\n<p>所以对应到C语言中时，因为这些虚函数表的内容和地址在编T译期就已经固定了，我们这里需要模拟的话可以用一个全局的变量来唯一标识这个虚函数表。那么接下来的工作就容易很多了，虽然跨度有一点大，但是看下代码应该也能够很容易理解了：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>** pVftable;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125; TestBase;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestDerive</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    TestBase base;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125; TestDerive;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span>** g_pBaseVftable = <span class=\"number\">0</span>; <span class=\"comment\">// base的虚函数表</span></span><br><span class=\"line\"><span class=\"keyword\">void</span>** g_pDeriveVftable = <span class=\"number\">0</span>; <span class=\"comment\">// derive的虚函数表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestBaseConstructor</span><span class=\"params\">(TestBase* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pThis-&gt;pVftable = g_pBaseVftable; <span class=\"comment\">//初始化虚函数表</span></span><br><span class=\"line\">    pThis-&gt;a = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestDeriveConstructor</span><span class=\"params\">(TestDerive* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestBaseConstructor(&amp;pThis-&gt;base);</span><br><span class=\"line\">    pThis-&gt;base.pVftable = g_pDeriveVftable; <span class=\"comment\">//改写虚函数表地址</span></span><br><span class=\"line\">    pThis-&gt;b = <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个就是前面一章讲到的虚函数的跳转函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CallVirtualAdd_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*FuncType)</span><span class=\"params\">(TestBase*, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\">    FuncType func = (FuncType)pThis-&gt;pVftable[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(pThis, m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另外一个跳转函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CallVirtualSub_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*FuncType)</span><span class=\"params\">(TestBase*, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\">    FuncType func = (FuncType)pThis-&gt;pVftable[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(pThis, m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestBaseVirtualAdd_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;a + m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestBaseVirtualSub_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;a - m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestDeriveVirtualAdd_int</span><span class=\"params\">(TestDerive* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;b + m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestDeriveVirtualSub_int</span><span class=\"params\">(TestDerive* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;b - m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitVftables</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造Base的虚函数表</span></span><br><span class=\"line\">    g_pBaseVftable = (<span class=\"keyword\">void</span>**)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>*) * <span class=\"number\">2</span>);</span><br><span class=\"line\">    g_pBaseVftable[<span class=\"number\">0</span>] = (<span class=\"keyword\">void</span>*)&amp;TestBaseVirtualAdd_int;</span><br><span class=\"line\">    g_pBaseVftable[<span class=\"number\">1</span>] = (<span class=\"keyword\">void</span>*)&amp;TestBaseVirtualSub_int;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造Derive的虚函数表</span></span><br><span class=\"line\">    g_pDeriveVftable = (<span class=\"keyword\">void</span>**)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>*) * <span class=\"number\">2</span>);</span><br><span class=\"line\">    g_pDeriveVftable[<span class=\"number\">0</span>] = (<span class=\"keyword\">void</span>*)TestDeriveVirtualAdd_int;</span><br><span class=\"line\">    g_pDeriveVftable[<span class=\"number\">1</span>] = (<span class=\"keyword\">void</span>*)TestDeriveVirtualSub_int;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UninitVftables</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(g_pBaseVftable);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(g_pDeriveVftable);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main_core</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestDerive d;</span><br><span class=\"line\">    TestDeriveConstructor(&amp;d);</span><br><span class=\"line\">    CallVirtualAdd_int((TestBase*)&amp;d, <span class=\"number\">19</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    InitVftables();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里之所以要弄一个单独的函数，是因为C语言中变量声明必须放在函数的开头</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里你可以理解为只是为了对称吧</span></span><br><span class=\"line\">    main_core(argc, argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    UninitVftables();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么这样做的话肯定不能满足大多数人的需求，因为不可能每次要用到虚函数都要让我写这么一大坨东西。所以这个时候就需要用到C语言中的利器——宏了，但是我这里不打算介绍宏的编写，因为确实好复杂，以后研究出来了放出来给大家好了。</p>\n<p>而其实C语言中使用虚函数更好的方式并不是利用虚函数表，因为这样的话，如果有n个虚函数那么我们就需要写相当多个虚函数的call函数，那么针对上面的虚函数调用，C语言中更常用的代码版本如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestBase</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*AddFuncType)</span><span class=\"params\">(struct tagTestBase* pThis, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*SubFuncType)</span><span class=\"params\">(struct tagTestBase* pThis, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    AddFuncType addFunc;</span><br><span class=\"line\">    SubFuncType subFunc;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125; TestBase;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestDerive</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    TestBase base;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125; TestDerive;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestBaseVirtualAdd_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;a + m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestBaseVirtualSub_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;a - m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestDeriveVirtualAdd_int</span><span class=\"params\">(TestDerive* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;b + m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestDeriveVirtualSub_int</span><span class=\"params\">(TestDerive* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;b - m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestBaseConstructor</span><span class=\"params\">(TestBase* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pThis-&gt;addFunc = &amp;TestBaseVirtualAdd_int;</span><br><span class=\"line\">    pThis-&gt;subFunc = &amp;TestBaseVirtualSub_int;</span><br><span class=\"line\">    pThis-&gt;a = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestDeriveConstructor</span><span class=\"params\">(TestDerive* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestBaseConstructor(&amp;pThis-&gt;base);</span><br><span class=\"line\">    pThis-&gt;base.addFunc = (AddFuncType)&amp;TestDeriveVirtualAdd_int;</span><br><span class=\"line\">    pThis-&gt;base.subFunc = (SubFuncType)&amp;TestDeriveVirtualSub_int;</span><br><span class=\"line\">    pThis-&gt;b = <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main_core</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestDerive d;</span><br><span class=\"line\">    TestDeriveConstructor(&amp;d);</span><br><span class=\"line\">    d.base.addFunc((TestBase*)&amp;d, <span class=\"number\">19</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    main_core(argc, argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么这次番外篇就这么结束好了，只是一个简单的介绍，不理解也没有大碍。晚安</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"导言\"><a href=\"#导言\" class=\"headerlink\" title=\"导言\"></a>导言</h2><p>很多同学在面试的时候都会遇到这个问题吧，请问在C里面我要怎么实现虚函数呢？我记得当时大多数都是死记硬背的答案：通过函数指针就可以了啊。但是本后的机制当时有弄懂么？如果你懂了，那么这一节你就不需要继续往下看了；如果你是个C语言高手，那么你也可以给我这篇文章提一点意见，因为我用C语言的经验至今就三千行代码，而且还是四年前写的。其他同学就跟着我一起来模拟一下在C语言里面究竟如何才能实现C++中的虚函数。<br>","more":"</p>\n<h2 id=\"我记得是这样运作的\"><a href=\"#我记得是这样运作的\" class=\"headerlink\" title=\"我记得是这样运作的\"></a>我记得是这样运作的</h2><p>回顾一下上面两章的内容，首先我们要弄清楚三个问题：</p>\n<ol>\n<li>类的继承是怎么实现的，内存结构如何</li>\n<li>虚函数表存放在类的什么地方</li>\n<li>虚函数表里面存放了什么</li>\n</ol>\n<p>如果上面三个问题还没有弄清楚，我建议先把第三四章的内容搞定再来研究这个吧。</p>\n<p>我们这里先来模拟继承，看C++下面这段代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDerive</span> :</span> <span class=\"keyword\">public</span> TestBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>首先，在C语言里面并没有<code>class</code>关键字，只有通过<code>struct</code>来定义结构体。并且也没有<code>public</code>等访问控制符，但是正如我以前所说，其实这些访问控制符在实际生成的代码中并没有任何作用，他们的作用只是将代码语义上的错误在编译期抛出来，我们这里也可以忽略。而父类在子类中的布局其实前面一章也说明了，父类对象的内容位于子类对象最开始的地方（这里我们先不考虑多重继承）。我们所需要做的就是将一个父类对象放到子类对象最开始的地方就行了。所以它所对应的C代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125; TestBase;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestDerive</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    TestBase base;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125; TestDerive;</span><br></pre></td></tr></table></figure></p>\n<p>接着我们需要加的就是构造函数了，考虑下面这段C++代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestBase()</span><br><span class=\"line\">        : a(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDerive</span> :</span> <span class=\"keyword\">public</span> TestBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestDerive()</span><br><span class=\"line\">        : b(<span class=\"number\">12</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>但是在C语言里面，其实我们并不能在结构体里面加入函数（你不要和我说你的能加，你先把cpp后缀改成c再说），所以C语言里面的函数都是全局函数，并且提前说明一下，C语言不支持函数的重载。前面我们研究了<code>this</code>指针的由来，还记得么？</p>\n<ol>\n<li>将局部变量的堆栈地址存放到<code>ecx</code>寄存器</li>\n<li><code>call</code>构造函数</li>\n<li>将<code>ecx</code>的值存放到<code>ebp-8</code>的位置（也出现了<code>ebp-14h</code>的情况）</li>\n<li>将<code>ebp-8</code>处的值存放到<code>eax</code>寄存器中</li>\n</ol>\n<p>也就是说，<code>this</code>指针也是每次函数调用时，外部传入的一个指针变量。<br>接着构造函数会执行下列操作：</p>\n<ol>\n<li>调用父类构造函数</li>\n<li>调用成员变量的初始化器</li>\n<li>执行函数体</li>\n</ol>\n<p>那么这里就好办了，我们可以直接写出下面这段代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125; TestBase;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestDerive</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    TestBase base;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125; TestDerive;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestBaseConstructor</span><span class=\"params\">(TestBase* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pThis-&gt;a = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestDeriveConstructor</span><span class=\"params\">(TestDerive* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestBaseConstructor(pThis-&gt;base);</span><br><span class=\"line\">    pThis-&gt;b = <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那个说我没有判断指针为空的，你给我出去。好了，我们继续。所以这里构造函数已经模拟完成。</p>\n<p>下面该清楚本章的主角了：虚函数。考虑下面这个C++代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestBase()</span><br><span class=\"line\">        : a(<span class=\"number\">10</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">sub</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a - k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestDerive</span> :</span> <span class=\"keyword\">public</span> TestBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TestDerive()</span><br><span class=\"line\">        : b(<span class=\"number\">12</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b + k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">int</span> <span class=\"title\">sub</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b - k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>因为刚讲虚函数，所以可能大家还没有消化完全，所以这里我大致画一下这两个类的结构图吧，画完之后大家应该就知道如何用C语言实现虚函数了：<br><img src=\"/2016/05/02/windbg-windbg-extra1/vftables.png\" title=\"类的内存结构\"></p>\n<p>我来解释下其中的<code>TestDerive</code>吧，<code>TestBase</code>同样的道理。虚函数表的地址存放在<code>this</code>指针指向的头四个字节，我们把这个地址用变量的方式标记为<code>vftable</code>吧，那么<code>vftable</code>指向的内存，第一个<code>DWORD</code>存放了<code>TestDerive</code>类中虚函数<code>add</code>的地址，第二个<code>DWORD</code>存放了<code>TestDerive</code>类中虚函数<code>sub</code>的地址。</p>\n<p>所以对应到C语言中时，因为这些虚函数表的内容和地址在编T译期就已经固定了，我们这里需要模拟的话可以用一个全局的变量来唯一标识这个虚函数表。那么接下来的工作就容易很多了，虽然跨度有一点大，但是看下代码应该也能够很容易理解了：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span>** pVftable;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125; TestBase;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestDerive</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    TestBase base;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125; TestDerive;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span>** g_pBaseVftable = <span class=\"number\">0</span>; <span class=\"comment\">// base的虚函数表</span></span><br><span class=\"line\"><span class=\"keyword\">void</span>** g_pDeriveVftable = <span class=\"number\">0</span>; <span class=\"comment\">// derive的虚函数表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestBaseConstructor</span><span class=\"params\">(TestBase* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pThis-&gt;pVftable = g_pBaseVftable; <span class=\"comment\">//初始化虚函数表</span></span><br><span class=\"line\">    pThis-&gt;a = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestDeriveConstructor</span><span class=\"params\">(TestDerive* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestBaseConstructor(&amp;pThis-&gt;base);</span><br><span class=\"line\">    pThis-&gt;base.pVftable = g_pDeriveVftable; <span class=\"comment\">//改写虚函数表地址</span></span><br><span class=\"line\">    pThis-&gt;b = <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个就是前面一章讲到的虚函数的跳转函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CallVirtualAdd_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*FuncType)</span><span class=\"params\">(TestBase*, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\">    FuncType func = (FuncType)pThis-&gt;pVftable[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(pThis, m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另外一个跳转函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CallVirtualSub_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*FuncType)</span><span class=\"params\">(TestBase*, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\">    FuncType func = (FuncType)pThis-&gt;pVftable[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(pThis, m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestBaseVirtualAdd_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;a + m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestBaseVirtualSub_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;a - m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestDeriveVirtualAdd_int</span><span class=\"params\">(TestDerive* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;b + m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestDeriveVirtualSub_int</span><span class=\"params\">(TestDerive* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;b - m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">InitVftables</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造Base的虚函数表</span></span><br><span class=\"line\">    g_pBaseVftable = (<span class=\"keyword\">void</span>**)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>*) * <span class=\"number\">2</span>);</span><br><span class=\"line\">    g_pBaseVftable[<span class=\"number\">0</span>] = (<span class=\"keyword\">void</span>*)&amp;TestBaseVirtualAdd_int;</span><br><span class=\"line\">    g_pBaseVftable[<span class=\"number\">1</span>] = (<span class=\"keyword\">void</span>*)&amp;TestBaseVirtualSub_int;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造Derive的虚函数表</span></span><br><span class=\"line\">    g_pDeriveVftable = (<span class=\"keyword\">void</span>**)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>*) * <span class=\"number\">2</span>);</span><br><span class=\"line\">    g_pDeriveVftable[<span class=\"number\">0</span>] = (<span class=\"keyword\">void</span>*)TestDeriveVirtualAdd_int;</span><br><span class=\"line\">    g_pDeriveVftable[<span class=\"number\">1</span>] = (<span class=\"keyword\">void</span>*)TestDeriveVirtualSub_int;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UninitVftables</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(g_pBaseVftable);</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(g_pDeriveVftable);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main_core</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestDerive d;</span><br><span class=\"line\">    TestDeriveConstructor(&amp;d);</span><br><span class=\"line\">    CallVirtualAdd_int((TestBase*)&amp;d, <span class=\"number\">19</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    InitVftables();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里之所以要弄一个单独的函数，是因为C语言中变量声明必须放在函数的开头</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里你可以理解为只是为了对称吧</span></span><br><span class=\"line\">    main_core(argc, argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    UninitVftables();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么这样做的话肯定不能满足大多数人的需求，因为不可能每次要用到虚函数都要让我写这么一大坨东西。所以这个时候就需要用到C语言中的利器——宏了，但是我这里不打算介绍宏的编写，因为确实好复杂，以后研究出来了放出来给大家好了。</p>\n<p>而其实C语言中使用虚函数更好的方式并不是利用虚函数表，因为这样的话，如果有n个虚函数那么我们就需要写相当多个虚函数的call函数，那么针对上面的虚函数调用，C语言中更常用的代码版本如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestBase</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*AddFuncType)</span><span class=\"params\">(struct tagTestBase* pThis, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*SubFuncType)</span><span class=\"params\">(struct tagTestBase* pThis, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestBase</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    AddFuncType addFunc;</span><br><span class=\"line\">    SubFuncType subFunc;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">&#125; TestBase;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tagTestDerive</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    TestBase base;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125; TestDerive;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestBaseVirtualAdd_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;a + m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestBaseVirtualSub_int</span><span class=\"params\">(TestBase* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;a - m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestDeriveVirtualAdd_int</span><span class=\"params\">(TestDerive* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;b + m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">TestDeriveVirtualSub_int</span><span class=\"params\">(TestDerive* pThis, <span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pThis-&gt;b - m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestBaseConstructor</span><span class=\"params\">(TestBase* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pThis-&gt;addFunc = &amp;TestBaseVirtualAdd_int;</span><br><span class=\"line\">    pThis-&gt;subFunc = &amp;TestBaseVirtualSub_int;</span><br><span class=\"line\">    pThis-&gt;a = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TestDeriveConstructor</span><span class=\"params\">(TestDerive* pThis)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestBaseConstructor(&amp;pThis-&gt;base);</span><br><span class=\"line\">    pThis-&gt;base.addFunc = (AddFuncType)&amp;TestDeriveVirtualAdd_int;</span><br><span class=\"line\">    pThis-&gt;base.subFunc = (SubFuncType)&amp;TestDeriveVirtualSub_int;</span><br><span class=\"line\">    pThis-&gt;b = <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main_core</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    TestDerive d;</span><br><span class=\"line\">    TestDeriveConstructor(&amp;d);</span><br><span class=\"line\">    d.base.addFunc((TestBase*)&amp;d, <span class=\"number\">19</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    main_core(argc, argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>那么这次番外篇就这么结束好了，只是一个简单的介绍，不理解也没有大碍。晚安</p>"}],"PostAsset":[{"_id":"source/_posts/hexo/2016-06-20-build-blog-with-hexo/getrepositoryaddress.png","slug":"getrepositoryaddress.png","post":"cjivnhtn200032gusk1yg1mmp","modified":1,"renderable":0},{"_id":"source/_posts/inject/2016-07-14-remote-inject/explorer_kernel32_address.jpg","slug":"explorer_kernel32_address.jpg","post":"cjivnhtmy00022gus2eqqovmz","modified":1,"renderable":0},{"_id":"source/_posts/windbg/windbg-chapter1/breakpoint.png","slug":"breakpoint.png","post":"cjivnhtnc00082guslinn7z4f","modified":1,"renderable":0},{"_id":"source/_posts/windbg/windbg-chapter1/sourcemode.png","slug":"sourcemode.png","post":"cjivnhtnc00082guslinn7z4f","modified":1,"renderable":0},{"_id":"source/_posts/windbg/windbg-chapter3/ThePlaceWhereCallMain.png","slug":"ThePlaceWhereCallMain.png","post":"cjivnhtne000b2gusea2baouz","modified":1,"renderable":0},{"_id":"source/_posts/inject/2016-07-14-remote-inject/devenv_kernel32_address.jpg","slug":"devenv_kernel32_address.jpg","post":"cjivnhtmy00022gus2eqqovmz","modified":1,"renderable":0},{"_id":"source/_posts/inject/2016-07-14-remote-inject/inject_result.jpg","post":"cjivnhtmy00022gus2eqqovmz","slug":"inject_result.jpg","modified":1,"renderable":1},{"_id":"source/_posts/hexo/2016-06-20-build-blog-with-hexo/generatesshkey.png","post":"cjivnhtn200032gusk1yg1mmp","slug":"generatesshkey.png","modified":1,"renderable":1},{"_id":"source/_posts/hexo/2016-06-20-build-blog-with-hexo/newrepository.png","post":"cjivnhtn200032gusk1yg1mmp","slug":"newrepository.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/AfterCallTestReturn.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"AfterCallTestReturn.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/AfterCallTestReturnStack.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"AfterCallTestReturnStack.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/AfterTestReturnReturn.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"AfterTestReturnReturn.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/BeforeCallTestReturn.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"BeforeCallTestReturn.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/BeforeCallTestReturnStack.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"BeforeCallTestReturnStack.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/CallTestConstReference.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"CallTestConstReference.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/CallTestPointer.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"CallTestPointer.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/CallTestReference.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"CallTestReference.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/CallTestValue.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"CallTestValue.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/InitSimple.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"InitSimple.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/SimpleStructMemory.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"SimpleStructMemory.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/TestReturnAssembly.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"TestReturnAssembly.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/begin.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"begin.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/ddebp-14hL4.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"ddebp-14hL4.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/ddebp-2ChL4.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"ddebp-2ChL4.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter2/dtHelloWorld2005Simple.png","post":"cjivnhtnh000c2gus6uvwuw1m","slug":"dtHelloWorld2005Simple.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/aftera10.png","post":"cjivnhtnc00082guslinn7z4f","slug":"aftera10.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/afterda30.png","post":"cjivnhtnc00082guslinn7z4f","slug":"afterda30.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/afterrepstos.png","post":"cjivnhtnc00082guslinn7z4f","slug":"afterrepstos.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/afterrepstosmem.png","post":"cjivnhtnc00082guslinn7z4f","slug":"afterrepstosmem.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/callstack.png","post":"cjivnhtnc00082guslinn7z4f","slug":"callstack.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/callstackstatus.png","post":"cjivnhtnc00082guslinn7z4f","slug":"callstackstatus.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/checkesp.png","post":"cjivnhtnc00082guslinn7z4f","slug":"checkesp.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/disassembly.png","post":"cjivnhtnc00082guslinn7z4f","slug":"disassembly.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/pushebp.png","post":"cjivnhtnc00082guslinn7z4f","slug":"pushebp.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/pushebxesiedi.png","post":"cjivnhtnc00082guslinn7z4f","slug":"pushebxesiedi.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/pushresult.png","post":"cjivnhtnc00082guslinn7z4f","slug":"pushresult.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/registers.png","post":"cjivnhtnc00082guslinn7z4f","slug":"registers.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/runexe.png","post":"cjivnhtnc00082guslinn7z4f","slug":"runexe.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/stackmemory.png","post":"cjivnhtnc00082guslinn7z4f","slug":"stackmemory.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter1/testfuncsource.png","post":"cjivnhtnc00082guslinn7z4f","slug":"testfuncsource.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/ActualValueForCmp.png","post":"cjivnhtne000b2gusea2baouz","slug":"ActualValueForCmp.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/AfterCmpOperation.png","post":"cjivnhtne000b2gusea2baouz","slug":"AfterCmpOperation.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/AllRegisters.png","post":"cjivnhtne000b2gusea2baouz","slug":"AllRegisters.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/CmpResult.png","post":"cjivnhtne000b2gusea2baouz","slug":"CmpResult.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/DtSimpleClass.png","post":"cjivnhtne000b2gusea2baouz","slug":"DtSimpleClass.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/DumpHelloWorldHeaders.png","post":"cjivnhtne000b2gusea2baouz","slug":"DumpHelloWorldHeaders.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/DynamicInitializerForK.png","post":"cjivnhtne000b2gusea2baouz","slug":"DynamicInitializerForK.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/GlobalVarCallStack.png","post":"cjivnhtne000b2gusea2baouz","slug":"GlobalVarCallStack.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/HelloWorld2005PreCppInit.png","post":"cjivnhtne000b2gusea2baouz","slug":"HelloWorld2005PreCppInit.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/HitConstructorBreakPoint.png","post":"cjivnhtne000b2gusea2baouz","slug":"HitConstructorBreakPoint.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/InInitTermFunction.png","post":"cjivnhtne000b2gusea2baouz","slug":"InInitTermFunction.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/InitTermJmpBackToFuncHead.png","post":"cjivnhtne000b2gusea2baouz","slug":"InitTermJmpBackToFuncHead.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/MainCallTestStatic.png","post":"cjivnhtne000b2gusea2baouz","slug":"MainCallTestStatic.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/MainCallTestVirtual.png","post":"cjivnhtne000b2gusea2baouz","slug":"MainCallTestVirtual.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/MainCompareTestAndTestConst.png","post":"cjivnhtne000b2gusea2baouz","slug":"MainCompareTestAndTestConst.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/MainSimpleClassJ=233.png","post":"cjivnhtne000b2gusea2baouz","slug":"MainSimpleClassJ=233.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/MainSimpleClassJ=233Stack.png","post":"cjivnhtne000b2gusea2baouz","slug":"MainSimpleClassJ=233Stack.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/PreCppInitDtValueResult.png","post":"cjivnhtne000b2gusea2baouz","slug":"PreCppInitDtValueResult.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/PreCppInitDvResult.png","post":"cjivnhtne000b2gusea2baouz","slug":"PreCppInitDvResult.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/SetConstructorBreakPoint.png","post":"cjivnhtne000b2gusea2baouz","slug":"SetConstructorBreakPoint.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/SimpleClassConstructorCode.png","post":"cjivnhtne000b2gusea2baouz","slug":"SimpleClassConstructorCode.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/SimpleClassCopyConstructorCode.png","post":"cjivnhtne000b2gusea2baouz","slug":"SimpleClassCopyConstructorCode.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/SimpleClassMemoryMap.png","post":"cjivnhtne000b2gusea2baouz","slug":"SimpleClassMemoryMap.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/SimpleClassThisPointToMemory.png","post":"cjivnhtne000b2gusea2baouz","slug":"SimpleClassThisPointToMemory.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/TestDeriveCtorBeforeBaseCtorStackMemory.png","post":"cjivnhtne000b2gusea2baouz","slug":"TestDeriveCtorBeforeBaseCtorStackMemory.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/da0040412c.png","post":"cjivnhtne000b2gusea2baouz","slug":"da0040412c.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/dd00406000.png","post":"cjivnhtne000b2gusea2baouz","slug":"dd00406000.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/lmvmHelloWorld2005.png","post":"cjivnhtne000b2gusea2baouz","slug":"lmvmHelloWorld2005.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter3/s-saHelloWorld2005+4000L115C.png","post":"cjivnhtne000b2gusea2baouz","slug":"s-saHelloWorld2005+4000L115C.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-extra1/vftables.png","post":"cjivnhtpc001s2gusk70vz3lq","slug":"vftables.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/VirtualFunc1Code.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"VirtualFunc1Code.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/beforedconstructorstack.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"beforedconstructorstack.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/contentofecx.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"contentofecx.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/contentofobjectd.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"contentofobjectd.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/firststep.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"firststep.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/inderiveconstructor.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"inderiveconstructor.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/inderiveconstructorstack.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"inderiveconstructorstack.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/jumpoversupercall.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"jumpoversupercall.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/linkoptions.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"linkoptions.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/superconstructor.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"superconstructor.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/vbtablecontent.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"vbtablecontent.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter5/vsoptions.png","post":"cjivnhtpa001q2gusrrjdberd","slug":"vsoptions.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/AssignMemberFuncPointer.png","post":"cjivnhtp8001p2gusswucmssz","slug":"AssignMemberFuncPointer.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/FirstClassVariable.png","post":"cjivnhtp8001p2gusswucmssz","slug":"FirstClassVariable.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/NormalFunc1Addresses.png","post":"cjivnhtp8001p2gusswucmssz","slug":"NormalFunc1Addresses.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseConstructor.png","post":"cjivnhtp8001p2gusswucmssz","slug":"TestBaseConstructor.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseContentOfVirtualTable.png","post":"cjivnhtp8001p2gusswucmssz","slug":"TestBaseContentOfVirtualTable.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseInitSequence.png","post":"cjivnhtp8001p2gusswucmssz","slug":"TestBaseInitSequence.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseLookupThis.png","post":"cjivnhtp8001p2gusswucmssz","slug":"TestBaseLookupThis.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseVcall0.png","post":"cjivnhtp8001p2gusswucmssz","slug":"TestBaseVcall0.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseVirtualFunc2Function.png","post":"cjivnhtp8001p2gusswucmssz","slug":"TestBaseVirtualFunc2Function.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/TestBaseVirtualFunctionsAddress.png","post":"cjivnhtp8001p2gusswucmssz","slug":"TestBaseVirtualFunctionsAddress.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/TestDeriveAfterAssignVftable.png","post":"cjivnhtp8001p2gusswucmssz","slug":"TestDeriveAfterAssignVftable.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/TestDeriveConstructor.png","post":"cjivnhtp8001p2gusswucmssz","slug":"TestDeriveConstructor.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/TestDeriveVirtualFunctionAddress.png","post":"cjivnhtp8001p2gusswucmssz","slug":"TestDeriveVirtualFunctionAddress.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/TestDeriveVtableContent.png","post":"cjivnhtp8001p2gusswucmssz","slug":"TestDeriveVtableContent.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/dtTestBase.png","post":"cjivnhtp8001p2gusswucmssz","slug":"dtTestBase.png","modified":1,"renderable":1},{"_id":"source/_posts/windbg/windbg-chapter4/dtTestDerive.png","post":"cjivnhtp8001p2gusswucmssz","slug":"dtTestDerive.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjivnhtmy00022gus2eqqovmz","category_id":"cjivnhtn400042guswa4m4mh6","_id":"cjivnhtni000d2guspvc2jea8"},{"post_id":"cjivnhtn200032gusk1yg1mmp","category_id":"cjivnhtnd00092gus234jbe21","_id":"cjivnhtno000g2guspnfbnm7v"},{"post_id":"cjivnhtn600062gusm3dao6ax","category_id":"cjivnhtni000e2gusz775x9pl","_id":"cjivnhtnw000m2gusdloawcdy"},{"post_id":"cjivnhtn800072gustgla2oc0","category_id":"cjivnhtni000e2gusz775x9pl","_id":"cjivnhtny000p2gusda6hfuxr"},{"post_id":"cjivnhtnc00082guslinn7z4f","category_id":"cjivnhtnw000l2gusevcup6jm","_id":"cjivnhtnz000u2gus1emmpvid"},{"post_id":"cjivnhtne000b2gusea2baouz","category_id":"cjivnhtnw000l2gusevcup6jm","_id":"cjivnhto0000x2gusgnh9df0w"},{"post_id":"cjivnhtnh000c2gus6uvwuw1m","category_id":"cjivnhtnw000l2gusevcup6jm","_id":"cjivnhto1000z2gusuotvxd7m"},{"post_id":"cjivnhtp8001p2gusswucmssz","category_id":"cjivnhtnw000l2gusevcup6jm","_id":"cjivnhtpe001u2gus988qtafy"},{"post_id":"cjivnhtpa001q2gusrrjdberd","category_id":"cjivnhtnw000l2gusevcup6jm","_id":"cjivnhtpf001x2gus4m62abrc"},{"post_id":"cjivnhtpc001s2gusk70vz3lq","category_id":"cjivnhtnw000l2gusevcup6jm","_id":"cjivnhtpf001z2gus8j0sekbq"}],"PostTag":[{"post_id":"cjivnhtmy00022gus2eqqovmz","tag_id":"cjivnhtn500052gustk9y56z2","_id":"cjivnhtns000j2gusv2269dt6"},{"post_id":"cjivnhtmy00022gus2eqqovmz","tag_id":"cjivnhtnd000a2gushpmjcbvl","_id":"cjivnhtnu000k2gusoqt7nm47"},{"post_id":"cjivnhtmy00022gus2eqqovmz","tag_id":"cjivnhtnj000f2gusmgqft8au","_id":"cjivnhtnx000o2gus4c6rcps5"},{"post_id":"cjivnhtn200032gusk1yg1mmp","tag_id":"cjivnhtnq000i2gus8cmavjhd","_id":"cjivnhtnz000s2gus3mtzamco"},{"post_id":"cjivnhtn200032gusk1yg1mmp","tag_id":"cjivnhtnw000n2gus8807dc3l","_id":"cjivnhto0000v2gushmcerdhb"},{"post_id":"cjivnhtn600062gusm3dao6ax","tag_id":"cjivnhtny000r2gusr52xk6w1","_id":"cjivnhto200112gus1q5db3n1"},{"post_id":"cjivnhtn600062gusm3dao6ax","tag_id":"cjivnhtnd000a2gushpmjcbvl","_id":"cjivnhto200122gusmmcy6o0f"},{"post_id":"cjivnhtn600062gusm3dao6ax","tag_id":"cjivnhto1000y2gusqhn0o3lz","_id":"cjivnhto200142gusvel128ql"},{"post_id":"cjivnhtn800072gustgla2oc0","tag_id":"cjivnhtny000r2gusr52xk6w1","_id":"cjivnhto300172guslui0bsjy"},{"post_id":"cjivnhtn800072gustgla2oc0","tag_id":"cjivnhtnd000a2gushpmjcbvl","_id":"cjivnhto300182gusukcp3rz8"},{"post_id":"cjivnhtn800072gustgla2oc0","tag_id":"cjivnhto1000y2gusqhn0o3lz","_id":"cjivnhto4001a2gus9m601nwq"},{"post_id":"cjivnhtnc00082guslinn7z4f","tag_id":"cjivnhto300162gushg5hfi6u","_id":"cjivnhto5001d2gus7dbh7t8b"},{"post_id":"cjivnhtnc00082guslinn7z4f","tag_id":"cjivnhto300192gusbvyzmc1o","_id":"cjivnhto5001e2gussrlzsllw"},{"post_id":"cjivnhtnc00082guslinn7z4f","tag_id":"cjivnhtnd000a2gushpmjcbvl","_id":"cjivnhto5001g2gush92swa36"},{"post_id":"cjivnhtne000b2gusea2baouz","tag_id":"cjivnhto300162gushg5hfi6u","_id":"cjivnhto6001i2gusy9zzmpbd"},{"post_id":"cjivnhtne000b2gusea2baouz","tag_id":"cjivnhto300192gusbvyzmc1o","_id":"cjivnhto6001j2gusppos5rhn"},{"post_id":"cjivnhtne000b2gusea2baouz","tag_id":"cjivnhtnd000a2gushpmjcbvl","_id":"cjivnhto7001l2gusb7djsg3d"},{"post_id":"cjivnhtnh000c2gus6uvwuw1m","tag_id":"cjivnhto300162gushg5hfi6u","_id":"cjivnhto7001m2gus2p27ve2t"},{"post_id":"cjivnhtnh000c2gus6uvwuw1m","tag_id":"cjivnhto300192gusbvyzmc1o","_id":"cjivnhto7001n2gus03rypzgn"},{"post_id":"cjivnhtnh000c2gus6uvwuw1m","tag_id":"cjivnhtnd000a2gushpmjcbvl","_id":"cjivnhto7001o2gussxi37noz"},{"post_id":"cjivnhtp8001p2gusswucmssz","tag_id":"cjivnhto300162gushg5hfi6u","_id":"cjivnhtpb001r2guso7sg9vf8"},{"post_id":"cjivnhtp8001p2gusswucmssz","tag_id":"cjivnhto300192gusbvyzmc1o","_id":"cjivnhtpd001t2gus11opy1b2"},{"post_id":"cjivnhtp8001p2gusswucmssz","tag_id":"cjivnhtnd000a2gushpmjcbvl","_id":"cjivnhtpe001w2gusao8wdkfb"},{"post_id":"cjivnhtpa001q2gusrrjdberd","tag_id":"cjivnhto300162gushg5hfi6u","_id":"cjivnhtpf001y2gus67myw9ua"},{"post_id":"cjivnhtpa001q2gusrrjdberd","tag_id":"cjivnhto300192gusbvyzmc1o","_id":"cjivnhtpf00202guszv899qq1"},{"post_id":"cjivnhtpa001q2gusrrjdberd","tag_id":"cjivnhtnd000a2gushpmjcbvl","_id":"cjivnhtpg00212gusn67ujh0z"},{"post_id":"cjivnhtpc001s2gusk70vz3lq","tag_id":"cjivnhto300162gushg5hfi6u","_id":"cjivnhtpg00222gussmc9p4ck"},{"post_id":"cjivnhtpc001s2gusk70vz3lq","tag_id":"cjivnhto300192gusbvyzmc1o","_id":"cjivnhtpg00232gusih4p9coi"},{"post_id":"cjivnhtpc001s2gusk70vz3lq","tag_id":"cjivnhtnd000a2gushpmjcbvl","_id":"cjivnhtph00242gus2iznjycg"},{"post_id":"cjivnhtpc001s2gusk70vz3lq","tag_id":"cjivnhtpe001v2gusy5r06ta5","_id":"cjivnhtph00252gus0m4k0zaw"}],"Tag":[{"name":"windows","_id":"cjivnhtn500052gustk9y56z2"},{"name":"c++","_id":"cjivnhtnd000a2gushpmjcbvl"},{"name":"inject","_id":"cjivnhtnj000f2gusmgqft8au"},{"name":"blog","_id":"cjivnhtnq000i2gus8cmavjhd"},{"name":"hexo","_id":"cjivnhtnw000n2gus8807dc3l"},{"name":"algorithm","_id":"cjivnhtny000r2gusr52xk6w1"},{"name":"leetcode","_id":"cjivnhto1000y2gusqhn0o3lz"},{"name":"windbg","_id":"cjivnhto300162gushg5hfi6u"},{"name":"disassembly","_id":"cjivnhto300192gusbvyzmc1o"},{"name":"c","_id":"cjivnhtpe001v2gusy5r06ta5"}]}}