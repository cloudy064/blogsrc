---
title: WinDBG观世界（一）
date: 2016-04-10 12:19:11
categories: windbg
tags: [windbg,disassembly,c++]
---

## 导言
技术的研究是一个无底洞，如果想要在技术上有所突破，首先得耐得住寂寞，三分钟热度的激情、三天打鱼两天晒网都是不可取，确实能在这个浮躁的社会里面要想耐下性子来好好研究一番的人实在是不多。不妨打开浏览器、甚至是你的qq聊天工具，基本上到处都能看到XX天精通C++，月薪XXXX之类的话。其实后一句话才是重点，如果不是为了追求更好的生活，我想程序员的人数应该会减少一大半。我曾经把程序员分为几个档次:初级的就叫API Caller，粗俗一点就叫码农，只需要保证程序能够按照预期的情况运行，不出bug就行，当然这其实也是大多数程序员的愿望啦。至于为什么叫API Caller，大家看名字应该就知道了吧；中级的叫做Programmer，大多数人也处于这个等级中，我也不例外，属于靠着代码吃饭的同时，也会努力在代码的架构上和整洁上下一番功夫；再往上就是researcher和architect，属于小到技术细节，大到程序框架都能研究个透彻，并且能够信手拈来。好吧，扯远了，其实开心就好。我这次做WinDBG的博客，主要是和大家一起探讨一下程序背后的细节，所谓WinDBG观世界，其实就是程序的世界。这里我推荐大家可以看这本书《程序员的自我修养》，本专题和该书的内容有很大的联系，但是本系列内容只会涉及到windows编程，所使用的工具有Visual Studio 2005和WinDBG。通过对该系列文章的学习，你可以认识到程序编译到运行的原理，以及WinDBG的基本使用。那么闲话少叙，切入正题吧。
<!--more-->
## 第一个程序
Hello, World!

本着尽可能简单的思想，我把第一个程序简化成如下的样子：
```cpp
void TestFunc()
{
    int a = 10;
    int b = 20;

    int c = a + b;

    int d = a + 30;

    int e = 1 + 3;
}

int main(int argc, char** argv)
{
    TestFunc();
    return 0;
}
```
没有任何`include`，可能比Hello, World!都简单，但是这么简单的语句，
* 在经过编译器之后变成了什么样呢？
* 开了优化和没有开优化有什么区别呢？
* 它在生成了exe之后，exe里面又存放了哪些东西呢？
* 上面的变量和常量在exe中又是怎样体现的？

如果你对上面这些问题都了然于胸，那么这一章不适合你，你可以等下一章了。如果你对C++基本语法都无法理解，那么也很遗憾，本系列你看不懂。

那么仍然继续读下来的同学，首先要做的事情就是把上面这段代码敲到VS中，然后进行编译就行了。

## 一切都是有条不紊
这里我们针对Debug编译出来的程序作分析，打开你的WinDBG，然后按下`Ctrl+S`，在弹出的对话框中输入微软符号路径和本地符号路径，我的内容如下：
```
D:\localsymbols;SRV*D:\localsymbols*http://msdl.microsoft.com/download/symbols;
```
然后按下`Ctrl+E`，运行我们编译出来的程序。然后WinDBG展示如下：
{% asset_img runexe.png 程序执行界面 %}

我们需要在main函数执行的地方下一个断点，以便我们观察程序运行情况，那么我们可以使用下面的命令，然后回车：
```
bp HelloWorld2005!main
```

因为我的程序名字叫做HelloWorld2005，如果你的exe是其他名字记得调整。

输入g回车，WinDBG会执行到main函数时暂定，并自动帮你加载程序的源码。我们这里想了解的是程序背后运作的原理，所以这里更想看到的是汇编代码，很简单，按下`Alt+7`就可以了。

这个时候还没准备好开始调试，还需要把Debug下拉菜单中的Source Mode选项去掉，因为在加载了代码的情况下，WinDBG是以单句代码为单位进行调试的：
{% asset_img sourcemode.png Source Mode %}

那么从现在开始，调试的操作都和VS一样了，F10是Step Over，F11是Step Into,Shift+F11是Step Out。好了，我们先看汇编代码好了，一句一句来理解。从HelloWorld2005!main开始到ret为止，就是main函数的所有的实现了，怎么样很简短吧，但是也很让人头疼，因为分析起来也不是那么容易的：
{% asset_img disassembly.png 汇编代码 %}

首先看第一行，
```
push ebp
```
好吧，看到这一句想到的几个问题就是
* 它是干嘛的？
* ebp里面放了什么东西？

那么我这里只能大致告诉你这句话究竟发生了什么事情，因为说多了反而不好理解。

`push ebp`是将ebp寄存器中保存的值进行入栈操作，寄存器如果不明白的话，可以把寄存器当做是一个盒子，里面放了一些数值，并且一台电脑会提供给你多个盒子进行使用。你每次在单步调试时，WinDBG都会把这些盒子里面的数字展示给你看，如下图为当前的寄存器的状态：
{% asset_img registers.png 寄存器 %}

可以看到ebp中存放了0019ff78(Windbg中展示的数字都是十六进制的，没有前缀0x，但是可能会有后缀h)。它的含义其实是当前函数在堆栈上申请的内存的基地址，具体解释我之后会带出来，此处先不做过多说明。

然后就是push操作对ebp做了什么？有一定C++基础的同学一定都知道局部变量使用的是栈内存，而new出来的对象使用的是堆内存。这里push esp就是把ebp的内容放到栈上，那么这个栈在哪里呢？留着这个疑问，我们按下F10单步执行，观察前后的寄存器的值有什么不同：
{% asset_img pushebp.png push ebp %}

能看出来么？一共只有两个寄存器发生了变化，eip和esp。

我们这里不难发现，eip和汇编代码左边那堆数字好像有点关系，没错，这个寄存器永远都指向了下一步执行的代码的地址。恩恩，汇编代码左边的那8位数字就是该条汇编代码在该exe运行时的具体地址。

然后就是esp了，它才是这次的主角，它的值从0019ff2c变成了0019ff28，减少了4，而ebp的值是0019ff78，正好四个字节，这不是个巧合，esp永远都指向当前栈的栈顶。这次入栈操作一共经过下面两个步骤：
1. esp-4
2. [esp]=ebp

我们还可以通过Windbg命令来验证一下，输入`dd 0019ff28`即可查看0019ff28内存地址附近的内容，也可以直接输入`dd esp`。
{% asset_img pushresult.png push result %}

怎么样，第一个字节是不是和ebp的内容一样？这样的话ebp此时的值就可以认为是被保存了起来，并且如果以后需要用到该值，可以使用`pop ebp`来获取。

要想理解ebp的含义，那么不如在TestFunc的地方下一个断点，还记得什么指令么：`bp HelloWorld2005!TestFunc`。然后输入g，回车。我们便来到了TestFunc函数的入口处：
{% asset_img testfuncsource.png TestFunc disassembly %}

这时我们可以不忙着看汇编实现，尝试着输入kbn，来看下当前的函数调用堆栈：
{% asset_img callstack.png Callstack %}

这里我简单说明下程序执行遇到函数调用会发生什么动作（下面的顺序不代表动作的先后顺序）：
* 保存上一个函数的局部变量等信息
* 保存函数调用点
* 将函数调用参数入栈
* 调用函数

那么这里显示的函数调用堆栈，主要为我们展示了下面几个信息：
1. ChildEBP: 当前函数在堆栈上申请的内存的基地址
2. RetAddr: 函数的返回地址，或者理解为该函数返回后，继续执行的那个地址
3. Args to Child: 函数参数的值
4. 函数名和所在代码位置信息

那么这里ChildEBP和ebp寄存器名字相似绝对不是偶然，恩恩，你猜对了，ebp中保存的就是当前函数在堆栈上所使用的一小部分内存的基地址。众所周知，在函数中申请局部变量是需要消耗栈上内存的，那么在有多个函数调用发生时，为了能够不破坏彼此函数之间的堆栈信息，操作系统在函数调用时，会将其中一部分堆栈区间划分给该函数，而该函数如果想要申请局部变量，使用这块堆栈区间就可以了。比如下面这块代码：
```cpp
void func1()
{
  int a;
  int b;
}

void func2()
{
  int a;
  int b;
  func1();
}

int main()
{
  int a;
  int b;
  func2();
  return 0;
}
```
它们过程中形成的堆栈可能会如下图所示：
{% asset_img callstackstatus.png 堆栈内容 %}

每一个函数拥有自己的一个局部堆栈，然后在自己的局部堆栈中保存局部变量内容。如果发生了函数调用，那么就会把上一个函数的堆栈区间块的起始地址进行压栈，以便函数返回时对局部堆栈信息进行恢复。

所以每次函数调用一开始的两句话
```
push ebp
mov ebp, esp
```

就是为了做两个工作：
1. 保存上一个函数的局部堆栈起始地址
2. 更新本次函数局部堆栈的起始地址

还记得esp指向的是什么地方吗？恩，当前堆栈的顶部。所以这里需要注意的是，上一个函数的堆栈区间的结束地址就是本次函数堆栈区间的起始位置。但是到目前位置还没有为TestFunc函数分配堆栈空间，那么我们继续往下看：
```
sub esp, 0FCh
```

这里把esp的值减去0x0FC的大小，这样ebp~esp之间的区域就形成了TestFunc这个函数的局部堆栈区间了。

等等，那我怎么使用这块区间呢？你刚刚不是说使用push和pop来对堆栈进行操作的吗？怎么好像和你刚刚说的不一样呢？恩，用一分钟时间仔细想一想这些问题。想完之后，继续跟着我往下面一句一句执行：
```
push ebx
push esi
push edi
```

这四句话我目前不想解释，因为也不需要知道他们的用途，但是请记住它的结果，那就是esp减少了3*4=0ch，并且esp指向的是edi的值，esp+4指向的是esi的值，esp+8指向的是ebx的值，如下图所示：
{% asset_img pushebxesiedi.png 此时esp指向的内容 %}

同时现在局部堆栈内存分布的情况如下：
{% asset_img stackmemory.png 内存分布 %}

是不是现在一目了然了呢，内存地址由上而下依次变大，(ebp-0fch)~ebp的区间还没有做任何事情，然后由于刚刚压栈了三个寄存器，所以栈的顶部又出现了三个值。然后我们继续往下执行：
```
lea edi, [ebp-0FCh]
mov ecx, 3Fh
mov eax, 0CCCCCCCCh
rep stos dword ptr es:[edi]
```

我承认这四句话一开始我也不知道有啥用，直到我google了rep stos指令，其实这句话就是调用了一个函数，作用就是从es:edi指向的地址开始，以DWORD为单位，填充0CCCCCCCCh(eax)，一共填充3F(ecx)次，并且每次填充edi都会加上4，ecx减去1。我们可以计算一下一共是3F*4=FC个字节，正好和上面的预留的局部堆栈空间大小一致。所以这个函数在这里起到的作用其实就是初始化你预留的堆栈内存。而cc在汇编中其实就是int 3，触发一个中断。我猜windows这么做的原因应该就是为了阻止你的程序跑飞吧，因为如果执行到int 3时，你的程序就会崩溃。你也许会好奇es:edi指向的地址到底是多少，呵，好奇心是好的，只不过这个不是这次的重点，所以这次就不讲了，提供给你几个关键字，自己搜索一下吧：段寄存器，实地址模式，保护模式。这里es:edi的地址就是edi的值。

执行完这三句话之后，我们来比较一下前后寄存器的值变化，主要看ecx和edi:
{% asset_img afterrepstos.png 执行完rep stos %}

可以看出ecx变成了0，edi变成了0019fe54，值和ebp一样，稍微转一下脑筋其实就知道，上面的这三句话其实就可以翻译成下面的这段代码：
```cpp
while (ecx > 0)
{
  * esi = eax;
  esi += 4;
  ecx--;
}
```

其次我们可以继续通过dd的方式来查看内存的变化，不过我也推荐你按下`alt+5`，用Memory窗口来查看内存。然后在Virtual的输入框中输入edi初始的值，或者直接输入ebp-0fch：
{% asset_img afterrepstosmem.png 执行完rep stos之后的内存 %}

可以看到从(ebp-0fch)~ebp的区间，内存全部被清除为0CCCCCCCCh了，恩，就是这么神奇。那位同学，你先别急着走啊喂，坐下，我现在就开始讲函数主体了。

第一句是`int a = 10;`，简单声明了一个变量a，并给他赋值为10，那么我们到汇编里面找找看这个a在哪里。诶，好像整个函数里面都没有单独出现a这个字符？难道是优化？No！还记得以前老师说过或者看书看到，变量名不占任何空间，它只是一个标识符。那么a这个变量它标识的起始就是[ebp-8]这个地址开始的一个DWORD，windows汇编中DWORD就是4个字节，额，你要问我为什么exe能够记住每个地址对应于哪个变量啊，编译器生成的指令呗（有兴趣的可以去看下编译器设计中的代码生成）。所以`int a = 10;`这句话起始就被编译成了`mov dword ptr [ebp-8], 0Ah`。能够在上面我画的图里面指出[ebp-8]位于哪里么？
{% asset_img aftera10.png 执行完int a = 10 %}

如果你要问我为什么中间留出了4个字节没有用，额......好吧我不知道，诚信。我们继续往下看吧。

所以`int b = 20;`这句代码也不用我说了吧，虽然他中间还是空出来了8个字节。

接下来`int c = a + b;`，它对应于汇编中的语句是下面三句：
```
mov eax, dword ptr [ebp-8]
add eax, dword ptr [ebp-14h]
mov dword ptr [ebp-20h], eax
```

你可能会觉得好繁琐，为什么要先把`dword ptr [ebp-8]`指向的值放到eax中？这个就认了吧，人家硬件厂商提供给你的add指令必须要在寄存器上操作，你有什么办法。所以在得到a和b的和之后，再将值放到ebp-20h指向的地址上。下面的`int d = a + 30;`也是同理，所以会形成下图所示的内存结构：
{% asset_img afterda30.png 执行完int d= a + 30 %}

最后一句最神奇，汇编里面直接把`int e = 1 + 3;`翻译成了`mov dword ptr [ebp-38h], 4`，也就是说编译器在编译的时候已经帮你把1+3的结果给你算出来了。

那么到现在为止，函数的主体已经展示完成了。那么现在到了函数结束清理堆栈的时间了。

下面的三句和上面的三个push执行了一个逆操作：
```
pop edi
pop esi
pop ebx
```

这里就是恢复了上一个函数的堆栈情况。

对于下面一条语句
```
mov esp, ebp
```
由于上一个函数堆栈的结束位置和本次调用函数的开始位置相等，所以当前ebp的值其实就等于上一个函数esp的值，所以这里其实就起到了恢复局部堆栈的栈顶地址的作用。

最后一句`pop ebp`和函数调用最开始的`push ebp`相对应，恢复上一个函数的局部堆栈基地址。

那么关于TestFunc的调用已经全部讲完了。我们再次回到main函数中，其实接下来执行的语句和刚刚分析TestFunc差不多，不过这里又多了下面这几句：
{% asset_img checkesp.png 检查ESP %}

为什么能够直接用ebp得到esp上一次的值，还要用esp-0C0h这么麻烦呢？其实这里的作用只是为了检查堆栈是否出现了异常，如果堆栈异常了，esp-0c0h的值可能就不等于ebp，这里仅仅做了一个简单的检查处理。

所以第一期就先讲到这里吧。虽然还有它的优化版本，带参数的函数，函数的重载这些还没讲，不过下次再补上吧。拜拜


## 回顾：

### 关于WinDBG
1. dp 模块名!函数名 用来给一个函数下断点。然后F10单步调试，F11进入到函数实现，Shift+F11跳出函数
2. alt+7 打开反汇编代码
3. alt+5 打开内存窗口
4. dd 内存地址 用来查看该内存地址下的内容
5. kbn 显示当前函数调用堆栈信息

### 关于汇编
1. ebp记录了当前函数局部堆栈的基地址，esp记录了当前堆栈的栈顶；随着函数的调用和返回，ebp会被不断的压栈和出栈；调用函数的esp和被调用函数的ebp相等
2. 函数内局部变量以ebp为基地址，从预留的堆栈空间中分配内存的，esp不会发生变化；而push和pop操作，esp则会发生改变
3. rep stos指令用于给内存进行赋值，内容记录在eax中，赋值次数记录在ecx中；每次赋值eax都会减1
4. 再有简单运算可以在编译期决定时，编译期会为你进行优化。
